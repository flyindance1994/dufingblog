{"_id":{"$oid":"51d3dd0a8ece70c438000008"},"classid":"200","comment":0,"content":"问题从做一个布局的水平居中开始，比如：\r\n\r\n   \r\n（head省略）\r\n   \r\n\r\n要让wrapper定宽并水平居中，需要\r\n```css\r\n#wrapper {width:960px;margin:0 auto;}\r\n```\r\n即可，但是在IE的怪异模式下需要加上\r\n```css\r\nbody {text-align:center;} #wrapper {text-align:left;}\r\n```\r\n曾经一度认为这个是IE6的hack，正确认识后，这只是IE在怪异模式下才有的问题，那么，通常什么什么情况下会触发IE的怪异模式：\r\n1.没写DOCTYPE，这个最常见；\r\n2.写了DOCTYPE，但不在文档的第一行，实验证明，在DOCTYPE之前有任何非空字符都会触发IE6的怪异模式，在IE7下，DOCTYPE之前有XML的文档声明并不触发，但是在DOCTYPE和XML文档声明之间有任何非空字符仍然会触发。\r\n\r\n所以，为了不触发怪异模式，要保证DOCTYPE写在整个html文档的第一行。","pubtime":{"$date":1351674755399},"title":"IE下“怪异模式”的触发  ","visited":32351,"links":[["51d3de828ece70c43800000e",{"present":0.052631578947368418131,"title":"Internet Explorer 10 兼容性白皮书（一） "}],["51d3dfda8ece70c438000012",{"present":0.025641025641025640136,"title":"jQuery新的事件绑定机制on()"}],["51d3dc538ece70c438000005",{"present":0.025641025641025640136,"title":"小心 -webkit-text-size-adjust:none！[译]"}],["51d3dff38ece70c438000014",{"present":0.025641025641025640136,"title":"css cursor 属性 示例"}],["53995f446b13b74d15000001",{"present":0.025641025641025640136,"title":"Flexbox 布局完全解析"}],["5349905d7eeca8ec50000001",{"present":0.025641025641025640136,"title":"manifest 详解以及规范"}]],"html":"<p>问题从做一个布局的水平居中开始，比如：</p>\n<p>（head省略）</p>\n<p>要让wrapper定宽并水平居中，需要</p>\n<pre><code class=\"lang-css\">#wrapper {width:960px;margin:0 auto;}\n</code></pre>\n<p>即可，但是在IE的怪异模式下需要加上</p>\n<pre><code class=\"lang-css\">body {text-align:center;} #wrapper {text-align:left;}\n</code></pre>\n<p>曾经一度认为这个是IE6的hack，正确认识后，这只是IE在怪异模式下才有的问题，那么，通常什么什么情况下会触发IE的怪异模式：\n1.没写DOCTYPE，这个最常见；\n2.写了DOCTYPE，但不在文档的第一行，实验证明，在DOCTYPE之前有任何非空字符都会触发IE6的怪异模式，在IE7下，DOCTYPE之前有XML的文档声明并不触发，但是在DOCTYPE和XML文档声明之间有任何非空字符仍然会触发。</p>\n<p>所以，为了不触发怪异模式，要保证DOCTYPE写在整个html文档的第一行。</p>\n"}
{"_id":{"$oid":"51d3dfda8ece70c438000012"},"classid":"100","comment":0,"content":"今天浏览jQuery的deprecated列表，发现live()和die()在里面了，赶紧看了一下，发现从jQuery1.7开始，jQuery引入了全新的事件绑定机制，on()和off()两个函数统一处理事件绑定。因为在此之前有bind(), live(), delegate()等方法来处理事件绑定，jQuery从性能优化以及方式统一方面考虑决定推出新的函数来统一事件绑定方法并且替换掉以前的方法。\r\n\r\n``` javascript\r\non(events,[selector],[data],fn)\r\n\r\nevents:一个或多个用空格分隔的事件类型和可选的命名空间，如\"click\"或\"keydown.myPlugin\" 。\r\nselector:一个选择器字符串用于过滤器的触发事件的选择器元素的后代。如果选择器为null或省略，当它到达选定的元素，事件总是触发。\r\ndata:当一个事件被触发时要传递event.data给事件处理函数。\r\nfn:该事件被触发时执行的函数。 false 值也可以做一个函数的简写，返回false。\r\n```\r\n\r\n替换bind()\r\n\r\n当第二个参数'selector'为null时，on()和bind()其实在用法上基本上没有任何区别了，所以我们可以认为on()只是比bind()多了一个可选的'selector'参数，所以on()可以非常方便的替换掉bind()\r\n\r\n替换live()\r\n\r\n在1.4之前相信大家非常喜欢使用live(),因为它可以把事件绑定到当前以及以后添加的元素上面，当然在1.4之后delegate()也可以做类似的事情了。live()的原理很简单，它是通过document进行事件委派的，因此我们也可以使用on()通过将事件绑定到document来达到live()一样的效果。\r\nlive()写法\r\n\r\n``` javascript\r\n$('#list li').live('click', '#list li', function() {\r\n  //function code here.\r\n});\r\n```\r\n\r\non()写法\r\n\r\n``` javascript\r\n$(document).on('click', '#list li', function() {\r\n   //function code here.\r\n});\r\n```\r\n\r\n这里的关键就是第二个参数'selector'在起作用了。它是一个过滤器的作用，只有被选中元素的后代元素才会触发事件。\r\n\r\n替换delegate()\r\n\r\ndelegate()是1.4引入的，目的是通过祖先元素来代理委派后代元素的事件绑定问题，某种程度上和live()优点相似。只不过live()是通过document元素委派，而delegate则可以是任意的祖先节点。使用on()实现代理的写法和delegate()基本一致。\r\ndelegate()的写法\r\n\r\n``` javascript\r\n$('#list').delegate('li', 'click', function() {\r\n   //function code here.\r\n});\r\n```\r\non()写法\r\n``` javascript\r\n$('#list').on('click', 'li', function() {\r\n  //function code here.\r\n});\r\n```\r\n貌似第一个和第二个参数的顺序颠倒了一下，别的基本一样。\r\n\r\n总结\r\n\r\n jQuery推出on()的目的有2个，一是为了统一接口，二是为了提高性能，所以从现在开始用on()替换bind(), live(), delegate吧。尤其是不要再用live()了，因为它已经处于不推荐使用列表了，随时会被干掉。如果只绑定一次事件，那接着用one()吧，这个没有变化。\r\n","pubtime":{"$date":1372839898914},"title":"jQuery新的事件绑定机制on()","visited":30423,"links":[["51d3dc6c8ece70c438000006",{"present":0.081081081081081085582,"title":"jQuery.proxy(function,obj)"}],["51d3dd2e8ece70c43800000a",{"present":0.052631578947368418131,"title":"CSS的优先级特性 "}],["5349905d7eeca8ec50000001",{"present":0.052631578947368418131,"title":"manifest 详解以及规范"}],["54687208a02135883f000002",{"present":0.025641025641025640136,"title":"webGL 学习手记 | webGL 教程 （一）"}],["54817f6ea02135883f000004",{"present":0.025641025641025640136,"title":"使用缓冲区以及GLSL变量 - webGL 学习手记 | webGL 教程 （三）"}],["5242d5fc9ab354383d000001",{"present":0.025641025641025640136,"title":"CSS3 实现iOS7毛玻璃模糊效果 (iOS7 live blur)"}],["51d3dd0a8ece70c438000008",{"present":0.025641025641025640136,"title":"IE下“怪异模式”的触发  "}],["51f6519532ffd70b27000001",{"present":0.025641025641025640136,"title":"HTML5 File api 实现断点续传"}],["547f1ccfa02135883f000003",{"present":0.025641025641025640136,"title":"webGL 学习手记 | webGL 教程 （二）"}]],"html":"<p>今天浏览jQuery的deprecated列表，发现live()和die()在里面了，赶紧看了一下，发现从jQuery1.7开始，jQuery引入了全新的事件绑定机制，on()和off()两个函数统一处理事件绑定。因为在此之前有bind(), live(), delegate()等方法来处理事件绑定，jQuery从性能优化以及方式统一方面考虑决定推出新的函数来统一事件绑定方法并且替换掉以前的方法。</p>\n<pre><code class=\"lang-javascript\">on(events,[selector],[data],fn)\n\nevents:一个或多个用空格分隔的事件类型和可选的命名空间，如&quot;click&quot;或&quot;keydown.myPlugin&quot; 。\nselector:一个选择器字符串用于过滤器的触发事件的选择器元素的后代。如果选择器为null或省略，当它到达选定的元素，事件总是触发。\ndata:当一个事件被触发时要传递event.data给事件处理函数。\nfn:该事件被触发时执行的函数。 false 值也可以做一个函数的简写，返回false。\n</code></pre>\n<p>替换bind()</p>\n<p>当第二个参数&#39;selector&#39;为null时，on()和bind()其实在用法上基本上没有任何区别了，所以我们可以认为on()只是比bind()多了一个可选的&#39;selector&#39;参数，所以on()可以非常方便的替换掉bind()</p>\n<p>替换live()</p>\n<p>在1.4之前相信大家非常喜欢使用live(),因为它可以把事件绑定到当前以及以后添加的元素上面，当然在1.4之后delegate()也可以做类似的事情了。live()的原理很简单，它是通过document进行事件委派的，因此我们也可以使用on()通过将事件绑定到document来达到live()一样的效果。\nlive()写法</p>\n<pre><code class=\"lang-javascript\">$(&#39;#list li&#39;).live(&#39;click&#39;, &#39;#list li&#39;, function() {\n  //function code here.\n});\n</code></pre>\n<p>on()写法</p>\n<pre><code class=\"lang-javascript\">$(document).on(&#39;click&#39;, &#39;#list li&#39;, function() {\n   //function code here.\n});\n</code></pre>\n<p>这里的关键就是第二个参数&#39;selector&#39;在起作用了。它是一个过滤器的作用，只有被选中元素的后代元素才会触发事件。</p>\n<p>替换delegate()</p>\n<p>delegate()是1.4引入的，目的是通过祖先元素来代理委派后代元素的事件绑定问题，某种程度上和live()优点相似。只不过live()是通过document元素委派，而delegate则可以是任意的祖先节点。使用on()实现代理的写法和delegate()基本一致。\ndelegate()的写法</p>\n<pre><code class=\"lang-javascript\">$(&#39;#list&#39;).delegate(&#39;li&#39;, &#39;click&#39;, function() {\n   //function code here.\n});\n</code></pre>\n<p>on()写法</p>\n<pre><code class=\"lang-javascript\">$(&#39;#list&#39;).on(&#39;click&#39;, &#39;li&#39;, function() {\n  //function code here.\n});\n</code></pre>\n<p>貌似第一个和第二个参数的顺序颠倒了一下，别的基本一样。</p>\n<p>总结</p>\n<p> jQuery推出on()的目的有2个，一是为了统一接口，二是为了提高性能，所以从现在开始用on()替换bind(), live(), delegate吧。尤其是不要再用live()了，因为它已经处于不推荐使用列表了，随时会被干掉。如果只绑定一次事件，那接着用one()吧，这个没有变化。</p>\n"}
{"_id":{"$oid":"51d3dc6c8ece70c438000006"},"classid":"100","comment":0,"content":"无意中看到proxy，以前不曾用到过，记录之！ jquery1.4新增，返回一个新函数，并且这个函数始终保持了特定的作用域。 当有事件处理函数要附加到元素上，但他们的作用域实际是指向另一个对象时，这个方法最有用了。此外，最妙的是，jQuery能够确保即便你绑定的函数是经过jQuery.proxy()处理过的函数，你依然可以传递原先的函数来准确无误地取消绑定。请参考下面的例子。 这个函数还有另一种用法，jQuery.proxy( scope, name )。第一个参数是要设定的作用域对象。第二个参数是将要设置作用域的函数名（必须是第一个作用域对象的一个属性）。 看起来有点call/apply的意思是不是？ 示例：\r\n\r\n``` javascirpt\r\nvar obj = {  name: \"John\",  test: function() {    alert( this.name );   \r\n$(\"#test\").unbind(\"click\", obj.test);  } }; \r\n$(\"#test\").click( jQuery.proxy( obj, \"test\" ) );\r\n // 以下代码跟上面那句是等价的:\r\n // $(\"#test\").click( jQuery.proxy( obj.test, obj ) );\r\n // 可以与单独执行下面这句做个比较。 \r\n// $(\"#test\").click( obj.test ); 前两种输出的是指定的作用域obj，所以弹出john，后一种this.name将只想window.name，弹出undefined\r\n```","pubtime":{"$date":1351518001812},"title":"jQuery.proxy(function,obj)","visited":29551,"links":[["51d3dfda8ece70c438000012",{"present":0.081081081081081085582,"title":"jQuery新的事件绑定机制on()"}],["547f1ccfa02135883f000003",{"present":0.025641025641025640136,"title":"webGL 学习手记 | webGL 教程 （二）"}]],"html":"<p>无意中看到proxy，以前不曾用到过，记录之！ jquery1.4新增，返回一个新函数，并且这个函数始终保持了特定的作用域。 当有事件处理函数要附加到元素上，但他们的作用域实际是指向另一个对象时，这个方法最有用了。此外，最妙的是，jQuery能够确保即便你绑定的函数是经过jQuery.proxy()处理过的函数，你依然可以传递原先的函数来准确无误地取消绑定。请参考下面的例子。 这个函数还有另一种用法，jQuery.proxy( scope, name )。第一个参数是要设定的作用域对象。第二个参数是将要设置作用域的函数名（必须是第一个作用域对象的一个属性）。 看起来有点call/apply的意思是不是？ 示例：</p>\n<pre><code class=\"lang-javascirpt\">var obj = {  name: &quot;John&quot;,  test: function() {    alert( this.name );   \n$(&quot;#test&quot;).unbind(&quot;click&quot;, obj.test);  } }; \n$(&quot;#test&quot;).click( jQuery.proxy( obj, &quot;test&quot; ) );\n // 以下代码跟上面那句是等价的:\n // $(&quot;#test&quot;).click( jQuery.proxy( obj.test, obj ) );\n // 可以与单独执行下面这句做个比较。 \n// $(&quot;#test&quot;).click( obj.test ); 前两种输出的是指定的作用域obj，所以弹出john，后一种this.name将只想window.name，弹出undefined\n</code></pre>\n"}
{"_id":{"$oid":"51d3de728ece70c43800000d"},"classid":"100","comment":0,"content":"经常会用到判断不同浏览器的时候，\r\n这里给出几个区分ie的几款浏览器的方法，\r\n首先判断IE浏览器，主要是通过ActiveXObject这个IE特有的对象来区分是否是IE浏览器，\r\n在此基础上，可以通过XMLHttpRequest来判断是否是IE6，通过documentMode来判断IE8。\r\n至于IE7这里没有给出特别的方法，当然了目前出了IE10，所以要考虑的问题就没有这么简单了，至于如何区分IE10，等我拿到10测试之后再贴出来。\r\n``` javascript\r\nvar isIE=!!window.ActiveXObject;\r\nvar isIE6=isIE&&!window.XMLHttpRequest;\r\nvar isIE8=isIE&&!!document.documentMode;\r\nvar isIE7=isIE&&!isIE6&&!isIE8;\r\nif (isIE){\r\n    if (isIE6){\r\n        alert(”ie6″);\r\n    }else if (isIE8){\r\n        alert(”ie8″);\r\n    }else if (isIE7){\r\n        alert(”ie7″);\r\n    }\r\n}\r\n```","pubtime":{"$date":1352578416725},"title":"javascript区分判断ie6、ie7、ie8","visited":28048,"links":[["51d3de828ece70c43800000e",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（一） "}],["53eb8e22b55b886a13000001",{"present":0.025641025641025640136,"title":"我是如何发布版本的"}],["51d3dc538ece70c438000005",{"present":0.025641025641025640136,"title":"小心 -webkit-text-size-adjust:none！[译]"}],["558d74f22eacbd9648000001",{"present":0.025641025641025640136,"title":"Nodejs实现可训练的中文分词实践"}],["5524f05cfd9753d106000001",{"present":0.025641025641025640136,"title":"Window.postMessage() HTML5 跨域解决方案"}],["5534ec4efd9753d106000002",{"present":0.025641025641025640136,"title":"JavaScript 对象转换,toString,valueOf"}],["51d3de628ece70c43800000c",{"present":0.025641025641025640136,"title":"onhashchange与AJAX无缝刷新"}],["51d3de8e8ece70c43800000f",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（二） 用HTML5构建应用程序"}]],"html":"<p>经常会用到判断不同浏览器的时候，\n这里给出几个区分ie的几款浏览器的方法，\n首先判断IE浏览器，主要是通过ActiveXObject这个IE特有的对象来区分是否是IE浏览器，\n在此基础上，可以通过XMLHttpRequest来判断是否是IE6，通过documentMode来判断IE8。\n至于IE7这里没有给出特别的方法，当然了目前出了IE10，所以要考虑的问题就没有这么简单了，至于如何区分IE10，等我拿到10测试之后再贴出来。</p>\n<pre><code class=\"lang-javascript\">var isIE=!!window.ActiveXObject;\nvar isIE6=isIE&amp;&amp;!window.XMLHttpRequest;\nvar isIE8=isIE&amp;&amp;!!document.documentMode;\nvar isIE7=isIE&amp;&amp;!isIE6&amp;&amp;!isIE8;\nif (isIE){\n    if (isIE6){\n        alert(”ie6″);\n    }else if (isIE8){\n        alert(”ie8″);\n    }else if (isIE7){\n        alert(”ie7″);\n    }\n}\n</code></pre>\n"}
{"_id":{"$oid":"51d3dfe68ece70c438000013"},"classid":"100","comment":1,"content":"在写一个javascript截图功能的时候,想获取一个没有定义css的div的宽度，于是使用了\r\n\r\n``` javascript\r\nvar a=doucment.getElementById('dom').style.width\r\n```\r\n\r\n结果惊奇的发现获取到的值是undefined... WHY??\r\n\r\n尝试了offsetWidth结果发现不是自己想要的值，突然想到曾经看到过computerStyle之类的东西，于是百度之，终于知道为什么了。\r\n\r\n``` javascript\r\nstyle                  //只能获取元素的内联样式，内部样式和外部样式使用style是获取不到的。\r\ncurrentStyle         //可以弥补style的不足，但是只适用于IE。\r\ngetComputedStyle     //同currentStyle作用相同，但是适用于FF、opera、safari、chrome。\r\n```\r\n\r\n研究之后发现了可以用getComputedStyle来获取\r\n\r\n``` javascript\r\ngetStyle: function(element,attr){\r\n     return （el.currentStyle?el.currentStyle:getComputedStyle(el,null))[attr];\r\n}\r\n```","pubtime":{"$date":1355862286900},"title":"javascript获取元素的宽度、高度","visited":28106,"links":[["5534ec4efd9753d106000002",{"present":0.025641025641025640136,"title":"JavaScript 对象转换,toString,valueOf"}],["51d3dff38ece70c438000014",{"present":0.025641025641025640136,"title":"css cursor 属性 示例"}],["52300d0063c944475b000001",{"present":0.025641025641025640136,"title":"Atwood定律：“任何可以使用JavaScript来编写的应用，最终会由JavaScript编写。”"}]],"html":"<p>在写一个javascript截图功能的时候,想获取一个没有定义css的div的宽度，于是使用了</p>\n<pre><code class=\"lang-javascript\">var a=doucment.getElementById(&#39;dom&#39;).style.width\n</code></pre>\n<p>结果惊奇的发现获取到的值是undefined... WHY??</p>\n<p>尝试了offsetWidth结果发现不是自己想要的值，突然想到曾经看到过computerStyle之类的东西，于是百度之，终于知道为什么了。</p>\n<pre><code class=\"lang-javascript\">style                  //只能获取元素的内联样式，内部样式和外部样式使用style是获取不到的。\ncurrentStyle         //可以弥补style的不足，但是只适用于IE。\ngetComputedStyle     //同currentStyle作用相同，但是适用于FF、opera、safari、chrome。\n</code></pre>\n<p>研究之后发现了可以用getComputedStyle来获取</p>\n<pre><code class=\"lang-javascript\">getStyle: function(element,attr){\n     return （el.currentStyle?el.currentStyle:getComputedStyle(el,null))[attr];\n}\n</code></pre>\n"}
{"_id":{"$oid":"51d3db7f8ece70c438000003"},"classid":"400","comment":3,"content":"近来，笔者经常在一些报刊、杂志或互联网上看到“登lu网站”一词使用不规范、不统一，甚至错误使用的现象。有的使用“登陆”，有的使用“登录”，为了避免以讹传讹，纠正错误用法，规范正确用法，笔者认为有必要解释几句。\r\n\r\n   \r\n当今，我们生活在互联网时代，网络成为人们查询和传递信息的高效路径和载体。“登lu网站”一词被频繁使用，其正确用法应该是“登陆”，而非“登录”。这从两个词的词意区别上就可以看出。\r\n\r\n   \r\n从词意上看，我们知道“登陆”一词为动词，其原意在商务印书馆出版的《现代汉语词典》中解释为:“渡过海洋或江河登上陆地……”关键在于有“登上”之意。\r\n\r\n   \r\n从词性上看，“登陆”一词具有从下到上，从外到里进入之意。而互联网作为一种载体犹如“陆地”，要想从外进入其中就必须“登陆”。所以“登陆”互联网就有进入成功和失败，登上网站与没登上网站之分。\r\n\r\n   \r\n而“登录”一词则为记载、登记、记录、录制、抄写之意。重点强调的是“记录”之意，其词意中根本没有“登入”、“进入”之意。\r\n\r\n   \r\n由此可见，无论从词意还是从词性上讲，登入、进入网站，正确的用法应该是“登陆”，若使用“登录”则是说不通的。所以，不能将“登陆”与“登录”混为一谈。\r\n\r\n   \r\n转自 http://tech.sina.com.cn/i/2007-05-01/15331493962.shtml","pubtime":{"$date":1341825340944},"title":"“登陆网站”还是“登录网站”","visited":28211,"links":[["51d3de828ece70c43800000e",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（一） "}],["51d3dff38ece70c438000014",{"present":0.025641025641025640136,"title":"css cursor 属性 示例"}],["51d3dfc98ece70c438000011",{"present":0.025641025641025640136,"title":"Youtube Google要回来了？谷歌逆袭？非诚勿扰YouTube广告宣传谷歌"}],["51d3db3b8ece70c438000001",{"present":0.025641025641025640136,"title":"开张啦！"}],["52288399917d2e280e000001",{"present":0.025641025641025640136,"title":"给正在实习和将要实习的大学生——实习经验分享"}]],"html":"<p>近来，笔者经常在一些报刊、杂志或互联网上看到“登lu网站”一词使用不规范、不统一，甚至错误使用的现象。有的使用“登陆”，有的使用“登录”，为了避免以讹传讹，纠正错误用法，规范正确用法，笔者认为有必要解释几句。</p>\n<p>当今，我们生活在互联网时代，网络成为人们查询和传递信息的高效路径和载体。“登lu网站”一词被频繁使用，其正确用法应该是“登陆”，而非“登录”。这从两个词的词意区别上就可以看出。</p>\n<p>从词意上看，我们知道“登陆”一词为动词，其原意在商务印书馆出版的《现代汉语词典》中解释为:“渡过海洋或江河登上陆地……”关键在于有“登上”之意。</p>\n<p>从词性上看，“登陆”一词具有从下到上，从外到里进入之意。而互联网作为一种载体犹如“陆地”，要想从外进入其中就必须“登陆”。所以“登陆”互联网就有进入成功和失败，登上网站与没登上网站之分。</p>\n<p>而“登录”一词则为记载、登记、记录、录制、抄写之意。重点强调的是“记录”之意，其词意中根本没有“登入”、“进入”之意。</p>\n<p>由此可见，无论从词意还是从词性上讲，登入、进入网站，正确的用法应该是“登陆”，若使用“登录”则是说不通的。所以，不能将“登陆”与“登录”混为一谈。</p>\n<p>转自 <a href=\"http://tech.sina.com.cn/i/2007-05-01/15331493962.shtml\">http://tech.sina.com.cn/i/2007-05-01/15331493962.shtml</a></p>\n"}
{"_id":{"$oid":"52cfc44ad4cf86262b000001"},"classid":"100","comment":0,"content":"### 引子\r\n\r\nDrag和Drop是众多HTML5的令人兴奋的功能之一，它支持主流的现代浏览器，甚至是最新版本的IE哦！赞一个！\r\n\r\n最近Google放出了一个新的功能，可以从浏览器拖动文件到指定的文件夹里，没错，你没有听错，是任意一个你想拖动到的文件夹。听到这里是不是已经让各位极客们很兴奋了呢？！\r\n\r\n最初是L兄告诉我Gmail附件有这个功能，试了一下果然很神奇，居然真的可以把文件从网页里面拖到任何一个操作系统中的文件夹中，完成下载过程。\r\n\r\n查了很多很多资料，最终也找到了实现的方法，这里分享一下我所知道的一切。\r\n\r\n-----\r\n\r\n### 实现\r\n\r\n实现这个功能目前我们只需要以下几样东西：\r\n\r\n* Chrome\r\n* dragstart事件支持\r\n* 下载文件路径，下载的文件类型，下载的文件名\r\n\r\n相信这几样东西应该不是很难弄取到吧~\r\n\r\n接下来我们就要开工了：\r\n\r\n-----\r\n\r\n##### 1.  首先我们需要判断浏览器是否支持拖动事件。\r\n\r\n\r\n属性映射经常用来测试浏览器对HTML5 API属性的支持情况。比如，通过寻找draggable属性，检查带有[draggable=\"true\"]的元素支持\\*\\* Drag and Drop API\\*\\*：\r\n\r\n```javascript\r\n    \"draggable\" in document.createElement(\"div\");\r\n\r\n     //截至写这篇文章的时候还是只有chrome支持该功能\r\n    /chrome/.test( navigator.userAgent.toLowerCase() );\r\n````\r\n\r\n如果一切顺利，那么恭喜你可以进入接下来的游戏环节了\r\n\r\n##### 2.拼装地址\r\n\r\n拖动下载对文件地址的要求比较高，必须是如下格式的才能进行拖拽下载：\r\n\r\n    {MiME}:{FileName}:{FileUrl}\r\n\r\n如：\r\n\r\n    image/jpeg:Penguins.jpg:https://www.box.net/box_download_file?file_id=f66690\r\n\r\n经过实践，只有以上3个参数都正常的时候，该功能才能正常运行。\r\n\r\n##### 3.“安装”事件\r\n\r\n以上的工作完成之后，接下来就是绑定事件了。\r\n\r\n```javascript\r\nvar url='image/jpeg:Penguins.jpg:https://www.box.net/box_download_file?file_id=f66690';\r\n\r\ndocument.body.addEventListener(\"dragstart\",function(e) {\r\n    e.dataTransfer.setData(\"DownloadURL\",  url);\r\n});\r\n\r\n```\r\n好了，万事俱备只欠东风，现在回到你的浏览器，尽情的拖动图片文本等一切可以拖动的元素吧，把它拖到，文件夹中，是不是可以看到一个名为Penguins.jpg的文件已经安详的躺在了你拖动的文件夹里面了？哈哈 是不是很神奇\r\n\r\n---\r\n\r\n#### 废话\r\n\r\n好啦功能实现了，不得不多巴拉巴拉几句，个人认为这虽然是个很好的用户体验，但是很有可能成为鸡肋功能。\r\n1.浏览器兼容性，截至目前只有Chrome浏览器支持，不过对于谷歌来说，推广开来形成影响力不是问题。\r\n2.安全性，理论上用户拖拽下来的文件可以来着任何域，然后文件名、文件类型js都可以随意修改，如果别有用心的人，在网页中加入了一个恶意的js，替换拖拽的路径，把恶意文件伪装成和你要下载的文件是同一个文件名的文件，会怎样？\r\n\r\n---\r\n\r\n#### 还是废话\r\n\r\n你可能想继续了解：\r\n[HTML5 File api 实现断点续传](http://www.zhuwenlong.com/blog/51f6519532ffd70b27000001)\r\n\r\n","pubtime":{"$date":1389347914969},"title":"HTML5 拖动（Drag）文件到文件夹下载","visited":6551,"links":[["51f6519532ffd70b27000001",{"present":0.081081081081081085582,"title":"HTML5 File api 实现断点续传"}],["52d6769f93dcae3050000003",{"present":0.052631578947368418131,"title":"HTML5 file api 读取文件MD5码"}],["51d3de8e8ece70c43800000f",{"present":0.052631578947368418131,"title":"Internet Explorer 10 兼容性白皮书（二） 用HTML5构建应用程序"}],["51d3de828ece70c43800000e",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（一） "}],["53eb8e22b55b886a13000001",{"present":0.025641025641025640136,"title":"我是如何发布版本的"}],["51d3de628ece70c43800000c",{"present":0.025641025641025640136,"title":"onhashchange与AJAX无缝刷新"}],["5349905d7eeca8ec50000001",{"present":0.025641025641025640136,"title":"manifest 详解以及规范"}]],"html":"<h3 id=\"-\">引子</h3>\n<p>Drag和Drop是众多HTML5的令人兴奋的功能之一，它支持主流的现代浏览器，甚至是最新版本的IE哦！赞一个！</p>\n<p>最近Google放出了一个新的功能，可以从浏览器拖动文件到指定的文件夹里，没错，你没有听错，是任意一个你想拖动到的文件夹。听到这里是不是已经让各位极客们很兴奋了呢？！</p>\n<p>最初是L兄告诉我Gmail附件有这个功能，试了一下果然很神奇，居然真的可以把文件从网页里面拖到任何一个操作系统中的文件夹中，完成下载过程。</p>\n<p>查了很多很多资料，最终也找到了实现的方法，这里分享一下我所知道的一切。</p>\n<hr>\n<h3 id=\"-\">实现</h3>\n<p>实现这个功能目前我们只需要以下几样东西：</p>\n<ul>\n<li>Chrome</li>\n<li>dragstart事件支持</li>\n<li>下载文件路径，下载的文件类型，下载的文件名</li>\n</ul>\n<p>相信这几样东西应该不是很难弄取到吧~</p>\n<p>接下来我们就要开工了：</p>\n<hr>\n<h5 id=\"1-\">1.  首先我们需要判断浏览器是否支持拖动事件。</h5>\n<p>属性映射经常用来测试浏览器对HTML5 API属性的支持情况。比如，通过寻找draggable属性，检查带有[draggable=&quot;true&quot;]的元素支持** Drag and Drop API**：</p>\n<pre><code class=\"lang-javascript\">    &quot;draggable&quot; in document.createElement(&quot;div&quot;);\n\n     //截至写这篇文章的时候还是只有chrome支持该功能\n    /chrome/.test( navigator.userAgent.toLowerCase() );\n`\n</code></pre>\n<p>如果一切顺利，那么恭喜你可以进入接下来的游戏环节了</p>\n<h5 id=\"2-\">2.拼装地址</h5>\n<p>拖动下载对文件地址的要求比较高，必须是如下格式的才能进行拖拽下载：</p>\n<pre><code>{MiME}:{FileName}:{FileUrl}\n</code></pre><p>如：</p>\n<pre><code>image/jpeg:Penguins.jpg:https://www.box.net/box_download_file?file_id=f66690\n</code></pre><p>经过实践，只有以上3个参数都正常的时候，该功能才能正常运行。</p>\n<h5 id=\"3-\">3.“安装”事件</h5>\n<p>以上的工作完成之后，接下来就是绑定事件了。</p>\n<pre><code class=\"lang-javascript\">var url=&#39;image/jpeg:Penguins.jpg:https://www.box.net/box_download_file?file_id=f66690&#39;;\n\ndocument.body.addEventListener(&quot;dragstart&quot;,function(e) {\n    e.dataTransfer.setData(&quot;DownloadURL&quot;,  url);\n});\n</code></pre>\n<p>好了，万事俱备只欠东风，现在回到你的浏览器，尽情的拖动图片文本等一切可以拖动的元素吧，把它拖到，文件夹中，是不是可以看到一个名为Penguins.jpg的文件已经安详的躺在了你拖动的文件夹里面了？哈哈 是不是很神奇</p>\n<hr>\n<h4 id=\"-\">废话</h4>\n<p>好啦功能实现了，不得不多巴拉巴拉几句，个人认为这虽然是个很好的用户体验，但是很有可能成为鸡肋功能。\n1.浏览器兼容性，截至目前只有Chrome浏览器支持，不过对于谷歌来说，推广开来形成影响力不是问题。\n2.安全性，理论上用户拖拽下来的文件可以来着任何域，然后文件名、文件类型js都可以随意修改，如果别有用心的人，在网页中加入了一个恶意的js，替换拖拽的路径，把恶意文件伪装成和你要下载的文件是同一个文件名的文件，会怎样？</p>\n<hr>\n<h4 id=\"-\">还是废话</h4>\n<p>你可能想继续了解：\n<a href=\"http://www.zhuwenlong.com/blog/51f6519532ffd70b27000001\">HTML5 File api 实现断点续传</a></p>\n"}
{"_id":{"$oid":"51d3dff38ece70c438000014"},"classid":"300","comment":0,"content":"定义和用法\r\n\r\ncursor 属性规定所显示的指针（光标）的类型。\r\n\r\n语法：\r\n\r\n``` html\r\n    Object.style.cursor=cursortype\r\n```\r\n\r\n参数\r\n\r\nurl\r\n\r\ndefault\r\n\r\nauto\r\n\r\ncrosshair\r\n\r\npointer\r\n\r\nmove\r\n\r\ne-resize\r\n\r\nne-resize\r\n\r\nnw-resize\r\n\r\nn-resize\r\n\r\nse-resize\r\n\r\nsw-resize\r\n\r\ns-resize\r\n\r\nw-resize\r\n\r\ntext\r\n\r\nwait\r\n\r\nhelp","pubtime":{"$date":1355999356138},"title":"css cursor 属性 示例","visited":38447,"links":[["5534ec4efd9753d106000002",{"present":0.052631578947368418131,"title":"JavaScript 对象转换,toString,valueOf"}],["51d3dd0a8ece70c438000008",{"present":0.025641025641025640136,"title":"IE下“怪异模式”的触发  "}],["51d3dfe68ece70c438000013",{"present":0.025641025641025640136,"title":"javascript获取元素的宽度、高度"}],["51d3dc538ece70c438000005",{"present":0.025641025641025640136,"title":"小心 -webkit-text-size-adjust:none！[译]"}],["51d3db7f8ece70c438000003",{"present":0.025641025641025640136,"title":"“登陆网站”还是“登录网站”"}]],"html":"<p>定义和用法</p>\n<p>cursor 属性规定所显示的指针（光标）的类型。</p>\n<p>语法：</p>\n<pre><code class=\"lang-html\">    Object.style.cursor=cursortype\n</code></pre>\n<p>参数</p>\n<p>url</p>\n<p>default</p>\n<p>auto</p>\n<p>crosshair</p>\n<p>pointer</p>\n<p>move</p>\n<p>e-resize</p>\n<p>ne-resize</p>\n<p>nw-resize</p>\n<p>n-resize</p>\n<p>se-resize</p>\n<p>sw-resize</p>\n<p>s-resize</p>\n<p>w-resize</p>\n<p>text</p>\n<p>wait</p>\n<p>help</p>\n"}
{"_id":{"$oid":"5524f05cfd9753d106000001"},"title":"Window.postMessage() HTML5 跨域解决方案","classid":"100","content":"Hey,everybody~\r\n\r\n又是倒霉的跨域 T T , 有多少人死在了“说出你知道的跨域解决方案，越多越好？”这个面试问题上。\r\n\r\n今天和大家说说，HTML5提供的一个跨域解决方案，Window.postMessage ， 它足够易学好用，会让你眼前一亮。但是往往大多数情况下，都不会让人一直笑下去，俗话说道高一尺魔高一丈，这个方法同样也会被HTTP的一些协议所限制着，比如`X-Frame-Options:SAMEORIGIN`，不过好在大多数情况下，情况不至于这么糟糕。下面进入正题：\r\n\r\nWindow.postMessage 提供了一种安全的跨域通讯方案。\r\n\r\n## 语法\r\n\r\n----\r\n\r\n语法分为两部分，发和收，其实都很简单。\r\n\r\n### 发送\r\n\r\n`otherWindow.postMessage( message , origin [ , transfer] )`\r\n\r\n#### * otherWindow \r\n跨域的window对象的引用，比如iframe、window.open创建的对象等。\r\n\r\n#### * message \r\n发给跨域对象的消息，可以是string,object,number等对象\r\n\r\n#### * origin \r\n指定消息发送的域名，可以使用通配符 * \r\n\r\n\r\n### 接收\r\n\r\n我们可以监听window 的 \"message\" 事件来获取到传递过来的值，例如：\r\n\r\n```\r\nwindow.addEventListener('message',receiveMessage,false);\r\n\r\nfunction receiveMessage(event){\r\n\t// ...\r\n}\r\n```\r\n\r\n接收到的event包含下面几个重要的属性：\r\n\r\n#### *  data\r\n传递过来的信息。\r\n\r\n#### * origin\r\n发送消息的域名，包含了协议和端口（如 https://developer.mozilla.org:443），通常情况下 默认端口会被省略，例如 https://www.google.com 意味着省略了端口443 , http://www.google.com 省略了端口 80。\r\n\r\n#### * source\r\n发送数据的window的引用，例如b域名收到a域名的消息，此时的source指的是a域名的window，你可以通过它来实现双向通讯。\r\n\r\n\r\n\r\n## 举例：\r\n----\r\n\r\n好了，终于可以举个例子了，（等等我的糖炒板栗呢？）\r\n\r\n### 示例页面:\r\n\r\nhttp://jsbin.com/wecoqi\r\n\r\n示例代码：\r\n\r\nhttp://jsbin.com/wecoqi/9/edit?html,js\r\n\r\nhttp://jsbin.com/qetuwicebo/9/edit?html,js\r\n\r\n\r\n### 代码解释\r\n\r\n用户打开A页面，点击Open Window按钮，打开一个新的B页面（由于资源有限，Demo中用同域作为演示），\r\n回到A页面点击 push message 按钮 ，发送你好到B页面，同时收到B页面的反馈。\r\n这时候回到B页面，就能看到B页面的收到的消息了。\r\n\r\n具体代码如下。\r\n\r\nA页面\r\n\r\n```\r\n//获取按钮以及显示文本的DOM\r\nvar openWindow = document.getElementById('open');\r\nvar pushMessage = document.getElementById('push');\r\nvar messageBox = document.getElementById('message');\r\n\r\nvar newWin;\r\n\r\n//Open Window 按钮事件\r\nopenWindow.addEventListener('click',function(){\r\n\t//点击之后，打开一个新的窗口，并获得该窗口的引用\r\n  \tnewWin = window.open('http://jsbin.com/qetuwicebo');\r\n})\r\n\r\npushMessage.addEventListener('click',function(){\r\n\t//点击发送消息按钮，发送你好到新打开的窗口\r\n\t//注意第二参数是接收消息的域名，虽然可以用*匹配所有的域名，\r\n\t//但是在生产环境中，强烈建议写成真实的域名，以防不必要的攻击\r\n\tnewWin.postMessage('你好','*');\r\n\t//\r\n\tmessageBox.innerHTML=  messageBox.innerHTML+'发送了消息“你好“，请移步新打开的页面查看收到的消息'\r\n})\r\n\r\n//监听message事件，已接收其他页面发来的信息\r\nwindow.addEventListener('message',function(event){\r\n  messageBox.innerHTML=  messageBox.innerHTML+'<br>收到了回复:'+event.data\r\n})\r\n```\r\n\r\nB页面\r\n\r\n```\r\n//监听message事件\r\nwindow.addEventListener(\"message\", receiveMessage, false);\r\n\r\nfunction receiveMessage(event ){\r\n\t//注意，在生产环境中，一定要验证event.origin，以避免潜在的安全问题\r\n  \tvar html='event.data: '+event.data+'<br>';\r\n  \thtml += 'event.origin: '+event.origin+'<br>';\r\n  \thtml += 'event.source: '+event.source+'<br>';\r\n  \tdocument.getElementById('message').innerHTML= html;\r\n  \t\r\n  \t//收到消息之后我们会给，父页面发送一条回复\r\n  \t//event.source可以获取到消息来源页面的引用\r\n  \tevent.source.postMessage('hi,我来之新打开的页面，我收到你post的消息了',event.origin);\r\n}\r\n```\r\n\r\n## 结尾\r\n不想写结尾，但是，如果不写 @Robin Ma 又要说我的文章结尾太唐突了。\r\n好吧，这里是结尾，就这样。\r\n对了，记得回复哦，这是最好的鼓励 ~  :)\r\n","visited":1343,"comment":2,"pubtime":{"$date":1428484188420},"links":[["533904da1ba845cb37000002",{"present":0.081081081081081085582,"title":"node.js socket 高并发导致的消息合并成一条的解决方案"}],["51d3dc538ece70c438000005",{"present":0.025641025641025640136,"title":"小心 -webkit-text-size-adjust:none！[译]"}],["53eb8e22b55b886a13000001",{"present":0.025641025641025640136,"title":"我是如何发布版本的"}],["51d3de628ece70c43800000c",{"present":0.025641025641025640136,"title":"onhashchange与AJAX无缝刷新"}],["51d3de8e8ece70c43800000f",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（二） 用HTML5构建应用程序"}],["51d3de728ece70c43800000d",{"present":0.025641025641025640136,"title":"javascript区分判断ie6、ie7、ie8"}]],"html":"<p>Hey,everybody~</p>\n<p>又是倒霉的跨域 T T , 有多少人死在了“说出你知道的跨域解决方案，越多越好？”这个面试问题上。</p>\n<p>今天和大家说说，HTML5提供的一个跨域解决方案，Window.postMessage ， 它足够易学好用，会让你眼前一亮。但是往往大多数情况下，都不会让人一直笑下去，俗话说道高一尺魔高一丈，这个方法同样也会被HTTP的一些协议所限制着，比如<code>X-Frame-Options:SAMEORIGIN</code>，不过好在大多数情况下，情况不至于这么糟糕。下面进入正题：</p>\n<p>Window.postMessage 提供了一种安全的跨域通讯方案。</p>\n<h2 id=\"-\">语法</h2>\n<hr>\n<p>语法分为两部分，发和收，其实都很简单。</p>\n<h3 id=\"-\">发送</h3>\n<p><code>otherWindow.postMessage( message , origin [ , transfer] )</code></p>\n<h4 id=\"-otherwindow\">* otherWindow</h4>\n<p>跨域的window对象的引用，比如iframe、window.open创建的对象等。</p>\n<h4 id=\"-message\">* message</h4>\n<p>发给跨域对象的消息，可以是string,object,number等对象</p>\n<h4 id=\"-origin\">* origin</h4>\n<p>指定消息发送的域名，可以使用通配符 * </p>\n<h3 id=\"-\">接收</h3>\n<p>我们可以监听window 的 &quot;message&quot; 事件来获取到传递过来的值，例如：</p>\n<pre><code>window.addEventListener(&#39;message&#39;,receiveMessage,false);\n\nfunction receiveMessage(event){\n    // ...\n}\n</code></pre><p>接收到的event包含下面几个重要的属性：</p>\n<h4 id=\"-data\">*  data</h4>\n<p>传递过来的信息。</p>\n<h4 id=\"-origin\">* origin</h4>\n<p>发送消息的域名，包含了协议和端口（如 <a href=\"https://developer.mozilla.org:443），通常情况下\">https://developer.mozilla.org:443），通常情况下</a> 默认端口会被省略，例如 <a href=\"https://www.google.com\">https://www.google.com</a> 意味着省略了端口443 , <a href=\"http://www.google.com\">http://www.google.com</a> 省略了端口 80。</p>\n<h4 id=\"-source\">* source</h4>\n<p>发送数据的window的引用，例如b域名收到a域名的消息，此时的source指的是a域名的window，你可以通过它来实现双向通讯。</p>\n<h2 id=\"-\">举例：</h2>\n<hr>\n<p>好了，终于可以举个例子了，（等等我的糖炒板栗呢？）</p>\n<h3 id=\"-\">示例页面:</h3>\n<p><a href=\"http://jsbin.com/wecoqi\">http://jsbin.com/wecoqi</a></p>\n<p>示例代码：</p>\n<p><a href=\"http://jsbin.com/wecoqi/9/edit?html,js\">http://jsbin.com/wecoqi/9/edit?html,js</a></p>\n<p><a href=\"http://jsbin.com/qetuwicebo/9/edit?html,js\">http://jsbin.com/qetuwicebo/9/edit?html,js</a></p>\n<h3 id=\"-\">代码解释</h3>\n<p>用户打开A页面，点击Open Window按钮，打开一个新的B页面（由于资源有限，Demo中用同域作为演示），\n回到A页面点击 push message 按钮 ，发送你好到B页面，同时收到B页面的反馈。\n这时候回到B页面，就能看到B页面的收到的消息了。</p>\n<p>具体代码如下。</p>\n<p>A页面</p>\n<pre><code>//获取按钮以及显示文本的DOM\nvar openWindow = document.getElementById(&#39;open&#39;);\nvar pushMessage = document.getElementById(&#39;push&#39;);\nvar messageBox = document.getElementById(&#39;message&#39;);\n\nvar newWin;\n\n//Open Window 按钮事件\nopenWindow.addEventListener(&#39;click&#39;,function(){\n    //点击之后，打开一个新的窗口，并获得该窗口的引用\n      newWin = window.open(&#39;http://jsbin.com/qetuwicebo&#39;);\n})\n\npushMessage.addEventListener(&#39;click&#39;,function(){\n    //点击发送消息按钮，发送你好到新打开的窗口\n    //注意第二参数是接收消息的域名，虽然可以用*匹配所有的域名，\n    //但是在生产环境中，强烈建议写成真实的域名，以防不必要的攻击\n    newWin.postMessage(&#39;你好&#39;,&#39;*&#39;);\n    //\n    messageBox.innerHTML=  messageBox.innerHTML+&#39;发送了消息“你好“，请移步新打开的页面查看收到的消息&#39;\n})\n\n//监听message事件，已接收其他页面发来的信息\nwindow.addEventListener(&#39;message&#39;,function(event){\n  messageBox.innerHTML=  messageBox.innerHTML+&#39;&lt;br&gt;收到了回复:&#39;+event.data\n})\n</code></pre><p>B页面</p>\n<pre><code>//监听message事件\nwindow.addEventListener(&quot;message&quot;, receiveMessage, false);\n\nfunction receiveMessage(event ){\n    //注意，在生产环境中，一定要验证event.origin，以避免潜在的安全问题\n      var html=&#39;event.data: &#39;+event.data+&#39;&lt;br&gt;&#39;;\n      html += &#39;event.origin: &#39;+event.origin+&#39;&lt;br&gt;&#39;;\n      html += &#39;event.source: &#39;+event.source+&#39;&lt;br&gt;&#39;;\n      document.getElementById(&#39;message&#39;).innerHTML= html;\n\n      //收到消息之后我们会给，父页面发送一条回复\n      //event.source可以获取到消息来源页面的引用\n      event.source.postMessage(&#39;hi,我来之新打开的页面，我收到你post的消息了&#39;,event.origin);\n}\n</code></pre><h2 id=\"-\">结尾</h2>\n<p>不想写结尾，但是，如果不写 @Robin Ma 又要说我的文章结尾太唐突了。\n好吧，这里是结尾，就这样。\n对了，记得回复哦，这是最好的鼓励 ~  :)</p>\n","like":1}
{"_id":{"$oid":"51d3db3b8ece70c438000001"},"classid":"400","comment":12,"content":"Hi，大家好，我是Mofei，很多年前就梦想着能有一个属于自己的Blog，当然了是自己的是指指整体框架代码什么的都是自己搭建的那种，经过这些年的风风雨雨，不断成长，直到最后走入网站前端这个行业，才终于能实现自己的这个小小的愿望。\r\n\r\n自己之前一直用网易博客（ http://z-snake.blog.163.com  ），虽然有一定的访问量，但是……，现在是时候起飞的时候了！\r\n\r\n鉴于，个人能力和精力有限，可能建设速度没有想象的那么流畅，不过我相信，很快她就能初具规模。\r\n\r\n这里我不想做一个纯技术的博客，更多的是融入我的思想、生活的一个载体，同时也会是我开展我的前端“实验”的一个地方\r\n先写这么多吧，常来看看哦，会有惊喜的！","pubtime":{"$date":1340496000523},"title":"开张啦！","visited":27603,"links":[["53eb8e22b55b886a13000001",{"present":0.025641025641025640136,"title":"我是如何发布版本的"}],["51d3de558ece70c43800000b",{"present":0.025641025641025640136,"title":"前端工程师的价值体现在哪里?  "}],["52836b510d1662a510000001",{"present":0.025641025641025640136,"title":"懵懂的季节（原标题 “等待=放弃？ ” ）"}],["52bd036287e7903949000001",{"present":0.025641025641025640136,"title":"怎样成长为一个优秀的 Web 前端开发工程师？"}],["51d3db7f8ece70c438000003",{"present":0.025641025641025640136,"title":"“登陆网站”还是“登录网站”"}]],"html":"<p>Hi，大家好，我是Mofei，很多年前就梦想着能有一个属于自己的Blog，当然了是自己的是指指整体框架代码什么的都是自己搭建的那种，经过这些年的风风雨雨，不断成长，直到最后走入网站前端这个行业，才终于能实现自己的这个小小的愿望。</p>\n<p>自己之前一直用网易博客（ <a href=\"http://z-snake.blog.163.com\">http://z-snake.blog.163.com</a>  ），虽然有一定的访问量，但是……，现在是时候起飞的时候了！</p>\n<p>鉴于，个人能力和精力有限，可能建设速度没有想象的那么流畅，不过我相信，很快她就能初具规模。</p>\n<p>这里我不想做一个纯技术的博客，更多的是融入我的思想、生活的一个载体，同时也会是我开展我的前端“实验”的一个地方\n先写这么多吧，常来看看哦，会有惊喜的！</p>\n"}
{"_id":{"$oid":"5349905d7eeca8ec50000001"},"classid":"100","comment":3,"content":"#manifest 详解以及规范 \r\n\r\n> HTML5 提供了应用缓存功能，可以让浏览器保存上一次打开的文件，以便在没有网络的情况下进行访问。\r\n\r\n使用应用缓存有以下的优势\r\n\r\n* 离线访问：当用户离线的情况下任然可以继续访问网站\r\n* 速度优势：文件从本地加载，数独优势\r\n* 减少服务器压力：浏览器只下载变动的文件，多次加载同一个页面的时候不会通过服务器多次访问同一个文件\r\n\r\n## 使用manifest\r\n\r\n使用应用缓存主要是通过<html>的manifest属性来指定缓存文件。\r\n\r\n```html\r\n<html manifest=\"example.appcache\">\r\n  ...\r\n</html>\r\n```\r\n## manifest加载文件流程\r\n\r\n* 当用户访问一个指定了 manifest 的网站，如果没有缓存，浏览器会加载manifest文件，然后下载所有指定的文件，建立第一个缓存版本。\r\n* 当用户第二次访问的时候，浏览器会先根据 manifest 从本地加载文件，并触发 windwo.applicationCache 对象的 checking 事件\r\n* 如果没有文件更新，浏览器会触发 applicationCache 对象的 noupdate 事件\r\n* 如果manifest文件更新了，浏览器会重新从服务端加载更新后的文件，用户也可以通过 applicationCache.add() 事件增加缓存文件，每一个零时增加的文件会触发 applicationCache 对象的 progress 事件。如果文件出错会触发 error 事件。\r\n* 当所有的文件加载完成之后，会触发 applicationCache 对象的 cached 事件。\r\n\r\n## manifset 语法\r\n\r\nmanifest 文件以 `text/cache-manifest` 的MIME类型保存，文件的开头是 `CACHE MANIFEST` 两个单词中间用空格分割。\r\n\r\n### 标记\r\n\r\n|  标记  |  说明  |\r\n| ---   | ---  |\r\n|  CACHE:  |  指定的缓存文件  |\r\n|  NETWORK:  |  缓存文件白名单  |\r\n|  FALLBACK:  |  失败处理  |\r\n\r\n```html\r\nCACHE MANIFEST\r\n# v1 2011-08-14\r\n# This is another comment\r\nindex.html\r\ncache.html\r\nstyle.css\r\nimage1.png\r\n\r\n# Use from network if available\r\nNETWORK:\r\nnetwork.html\r\n\r\n# Fallback content\r\nFALLBACK:\r\n/ fallback.html\r\n```\r\n\r\n\r\n\r\n## manifest 文件规范 (建议稿)\r\n\r\n* manifest文件必须使用 `text/cache-manifest` 的MIME类型\r\n* manifest文件内容必须以 `CACHE MANIFEST` 开头\r\n* manifest文件中需要加上版本号的注释，任何关于缓存文件的修改，必须要修改版本号\r\n* 禁止缓存manifest文件本身，这样会导致网页无法更新。\r\n* 尽可能的缓存CSS，JS，HTML文件，动态的文件如AJAX接口，PHP动态输出文件禁止缓存\r\n","pubtime":{"$date":1397330013837},"title":"manifest 详解以及规范","visited":6043,"links":[["51d3dfda8ece70c438000012",{"present":0.052631578947368418131,"title":"jQuery新的事件绑定机制on()"}],["51f6519532ffd70b27000001",{"present":0.052631578947368418131,"title":"HTML5 File api 实现断点续传"}],["51d3db928ece70c438000004",{"present":0.025641025641025640136,"title":"预加载和javascript Image()对象 "}],["53eb8e22b55b886a13000001",{"present":0.025641025641025640136,"title":"我是如何发布版本的"}],["52d6769f93dcae3050000003",{"present":0.025641025641025640136,"title":"HTML5 file api 读取文件MD5码"}],["51d3de8e8ece70c43800000f",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（二） 用HTML5构建应用程序"}],["51d3dd0a8ece70c438000008",{"present":0.025641025641025640136,"title":"IE下“怪异模式”的触发  "}],["52cfc44ad4cf86262b000001",{"present":0.025641025641025640136,"title":"HTML5 拖动（Drag）文件到文件夹下载"}]],"html":"<p>#manifest 详解以及规范 </p>\n<blockquote>\n<p>HTML5 提供了应用缓存功能，可以让浏览器保存上一次打开的文件，以便在没有网络的情况下进行访问。</p>\n</blockquote>\n<p>使用应用缓存有以下的优势</p>\n<ul>\n<li>离线访问：当用户离线的情况下任然可以继续访问网站</li>\n<li>速度优势：文件从本地加载，数独优势</li>\n<li>减少服务器压力：浏览器只下载变动的文件，多次加载同一个页面的时候不会通过服务器多次访问同一个文件</li>\n</ul>\n<h2 id=\"-manifest\">使用manifest</h2>\n<p>使用应用缓存主要是通过<html>的manifest属性来指定缓存文件。</p>\n<pre><code class=\"lang-html\">&lt;html manifest=&quot;example.appcache&quot;&gt;\n  ...\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"manifest-\">manifest加载文件流程</h2>\n<ul>\n<li>当用户访问一个指定了 manifest 的网站，如果没有缓存，浏览器会加载manifest文件，然后下载所有指定的文件，建立第一个缓存版本。</li>\n<li>当用户第二次访问的时候，浏览器会先根据 manifest 从本地加载文件，并触发 windwo.applicationCache 对象的 checking 事件</li>\n<li>如果没有文件更新，浏览器会触发 applicationCache 对象的 noupdate 事件</li>\n<li>如果manifest文件更新了，浏览器会重新从服务端加载更新后的文件，用户也可以通过 applicationCache.add() 事件增加缓存文件，每一个零时增加的文件会触发 applicationCache 对象的 progress 事件。如果文件出错会触发 error 事件。</li>\n<li>当所有的文件加载完成之后，会触发 applicationCache 对象的 cached 事件。</li>\n</ul>\n<h2 id=\"manifset-\">manifset 语法</h2>\n<p>manifest 文件以 <code>text/cache-manifest</code> 的MIME类型保存，文件的开头是 <code>CACHE MANIFEST</code> 两个单词中间用空格分割。</p>\n<h3 id=\"-\">标记</h3>\n<table>\n<thead>\n<tr>\n<th>标记</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CACHE:</td>\n<td>指定的缓存文件</td>\n</tr>\n<tr>\n<td>NETWORK:</td>\n<td>缓存文件白名单</td>\n</tr>\n<tr>\n<td>FALLBACK:</td>\n<td>失败处理</td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"lang-html\">CACHE MANIFEST\n# v1 2011-08-14\n# This is another comment\nindex.html\ncache.html\nstyle.css\nimage1.png\n\n# Use from network if available\nNETWORK:\nnetwork.html\n\n# Fallback content\nFALLBACK:\n/ fallback.html\n</code></pre>\n<h2 id=\"manifest-\">manifest 文件规范 (建议稿)</h2>\n<ul>\n<li>manifest文件必须使用 <code>text/cache-manifest</code> 的MIME类型</li>\n<li>manifest文件内容必须以 <code>CACHE MANIFEST</code> 开头</li>\n<li>manifest文件中需要加上版本号的注释，任何关于缓存文件的修改，必须要修改版本号</li>\n<li>禁止缓存manifest文件本身，这样会导致网页无法更新。</li>\n<li>尽可能的缓存CSS，JS，HTML文件，动态的文件如AJAX接口，PHP动态输出文件禁止缓存</li>\n</ul>\n"}
{"_id":{"$oid":"51d3db928ece70c438000004"},"classid":"100","comment":0,"content":"首先是Image()对象的使用，直接贴代码\r\n\r\n\r\n``` javascitpt\r\nfunction preloader() \r\n{\r\nheavyImage = new Image(); \r\nheavyImage.src = \"heavyimagefile.jpg\";\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n以下代码预先加载了heavyimgefile.jpg，当在onMouseOver的时候就不会出现等待的情况。\r\n如果想一次预加载很多张图片可以用以下的代码\r\n\r\n``` javascitpt\r\nfunction preloader() \r\n{\r\n\r\n // counter\r\n var i = 0;\r\n\r\n // create object\r\n imageObj = new Image();\r\n\r\n // set image list\r\n images = new Array();\r\n images[0]=\"image1.jpg\"\r\n images[1]=\"image2.jpg\"\r\n images[2]=\"image3.jpg\"\r\n images[3]=\"image4.jpg\"\r\n\r\n // start preloading\r\n for(i=0; i<=3; i++) \r\n {\r\n  imageObj.src=images[i];\r\n }\r\n\r\n} \r\n```\r\n\r\n然后是很实用的，经常会遇到在图片加载完成之前提示图片加载中，然后图片加载好了再显示图片，这里给出demo\r\n\r\n\r\n``` javascitpt\r\n// create an image object\r\nobjImage = new Image();\r\n\r\n// set what happens once the image has loaded objImage.onLoad=imagesLoaded();\r\n\r\n// preload the image file\r\nobjImage.src='images/image1n.gif';\r\n\r\n// function invoked on image load\r\nfunction imagesLoaded()\r\n{    \r\n document.location.href='index2.html';\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\nPlease wait, loading images...\r\n\r\n\r\n应该很好理解的，上面的例子，先创建Image()对象，然后预加载，通过objImage.onload这个来实现图片加载完成之后执行某些方法之类的。\r\n\r\n贴出英文原文的出处，有兴趣的话可以自己过去看看，写的很不错\r\nhttp://www.techrepublic.com/article/preloading-and-the-javascript-image-object/5214317\r\n","pubtime":{"$date":1348362770514},"title":"预加载和javascript Image()对象 ","visited":22693,"links":[["51d3de8e8ece70c43800000f",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（二） 用HTML5构建应用程序"}],["5349905d7eeca8ec50000001",{"present":0.025641025641025640136,"title":"manifest 详解以及规范"}]],"html":"<p>首先是Image()对象的使用，直接贴代码</p>\n<pre><code class=\"lang-javascitpt\">function preloader() \n{\nheavyImage = new Image(); \nheavyImage.src = &quot;heavyimagefile.jpg&quot;;\n}\n</code></pre>\n<p>以下代码预先加载了heavyimgefile.jpg，当在onMouseOver的时候就不会出现等待的情况。\n如果想一次预加载很多张图片可以用以下的代码</p>\n<pre><code class=\"lang-javascitpt\">function preloader() \n{\n\n // counter\n var i = 0;\n\n // create object\n imageObj = new Image();\n\n // set image list\n images = new Array();\n images[0]=&quot;image1.jpg&quot;\n images[1]=&quot;image2.jpg&quot;\n images[2]=&quot;image3.jpg&quot;\n images[3]=&quot;image4.jpg&quot;\n\n // start preloading\n for(i=0; i&lt;=3; i++) \n {\n  imageObj.src=images[i];\n }\n\n}\n</code></pre>\n<p>然后是很实用的，经常会遇到在图片加载完成之前提示图片加载中，然后图片加载好了再显示图片，这里给出demo</p>\n<pre><code class=\"lang-javascitpt\">// create an image object\nobjImage = new Image();\n\n// set what happens once the image has loaded objImage.onLoad=imagesLoaded();\n\n// preload the image file\nobjImage.src=&#39;images/image1n.gif&#39;;\n\n// function invoked on image load\nfunction imagesLoaded()\n{    \n document.location.href=&#39;index2.html&#39;;\n}\n</code></pre>\n<p>Please wait, loading images...</p>\n<p>应该很好理解的，上面的例子，先创建Image()对象，然后预加载，通过objImage.onload这个来实现图片加载完成之后执行某些方法之类的。</p>\n<p>贴出英文原文的出处，有兴趣的话可以自己过去看看，写的很不错\n<a href=\"http://www.techrepublic.com/article/preloading-and-the-javascript-image-object/5214317\">http://www.techrepublic.com/article/preloading-and-the-javascript-image-object/5214317</a></p>\n"}
{"_id":{"$oid":"53b37b9e4b7a6de506000001"},"title":"HTML input 选色板 ( HTML5 Color Input )","classid":"200","content":"现代浏览器中，HTML5的input新增了color属性，它允许用户调用系统的选色盘，非常方便，非常酷的一个功能。\r\n\r\n### 语法\r\n\r\ninput的color是HTML5的一个实现，因此，它只能被用于支持HTML5的浏览器。\r\n\r\n典型的用法如下：\r\n\r\n```javascript\r\n<input type=\"color\" value=\"#ff00ff\">\r\n```\r\n\r\n正如input的其他type一样，color和range、number等都是取决于浏览器的，如果浏览器不支持color的话，上面的input将会展示成默认的文本输入框，其默认值为value中的\"＃ff00ff\"。\r\n\r\n[![input color](http://static.zhuwenlong.com/upload/article/input_color_a.png)](http://jsbin.com/wibaf/1/)\r\n[点击图片查看DEMO](http://jsbin.com/wibaf/1/)\r\n\r\n\r\n### 响应颜色变化\r\n\r\n通过简单的 type ＝ \"color\"  可以很容易的调用系统选色器，那么如果我们能监控并响应颜色的变化，然后做出相应的动作，用户体验将会有很大的提升。\r\n\r\n举个栗子：\r\nHTML\r\n```html\r\n<input type=\"color\" value=\"#ff0000\" id=\"bgcolor\" oninput=\"changeBackground(bgcolor.value)\">\r\n```\r\nJAVASCRIPT\r\n```javascript\r\nfunction changeBackground(colorValue){\r\n    document.body.style.bakcgroundColor = colorValue;\r\n}\r\n```\r\n\r\n### 颜色候选者\r\n\r\n有时候，单单给出调色板还不够，我们需要给定用户几个选择，用户可以简单的从这些备选项中进行选择。\r\n\r\n这时候我们可以配合使用 detalist 来实现这样的需求。\r\n\r\nHTML\r\n```html\r\n<input type=\"color\" value=\"#333333\" list=\"colors\">\r\n<datalist id=\"colors\">\r\n    <option>#ffffff</optison>\r\n    <option>#ff0000</option>\r\n    <option>#ff7700</option>\r\n</datalist>\r\n```\r\n\r\n[![input color](http://static.zhuwenlong.com/upload/article/input_color_b.png)](http://jsbin.com/wibaf/1/)\r\n[点击图片查看DEMO](http://jsbin.com/wibaf/1/)\r\n\r\n### 参考文献\r\n\r\n* [input color 兼容性](http://caniuse.com/input-color)\r\n* [The HTML5 Color Input](http://demosthenes.info/blog/588/The-HTML5-Color-Input?utm_source=html5weekly&utm_medium=email)\r\n\r\n\r\n\r\n","visited":5483,"comment":2,"pubtime":{"$date":1404271518459},"links":[["51f6519532ffd70b27000001",{"present":0.025641025641025640136,"title":"HTML5 File api 实现断点续传"}],["53a9475819a5a13617000001",{"present":0.025641025641025640136,"title":"Javascript获取服务器系统时间"}],["51d3dd2e8ece70c43800000a",{"present":0.025641025641025640136,"title":"CSS的优先级特性 "}],["51d3de8e8ece70c43800000f",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（二） 用HTML5构建应用程序"}]],"html":"<p>现代浏览器中，HTML5的input新增了color属性，它允许用户调用系统的选色盘，非常方便，非常酷的一个功能。</p>\n<h3 id=\"-\">语法</h3>\n<p>input的color是HTML5的一个实现，因此，它只能被用于支持HTML5的浏览器。</p>\n<p>典型的用法如下：</p>\n<pre><code class=\"lang-javascript\">&lt;input type=&quot;color&quot; value=&quot;#ff00ff&quot;&gt;\n</code></pre>\n<p>正如input的其他type一样，color和range、number等都是取决于浏览器的，如果浏览器不支持color的话，上面的input将会展示成默认的文本输入框，其默认值为value中的&quot;＃ff00ff&quot;。</p>\n<p><a href=\"http://jsbin.com/wibaf/1/\"><img src=\"http://static.zhuwenlong.com/upload/article/input_color_a.png\" alt=\"input color\"></a>\n<a href=\"http://jsbin.com/wibaf/1/\">点击图片查看DEMO</a></p>\n<h3 id=\"-\">响应颜色变化</h3>\n<p>通过简单的 type ＝ &quot;color&quot;  可以很容易的调用系统选色器，那么如果我们能监控并响应颜色的变化，然后做出相应的动作，用户体验将会有很大的提升。</p>\n<p>举个栗子：\nHTML</p>\n<pre><code class=\"lang-html\">&lt;input type=&quot;color&quot; value=&quot;#ff0000&quot; id=&quot;bgcolor&quot; oninput=&quot;changeBackground(bgcolor.value)&quot;&gt;\n</code></pre>\n<p>JAVASCRIPT</p>\n<pre><code class=\"lang-javascript\">function changeBackground(colorValue){\n    document.body.style.bakcgroundColor = colorValue;\n}\n</code></pre>\n<h3 id=\"-\">颜色候选者</h3>\n<p>有时候，单单给出调色板还不够，我们需要给定用户几个选择，用户可以简单的从这些备选项中进行选择。</p>\n<p>这时候我们可以配合使用 detalist 来实现这样的需求。</p>\n<p>HTML</p>\n<pre><code class=\"lang-html\">&lt;input type=&quot;color&quot; value=&quot;#333333&quot; list=&quot;colors&quot;&gt;\n&lt;datalist id=&quot;colors&quot;&gt;\n    &lt;option&gt;#ffffff&lt;/optison&gt;\n    &lt;option&gt;#ff0000&lt;/option&gt;\n    &lt;option&gt;#ff7700&lt;/option&gt;\n&lt;/datalist&gt;\n</code></pre>\n<p><a href=\"http://jsbin.com/wibaf/1/\"><img src=\"http://static.zhuwenlong.com/upload/article/input_color_b.png\" alt=\"input color\"></a>\n<a href=\"http://jsbin.com/wibaf/1/\">点击图片查看DEMO</a></p>\n<h3 id=\"-\">参考文献</h3>\n<ul>\n<li><a href=\"http://caniuse.com/input-color\">input color 兼容性</a></li>\n<li><a href=\"http://demosthenes.info/blog/588/The-HTML5-Color-Input?utm_source=html5weekly&amp;utm_medium=email\">The HTML5 Color Input</a></li>\n</ul>\n"}
{"_id":{"$oid":"51d3dd1b8ece70c438000009"},"classid":"400","comment":2,"content":"有一个美国商人坐在墨西哥海边一个小渔村的码头上，看着一个墨西哥渔夫划着一艘小船靠岸，小船上有好几尾大黄鳍鲔鱼。这个美国商人对墨西哥渔夫能抓这么高档的鱼恭维了一番，还问要多少时间才能抓这么多？墨西哥渔夫说，才一会儿功夫就抓到了。美国人再问，你为什么不待久一点，好多抓一些鱼？墨西哥渔夫觉得不以为然:这些鱼已经足够我一家人生活所需啦！\r\n\r\n美国人又问：那么你一天剩下那么多时间都在干什么？\r\n\r\n墨西哥渔夫解释：我呀？我每天睡到自然醒，出海抓几条鱼，回来后跟孩子们玩一玩；再跟老婆睡个午觉，黄昏时晃到村子里喝点小酒，跟哥儿们玩玩吉他。我的日子可过得充满又忙碌呢！\r\n\r\n美国人不以为然，帮他出主意，他说：我是美国哈佛大学企管硕士，我倒是可以帮你忙！你应该每天多花一些时间去抓鱼，到时候你就有钱去买条大一点的船。自然你就可以抓更多鱼，在买更多渔船。然后你就可以拥有一个渔船队。\r\n\r\n到时候你就不必把鱼卖给鱼贩子，而是直接卖给加工厂。然后你可以自己开一家罐头工厂。如此你就可以控制整个生产、加工处理和行销。然后你可以离开这个小渔村，搬到墨西哥城，再搬到洛杉矶，最后到纽约，在那经营你不断扩充的企业。\r\n\r\n墨西哥渔夫问：这又花多少时间呢？\r\n\r\n美国人回答：十五到二十年。\r\n\r\n墨西哥渔夫问：然后呢？\r\n\r\n美国人大笑着说：然后你就可以在家当皇帝啦！时机一到，你就可以宣布股票上市，把你的公司股份卖给投资大众；到时候你就发啦！你可以几亿几亿地赚！\r\n\r\n然后呢？\r\n\r\n美国人说：到那个时候你就可以退休啦！你可以搬到海边的小渔村去住。每天睡到自然醒，出海随便抓几条鱼，跟孩子们玩一玩，再跟老婆睡个午觉，黄昏时，晃到村子里喝点小酒，跟哥儿们玩玩吉他。\r\n\r\n墨西哥渔夫疑惑的说：我现在不就是这样了吗？\r\n\r\n人的一生，到底在追求什么？\r\n\r\n感言:\r\n\r\n人的一生, 究竟在追求什么? 这是一个没有标准答案的问题, 一千个人可能会有一千个不同的回答. 但我们应该知道成功有很多种定义, 有些人终生都在追逐名利, 他们生活得很快乐(也许), 有些人毕生都在灯红酒绿, 他们生活得也很幸福(当然); 还有更多的人在平淡充实, 日复一日的工作和生活中度过平凡的一生, 这又何尝不是一种幸福呢.\r\n\r\n或许, 真正的成功只有一个, 就是按照自己喜欢的方式, 去度过人生！！\r\n\r\n\r\n","pubtime":{"$date":1351706417539},"title":"人的一生，到底在追求什么？","visited":34589,"links":[["51d3dfbb8ece70c438000010",{"present":0.025641025641025640136,"title":"99%的人不知道或者不用的7大成功秘诀"}]],"html":"<p>有一个美国商人坐在墨西哥海边一个小渔村的码头上，看着一个墨西哥渔夫划着一艘小船靠岸，小船上有好几尾大黄鳍鲔鱼。这个美国商人对墨西哥渔夫能抓这么高档的鱼恭维了一番，还问要多少时间才能抓这么多？墨西哥渔夫说，才一会儿功夫就抓到了。美国人再问，你为什么不待久一点，好多抓一些鱼？墨西哥渔夫觉得不以为然:这些鱼已经足够我一家人生活所需啦！</p>\n<p>美国人又问：那么你一天剩下那么多时间都在干什么？</p>\n<p>墨西哥渔夫解释：我呀？我每天睡到自然醒，出海抓几条鱼，回来后跟孩子们玩一玩；再跟老婆睡个午觉，黄昏时晃到村子里喝点小酒，跟哥儿们玩玩吉他。我的日子可过得充满又忙碌呢！</p>\n<p>美国人不以为然，帮他出主意，他说：我是美国哈佛大学企管硕士，我倒是可以帮你忙！你应该每天多花一些时间去抓鱼，到时候你就有钱去买条大一点的船。自然你就可以抓更多鱼，在买更多渔船。然后你就可以拥有一个渔船队。</p>\n<p>到时候你就不必把鱼卖给鱼贩子，而是直接卖给加工厂。然后你可以自己开一家罐头工厂。如此你就可以控制整个生产、加工处理和行销。然后你可以离开这个小渔村，搬到墨西哥城，再搬到洛杉矶，最后到纽约，在那经营你不断扩充的企业。</p>\n<p>墨西哥渔夫问：这又花多少时间呢？</p>\n<p>美国人回答：十五到二十年。</p>\n<p>墨西哥渔夫问：然后呢？</p>\n<p>美国人大笑着说：然后你就可以在家当皇帝啦！时机一到，你就可以宣布股票上市，把你的公司股份卖给投资大众；到时候你就发啦！你可以几亿几亿地赚！</p>\n<p>然后呢？</p>\n<p>美国人说：到那个时候你就可以退休啦！你可以搬到海边的小渔村去住。每天睡到自然醒，出海随便抓几条鱼，跟孩子们玩一玩，再跟老婆睡个午觉，黄昏时，晃到村子里喝点小酒，跟哥儿们玩玩吉他。</p>\n<p>墨西哥渔夫疑惑的说：我现在不就是这样了吗？</p>\n<p>人的一生，到底在追求什么？</p>\n<p>感言:</p>\n<p>人的一生, 究竟在追求什么? 这是一个没有标准答案的问题, 一千个人可能会有一千个不同的回答. 但我们应该知道成功有很多种定义, 有些人终生都在追逐名利, 他们生活得很快乐(也许), 有些人毕生都在灯红酒绿, 他们生活得也很幸福(当然); 还有更多的人在平淡充实, 日复一日的工作和生活中度过平凡的一生, 这又何尝不是一种幸福呢.</p>\n<p>或许, 真正的成功只有一个, 就是按照自己喜欢的方式, 去度过人生！！</p>\n"}
{"_id":{"$oid":"53a9475819a5a13617000001"},"classid":"100","comment":6,"content":"## 背景\r\n\r\n很多时候，比如有些抽奖、倒计时等应用需要用到时间，但是单纯的 ` new Date() ` 获取到的本地时间非常之不可靠，因为任何人都可以很容易的修改，这个时候我们就需要用到系统时间。\r\n通常情况下我们会和服务端约定好一个接口，这个接口用来返回系统时间。其实在实际的项目中，这个接口可以省略，我们可以通过另外一种方法获取服务器的时间。\r\n\r\n## 相关技术\r\n\r\n如果你熟悉HTTP编程一定会想到什么，对！就是HTTP头。\r\n\r\n通常情况下，http头中包含了很多有用的信息，如下面是百度首页的HTTP头：\r\n\r\n```\r\nHTTP/1.1 200 OK\r\nDate: Tue, 24 Jun 2014 09:29:29 GMT\r\nContent-Type: text/html\r\nTransfer-Encoding: chunked\r\nConnection: Keep-Alive\r\nSet-Cookie: BDRCVFR[Y7OWRVY3J9s]=I67x6TjHwwYf0; path=/; domain=.baidu.com\r\nSet-Cookie: BDSVRTM=92; path=/\r\nSet-Cookie: H_PS_PSSID=1468_7236_7157_7254; path=/; domain=.baidu.com\r\nP3P: CP=\" OTI DSP COR IVA OUR IND COM \"\r\nCache-Control: private\r\nExpires: Tue, 24 Jun 2014 09:29:29 GMT\r\nContent-Encoding: gzip\r\nServer: BWS/1.1\r\nBDPAGETYPE: 2\r\nBDQID: 0xd4c3d37f00019464\r\nBDUSERID: 29250924\r\n```\r\n\r\n这里我们关注一下 Date 这个字段，如果有办法取到这个字段，一切都好办了！\r\n\r\n那么我们要怎么取呢？\r\n\r\n很简单，通过xmlhttp对象的 `getResponseHeader('Date')` 方法\r\n\r\n## 实现\r\n\r\n现在，我们知道方法之后，就很好办了。\r\n\r\n首先我们向服务器发送一条请求(AJAX),然后取出响应头的 `Date` 字段，大功告成！\r\n\r\n我把这个过程封装成了一个小插件：\r\n [sysDate](https://github.com/zmofei/sysDate) \r\n\r\n感兴趣的可以去[查看源码](https://github.com/zmofei/sysDate)\r\n\r\n使用起来也很方便\r\n\r\n```javascript\r\nvar a=sysDate(option);\r\n\r\n// 可选字段option， {'url':'/getDate'}\r\na.done(function(data){\r\n    console.log('done',data);\r\n    // 服务器时间 data 1385003673000'\r\n});\r\n```\r\n\r\n同时它也支持异步调用（有点promise的感觉）\r\n\r\n```javascript\r\nvar a=sysDate();\r\n\r\n//这里你还以把回调写在异步里面\r\n//等待了3秒钟，然后再去注册done事件，同样有效，是不是很神奇？\r\nsetTimeout(function(){\r\n  a.done(function(data){\r\n    console.log('done',data);\r\n    //it will return 'done 1385003673000'\r\n  });\r\n},3000)\r\n\r\n```\r\n\r\n## 下载和源码\r\n\r\n感兴趣的同学可以[点击这里获取源码](https://github.com/zmofei/sysDate)，记得start哦 :)","pubtime":{"$date":1403602776483},"title":"Javascript获取服务器系统时间","visited":6283,"links":[["54687208a02135883f000002",{"present":0.052631578947368418131,"title":"webGL 学习手记 | webGL 教程 （一）"}],["54817f6ea02135883f000004",{"present":0.052631578947368418131,"title":"使用缓冲区以及GLSL变量 - webGL 学习手记 | webGL 教程 （三）"}],["53b37b9e4b7a6de506000001",{"present":0.025641025641025640136,"title":"HTML input 选色板 ( HTML5 Color Input )"}],["547f1ccfa02135883f000003",{"present":0.025641025641025640136,"title":"webGL 学习手记 | webGL 教程 （二）"}],["533904da1ba845cb37000002",{"present":0.025641025641025640136,"title":"node.js socket 高并发导致的消息合并成一条的解决方案"}]],"html":"<h2 id=\"-\">背景</h2>\n<p>很多时候，比如有些抽奖、倒计时等应用需要用到时间，但是单纯的 <code>new Date()</code> 获取到的本地时间非常之不可靠，因为任何人都可以很容易的修改，这个时候我们就需要用到系统时间。\n通常情况下我们会和服务端约定好一个接口，这个接口用来返回系统时间。其实在实际的项目中，这个接口可以省略，我们可以通过另外一种方法获取服务器的时间。</p>\n<h2 id=\"-\">相关技术</h2>\n<p>如果你熟悉HTTP编程一定会想到什么，对！就是HTTP头。</p>\n<p>通常情况下，http头中包含了很多有用的信息，如下面是百度首页的HTTP头：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Tue, 24 Jun 2014 09:29:29 GMT\nContent-Type: text/html\nTransfer-Encoding: chunked\nConnection: Keep-Alive\nSet-Cookie: BDRCVFR[Y7OWRVY3J9s]=I67x6TjHwwYf0; path=/; domain=.baidu.com\nSet-Cookie: BDSVRTM=92; path=/\nSet-Cookie: H_PS_PSSID=1468_7236_7157_7254; path=/; domain=.baidu.com\nP3P: CP=&quot; OTI DSP COR IVA OUR IND COM &quot;\nCache-Control: private\nExpires: Tue, 24 Jun 2014 09:29:29 GMT\nContent-Encoding: gzip\nServer: BWS/1.1\nBDPAGETYPE: 2\nBDQID: 0xd4c3d37f00019464\nBDUSERID: 29250924\n</code></pre><p>这里我们关注一下 Date 这个字段，如果有办法取到这个字段，一切都好办了！</p>\n<p>那么我们要怎么取呢？</p>\n<p>很简单，通过xmlhttp对象的 <code>getResponseHeader(&#39;Date&#39;)</code> 方法</p>\n<h2 id=\"-\">实现</h2>\n<p>现在，我们知道方法之后，就很好办了。</p>\n<p>首先我们向服务器发送一条请求(AJAX),然后取出响应头的 <code>Date</code> 字段，大功告成！</p>\n<p>我把这个过程封装成了一个小插件：\n <a href=\"https://github.com/zmofei/sysDate\">sysDate</a> </p>\n<p>感兴趣的可以去<a href=\"https://github.com/zmofei/sysDate\">查看源码</a></p>\n<p>使用起来也很方便</p>\n<pre><code class=\"lang-javascript\">var a=sysDate(option);\n\n// 可选字段option， {&#39;url&#39;:&#39;/getDate&#39;}\na.done(function(data){\n    console.log(&#39;done&#39;,data);\n    // 服务器时间 data 1385003673000&#39;\n});\n</code></pre>\n<p>同时它也支持异步调用（有点promise的感觉）</p>\n<pre><code class=\"lang-javascript\">var a=sysDate();\n\n//这里你还以把回调写在异步里面\n//等待了3秒钟，然后再去注册done事件，同样有效，是不是很神奇？\nsetTimeout(function(){\n  a.done(function(data){\n    console.log(&#39;done&#39;,data);\n    //it will return &#39;done 1385003673000&#39;\n  });\n},3000)\n</code></pre>\n<h2 id=\"-\">下载和源码</h2>\n<p>感兴趣的同学可以<a href=\"https://github.com/zmofei/sysDate\">点击这里获取源码</a>，记得start哦 :)</p>\n"}
{"_id":{"$oid":"51d3dd2e8ece70c43800000a"},"classid":"300","comment":0,"content":"新手朋友们在写css的时候，有时会遇到这样的情况，辛辛苦苦写了一条css，刷新页面一看，“OH！Shit！为什么页面没有变化”？\r\n\r\n举个栗子！\r\nHTML:\r\n```html\r\n我是列表我是列表我是列表我是列表\r\n```\r\nCSS:\r\n``` css\r\n.nav li {color:red;}\r\n.nav_active {color:yellow;}\r\n```\r\n很典型的例子，当然了如果你能准确的回答第三个列表是红色的话，后面的内容就可以不用看了～\r\n为什么不是黄色呢？这就是一个典型的权的问题。\r\n\r\n下面是我曾经看到过的一篇文章，贴上来，还木有完全搞清楚的童鞋可以看看！时间久远了来源已经找不到了，对不住原文作者了～\r\n\r\n－－－－－－－－－华丽丽的分割线－－－－－－－－－－\r\n\r\n选择器一样的情况下后面的会覆盖前面的属性。比如：\r\n\r\n``` css\r\np { color: red; }\r\np { color: blue; }\r\n```\r\np元素的元素将是蓝色，因为遵循后面的规则。\r\n\r\n然而，你不可能经常用相同的选择器冲突达到目的，当你使用嵌套选择器，合理的冲突来了。比如：\r\n\r\n``` css\r\ndiv p { color: red; }\r\np { color: blue; }\r\n```\r\n\r\n也许你看起来p元素在div元素里面的颜色是蓝色，就像后面p元素的规则，但是第一个选择器的特性却是红色。基本上，一个选择器越多特性，样式冲突的时候将显示它的样式。\r\n\r\n一组嵌套选择器的实际特性可以计算出来。基本的，使用ID选择器的值是100，使用class选择器的值是10，每个html选择器的值是1。它们加起来就可以计算出特性的值。\r\n\r\np的特性是1（一个html选择器）\r\n\r\ndiv p的特性是2（两个html选择器）\r\n\r\n.tree的特性是10（1个class选择器）\r\n\r\ndiv p.tree的特性是1+1+10=12，（两个html选择器，一个class选择器）\r\n\r\n#baobab的特性是100（1个ID选择器）\r\n\r\nbody #content .alternative p的特性是112（两个html选择器，一个ID选择器，一个类选择器）\r\n\r\n按照上面的规则，div p.tree的特性比div p高，body #content .alternative p又比它们两个都高\r\n","pubtime":{"$date":1352076564982},"title":"CSS的优先级特性 ","visited":35950,"links":[["51d3dfda8ece70c438000012",{"present":0.052631578947368418131,"title":"jQuery新的事件绑定机制on()"}],["53b37b9e4b7a6de506000001",{"present":0.025641025641025640136,"title":"HTML input 选色板 ( HTML5 Color Input )"}],["51d3dcfc8ece70c438000007",{"present":0.025641025641025640136,"title":"div模拟textarea文本域轻松实现高度自适应"}],["527100b5ce7d63c80c000001",{"present":0.025641025641025640136,"title":"跨域iframe高度自适应实现方案"}],["5242d5fc9ab354383d000001",{"present":0.025641025641025640136,"title":"CSS3 实现iOS7毛玻璃模糊效果 (iOS7 live blur)"}]],"html":"<p>新手朋友们在写css的时候，有时会遇到这样的情况，辛辛苦苦写了一条css，刷新页面一看，“OH！Shit！为什么页面没有变化”？</p>\n<p>举个栗子！\nHTML:</p>\n<pre><code class=\"lang-html\">我是列表我是列表我是列表我是列表\n</code></pre>\n<p>CSS:</p>\n<pre><code class=\"lang-css\">.nav li {color:red;}\n.nav_active {color:yellow;}\n</code></pre>\n<p>很典型的例子，当然了如果你能准确的回答第三个列表是红色的话，后面的内容就可以不用看了～\n为什么不是黄色呢？这就是一个典型的权的问题。</p>\n<p>下面是我曾经看到过的一篇文章，贴上来，还木有完全搞清楚的童鞋可以看看！时间久远了来源已经找不到了，对不住原文作者了～</p>\n<p>－－－－－－－－－华丽丽的分割线－－－－－－－－－－</p>\n<p>选择器一样的情况下后面的会覆盖前面的属性。比如：</p>\n<pre><code class=\"lang-css\">p { color: red; }\np { color: blue; }\n</code></pre>\n<p>p元素的元素将是蓝色，因为遵循后面的规则。</p>\n<p>然而，你不可能经常用相同的选择器冲突达到目的，当你使用嵌套选择器，合理的冲突来了。比如：</p>\n<pre><code class=\"lang-css\">div p { color: red; }\np { color: blue; }\n</code></pre>\n<p>也许你看起来p元素在div元素里面的颜色是蓝色，就像后面p元素的规则，但是第一个选择器的特性却是红色。基本上，一个选择器越多特性，样式冲突的时候将显示它的样式。</p>\n<p>一组嵌套选择器的实际特性可以计算出来。基本的，使用ID选择器的值是100，使用class选择器的值是10，每个html选择器的值是1。它们加起来就可以计算出特性的值。</p>\n<p>p的特性是1（一个html选择器）</p>\n<p>div p的特性是2（两个html选择器）</p>\n<p>.tree的特性是10（1个class选择器）</p>\n<p>div p.tree的特性是1+1+10=12，（两个html选择器，一个class选择器）</p>\n<p>#baobab的特性是100（1个ID选择器）</p>\n<p>body #content .alternative p的特性是112（两个html选择器，一个ID选择器，一个类选择器）</p>\n<p>按照上面的规则，div p.tree的特性比div p高，body #content .alternative p又比它们两个都高</p>\n"}
{"_id":{"$oid":"51d3dc538ece70c438000005"},"classid":"100","comment":0,"content":"有一天我打开一个网站，上面的文字很小，看起来很不舒服。我按了很多次Command加+希望Safari能放大一点字体...但是什么都没有发生。怎么了？！\r\n\r\n研究了网站的css之后，发现“真凶”是下面的CSS（千万别这样用）：\r\n```css\r\nbody {\r\n    -webkit-text-size-adjust:none;\r\n}\r\n```\r\n这断代码阻止webkit内核浏览器自动调整文字大小，甚至是整个页面。现在，对于如何阻止你的用户去放大页面的文字难道不是个好的方法么？\r\n\r\n根据 Safari 的CSS参考 -webkit-text-size-adjust 用来指定iOS的Safari浏览器调整页面文字的大小。\r\n当设置成 “none” 的时候，文本的字体不会被校正。\r\n\r\n但是，我的Mac电脑里用的是Mac OS X Snow Leopard系统，并没有webkit内核的浏览器（Safari,Chrome....）但是自动调整大小却生效了，可见，并不仅仅适用于iOS的Safari浏览器。\r\n\r\n请特别留意这个属性，用在一些特殊的并且不重要的文字上（局部）。我没有找到更好的理由把它用在body上，尤其是移动设备。\r\n\r\n英文原文地址 http://www.456bereastreet.com/archive/201011/beware_of_-webkit-text-size-adjustnone/\r\n\r\n原创翻译 转载请注明出处 http://www.zhuwenlong.com\r\n","pubtime":{"$date":1349880799839},"title":"小心 -webkit-text-size-adjust:none！[译]","visited":30069,"links":[["528611f363c705fc73000001",{"present":0.11111111111111110494,"title":"javascript 文字大小自动适应文本框 （文字大小自动调整）"}],["51d3de8e8ece70c43800000f",{"present":0.052631578947368418131,"title":"Internet Explorer 10 兼容性白皮书（二） 用HTML5构建应用程序"}],["51d3de828ece70c43800000e",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（一） "}],["51d3dff38ece70c438000014",{"present":0.025641025641025640136,"title":"css cursor 属性 示例"}],["5242d5fc9ab354383d000001",{"present":0.025641025641025640136,"title":"CSS3 实现iOS7毛玻璃模糊效果 (iOS7 live blur)"}],["51d3dd0a8ece70c438000008",{"present":0.025641025641025640136,"title":"IE下“怪异模式”的触发  "}],["5524f05cfd9753d106000001",{"present":0.025641025641025640136,"title":"Window.postMessage() HTML5 跨域解决方案"}],["51d3de728ece70c43800000d",{"present":0.025641025641025640136,"title":"javascript区分判断ie6、ie7、ie8"}]],"html":"<p>有一天我打开一个网站，上面的文字很小，看起来很不舒服。我按了很多次Command加+希望Safari能放大一点字体...但是什么都没有发生。怎么了？！</p>\n<p>研究了网站的css之后，发现“真凶”是下面的CSS（千万别这样用）：</p>\n<pre><code class=\"lang-css\">body {\n    -webkit-text-size-adjust:none;\n}\n</code></pre>\n<p>这断代码阻止webkit内核浏览器自动调整文字大小，甚至是整个页面。现在，对于如何阻止你的用户去放大页面的文字难道不是个好的方法么？</p>\n<p>根据 Safari 的CSS参考 -webkit-text-size-adjust 用来指定iOS的Safari浏览器调整页面文字的大小。\n当设置成 “none” 的时候，文本的字体不会被校正。</p>\n<p>但是，我的Mac电脑里用的是Mac OS X Snow Leopard系统，并没有webkit内核的浏览器（Safari,Chrome....）但是自动调整大小却生效了，可见，并不仅仅适用于iOS的Safari浏览器。</p>\n<p>请特别留意这个属性，用在一些特殊的并且不重要的文字上（局部）。我没有找到更好的理由把它用在body上，尤其是移动设备。</p>\n<p>英文原文地址 <a href=\"http://www.456bereastreet.com/archive/201011/beware_of_-webkit-text-size-adjustnone/\">http://www.456bereastreet.com/archive/201011/beware_of_-webkit-text-size-adjustnone/</a></p>\n<p>原创翻译 转载请注明出处 <a href=\"http://www.zhuwenlong.com\">http://www.zhuwenlong.com</a></p>\n"}
{"_id":{"$oid":"51d3de628ece70c43800000c"},"classid":"100","comment":6,"content":"最近忙着网盘项目的改版，由以前的点击目录跳转到下一页的操作方式，改成直接用ajax无刷新的功能实现，考虑到用户会有可能将当前目的的地址分享给好友，于是在HTML5的history AIP和hash中选择了后者，主要还是html5的兼容性处理起来比较麻烦，虽然hashchange也是不支持IE6、IE7的但是好在IE能识别hash，做起兼容还不是很麻烦。\r\n\r\nonhashchange主要是针对ajax无刷新交互所导致的浏览器“返回”按钮无效所产生的，应该还是属于比较新的方法。\r\n当js通过改变hash的方法进行交互的时候，比如说a.html#page=1,这里的‘#page=1’就是hash，通过js改变hash不会出发load事件，所以当点击“返回”按钮时，你会发现除了hash变了以外，其他的没有任何变化。所以此时就要用到onhashchange方法，当用户点击“返回”的时候捕捉变化后的hash然后进行相应的操作。\r\n       \r\n先看兼容性\r\nInternet Explorer 8+\r\n   \r\nFirefox 3.6+\r\n       \r\nChrome 5+\r\n           \r\nSafari 5+\r\n               \r\nOpera 10.6+\r\n                   \r\n基本上除了IE6、7外问题不大，贴出方法。\r\n```javascript\r\n        (function() {\r\n    if ('onhashchange' in window) {\r\n        //if browser support onhaschange  如果浏览器支持onhaschange事件\r\n        if (window.addEventListener) {\r\n            window.addHashChange = function(func, before) {\r\n                window.addEventListener('hashchange', func, before);\r\n            };\r\n            window.removeHashChange = function(func) {\r\n                window.removeEventListener('hashchange', func);\r\n            };\r\n            return;\r\n        } else if (window.attachEvent) {\r\n            window.addHashChange = function(func) {\r\n                window.attachEvent('onhashchange', func);\r\n            };\r\n            window.removeHashChange = function(func) {\r\n                window.detachEvent('onhashchange', func);\r\n            };\r\n            return;\r\n        }\r\n    }\r\n    //if the browser not support onhaschange 如果不支持的话\r\n    var hashChangeFuncs = [];\r\n    var oldHref = location.href;\r\n    window.addHashChange = function(func, before) {\r\n        if ( typeof func === 'function')\r\n            hashChangeFuncs[before ? 'unshift': 'push' ](func);\r\n    };\r\n    window.removeHashChange = function(func) {\r\n        for (var i = hashChangeFuncs.length - 1; i >= 0; i--)\r\n            if (hashChangeFuncs[i] === func)\r\n                hashChangeFuncs.splice(i, 1);\r\n    };\r\n    //!!inportant!! 用setInterval检测has的改变\r\n    setInterval(function() {\r\n        var newHref = location.href;\r\n        if (oldHref !== newHref) {\r\n            oldHref = newHref;\r\n            for (var i = 0; i < hashChangeFuncs.length; i++) {\r\n                hashChangeFuncs[i].call(window, {\r\n                    'type' : 'hashchange',\r\n                    'newURL' : newHref,\r\n                    'oldURL' : oldHref\r\n                });\r\n            }\r\n        }\r\n    }, 100);\r\n})();\r\n// Usage, infinitely many times: 使用方法\r\naddHashChange(function(e) {\r\n    alert(e.newURL || location.href);\r\n});\r\n```\r\n方法中如果原生的事件支持的话，调用原生事件，如果不支持的话用setInterval检测，似乎有不用setInterval的方法，本来想查查的，结果google最近被GFW封杀的厉害，度娘又不给力，所以木有找到详细的做法，如果你有发现，别忘了下面分享一下~~\r\n","pubtime":{"$date":1352295386398},"title":"onhashchange与AJAX无缝刷新","visited":24902,"links":[["51d3de828ece70c43800000e",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（一） "}],["5524f05cfd9753d106000001",{"present":0.025641025641025640136,"title":"Window.postMessage() HTML5 跨域解决方案"}],["51d3de728ece70c43800000d",{"present":0.025641025641025640136,"title":"javascript区分判断ie6、ie7、ie8"}],["52cfc44ad4cf86262b000001",{"present":0.025641025641025640136,"title":"HTML5 拖动（Drag）文件到文件夹下载"}],["51d3de8e8ece70c43800000f",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（二） 用HTML5构建应用程序"}]],"html":"<p>最近忙着网盘项目的改版，由以前的点击目录跳转到下一页的操作方式，改成直接用ajax无刷新的功能实现，考虑到用户会有可能将当前目的的地址分享给好友，于是在HTML5的history AIP和hash中选择了后者，主要还是html5的兼容性处理起来比较麻烦，虽然hashchange也是不支持IE6、IE7的但是好在IE能识别hash，做起兼容还不是很麻烦。</p>\n<p>onhashchange主要是针对ajax无刷新交互所导致的浏览器“返回”按钮无效所产生的，应该还是属于比较新的方法。\n当js通过改变hash的方法进行交互的时候，比如说a.html#page=1,这里的‘#page=1’就是hash，通过js改变hash不会出发load事件，所以当点击“返回”按钮时，你会发现除了hash变了以外，其他的没有任何变化。所以此时就要用到onhashchange方法，当用户点击“返回”的时候捕捉变化后的hash然后进行相应的操作。</p>\n<p>先看兼容性\nInternet Explorer 8+</p>\n<p>Firefox 3.6+</p>\n<p>Chrome 5+</p>\n<p>Safari 5+</p>\n<p>Opera 10.6+</p>\n<p>基本上除了IE6、7外问题不大，贴出方法。</p>\n<pre><code class=\"lang-javascript\">        (function() {\n    if (&#39;onhashchange&#39; in window) {\n        //if browser support onhaschange  如果浏览器支持onhaschange事件\n        if (window.addEventListener) {\n            window.addHashChange = function(func, before) {\n                window.addEventListener(&#39;hashchange&#39;, func, before);\n            };\n            window.removeHashChange = function(func) {\n                window.removeEventListener(&#39;hashchange&#39;, func);\n            };\n            return;\n        } else if (window.attachEvent) {\n            window.addHashChange = function(func) {\n                window.attachEvent(&#39;onhashchange&#39;, func);\n            };\n            window.removeHashChange = function(func) {\n                window.detachEvent(&#39;onhashchange&#39;, func);\n            };\n            return;\n        }\n    }\n    //if the browser not support onhaschange 如果不支持的话\n    var hashChangeFuncs = [];\n    var oldHref = location.href;\n    window.addHashChange = function(func, before) {\n        if ( typeof func === &#39;function&#39;)\n            hashChangeFuncs[before ? &#39;unshift&#39;: &#39;push&#39; ](func);\n    };\n    window.removeHashChange = function(func) {\n        for (var i = hashChangeFuncs.length - 1; i &gt;= 0; i--)\n            if (hashChangeFuncs[i] === func)\n                hashChangeFuncs.splice(i, 1);\n    };\n    //!!inportant!! 用setInterval检测has的改变\n    setInterval(function() {\n        var newHref = location.href;\n        if (oldHref !== newHref) {\n            oldHref = newHref;\n            for (var i = 0; i &lt; hashChangeFuncs.length; i++) {\n                hashChangeFuncs[i].call(window, {\n                    &#39;type&#39; : &#39;hashchange&#39;,\n                    &#39;newURL&#39; : newHref,\n                    &#39;oldURL&#39; : oldHref\n                });\n            }\n        }\n    }, 100);\n})();\n// Usage, infinitely many times: 使用方法\naddHashChange(function(e) {\n    alert(e.newURL || location.href);\n});\n</code></pre>\n<p>方法中如果原生的事件支持的话，调用原生事件，如果不支持的话用setInterval检测，似乎有不用setInterval的方法，本来想查查的，结果google最近被GFW封杀的厉害，度娘又不给力，所以木有找到详细的做法，如果你有发现，别忘了下面分享一下~~</p>\n","like":1}
{"_id":{"$oid":"51d3de558ece70c43800000b"},"classid":"400","comment":0,"content":"## 豆瓣前端: \n 认为前端工程师正慢慢演变为产品工程师。wap app, 响应性UI等以html5技术为基础的开发将成为前端工程师的主要工作内容，解决产品跨平台跨设备的实现问题。Javascript, HTML, CSS这些前端工程师熟悉的，多年使用的语言，作为开放标准将被各种平台所支持。产品形态和数据的分离是形势所趋。移动时代对产品形态多元化的要求虽然可 以靠不同技术分别实现，但要付出巨大的成本。这也是html5这个04年就提出来的标准，直到前两年才火爆的原因。\r\n现阶段的价值也很大。 web产品交互越来越复杂，用户使用体验和网站前端性能优化，这些都需要专业的前端工程师来解决。另外，在项目中还要弥补设计师在交互设计上的不足，前端 工程师在开发过程中起着重要的承上启下的作用。一两个前端工程师就可以让整个开发并行起来，让设计到实现的转换更顺利。明智的公司应该贮备前端工程师资 源。\r\n我不认为前端工程师和产品经理有什么关系。好的前端工程师一定会成为好的交互设计师。前端工程师对信息架构的理解应不亚于专业的交互设计师。\r\n\r\n## 新浪前端：\r\n\r\n作为前端工程师最核心的价值或者说是责任，就是将大伙的所有心血和努力最终要完美地呈现给用户。在一个技术开发团队中，无疑离用户最近的人就是前端，其次是UI、UE和产品，然后是后端、DBA和系统工程师。\r\n如 果说一个技术开发团队就是一支足球队的话，那么前端工程师无疑就是前锋，他接到队友们倾力传到脚下的球，他责无旁贷，要做的就是必须将球准确无误地打入对 方的球门….. 他有两点必须是非常清楚：1、他必须清楚在对方球门与自己之间存在着哪些阻碍；2、他必须清楚如何破除这些障碍将球直至门网….. 他也应该要是所有队员中对这两点最为清楚的人。\r\n\r\n每个球队都有自己的明星，可以是锋线杀手、可以是中场战车、可以是超级后卫、也可以是神奇 门将、甚至可以是救火教练。而且相信球场上任何一个位置的优秀球员，都有可能在后场断球长途盘带奔袭射门，球进！但任何一支优秀的球队都必须有两类分工， 前场球员想的是赢得比赛，后场球员想的是不能输掉比赛，各司其职才能卓越。\r\n而作为一名称职的前锋，你必须是球队里，进球最多、射门技术最好的那一个，否则你还有什么价值可言呢….\r\n\r\n## 百度前端：\r\n应该来讲有三条路，一个是向前走，一个是向后走，另外一个是一直做前端，深入下去。向前即是克军所说的往用户体验与交互设计甚至产品设计师上走，这是最能体现前端价值的了，即用户体验，大多人会往这方面走；\r\n向后走就是做Web开发，往数据库和后台开发方面走，不再区分前后端，大家深入产品的研发实现，这条路就是与软件工程师融合的路，这是的价值就体现在对于业务功能的实现上；\r\n\r\n最 后还有的是一直深入做前端开发，比如前端各类库与框架的架构设计，W3C各种标准深入研究，对于JavaScript语言本身的研究，对浏览器的原理分 析，对于网络传输协议的原理分析等等，这条路要深入下去很不容易，因为涉及很多原理与根本性的东西，所以走的人也不是很多。\r\n当然了，还有一些彻底离开了前端甚至软件开发，转行专门做产品或者做业务运营。可能会因为有不错的技术背景有一定的优势呢。\r\n\r\n\r\n","pubtime":{"$date":1372839509476},"title":"前端工程师的价值体现在哪里?  ","visited":33922,"links":[["52bd036287e7903949000001",{"present":0.081081081081081085582,"title":"怎样成长为一个优秀的 Web 前端开发工程师？"}],["53eb8e22b55b886a13000001",{"present":0.052631578947368418131,"title":"我是如何发布版本的"}],["51d3db3b8ece70c438000001",{"present":0.025641025641025640136,"title":"开张啦！"}]],"html":"<h2 id=\"-\">豆瓣前端:</h2>\n<p> 认为前端工程师正慢慢演变为产品工程师。wap app, 响应性UI等以html5技术为基础的开发将成为前端工程师的主要工作内容，解决产品跨平台跨设备的实现问题。Javascript, HTML, CSS这些前端工程师熟悉的，多年使用的语言，作为开放标准将被各种平台所支持。产品形态和数据的分离是形势所趋。移动时代对产品形态多元化的要求虽然可 以靠不同技术分别实现，但要付出巨大的成本。这也是html5这个04年就提出来的标准，直到前两年才火爆的原因。\n现阶段的价值也很大。 web产品交互越来越复杂，用户使用体验和网站前端性能优化，这些都需要专业的前端工程师来解决。另外，在项目中还要弥补设计师在交互设计上的不足，前端 工程师在开发过程中起着重要的承上启下的作用。一两个前端工程师就可以让整个开发并行起来，让设计到实现的转换更顺利。明智的公司应该贮备前端工程师资 源。\n我不认为前端工程师和产品经理有什么关系。好的前端工程师一定会成为好的交互设计师。前端工程师对信息架构的理解应不亚于专业的交互设计师。</p>\n<h2 id=\"-\">新浪前端：</h2>\n<p>作为前端工程师最核心的价值或者说是责任，就是将大伙的所有心血和努力最终要完美地呈现给用户。在一个技术开发团队中，无疑离用户最近的人就是前端，其次是UI、UE和产品，然后是后端、DBA和系统工程师。\n如 果说一个技术开发团队就是一支足球队的话，那么前端工程师无疑就是前锋，他接到队友们倾力传到脚下的球，他责无旁贷，要做的就是必须将球准确无误地打入对 方的球门….. 他有两点必须是非常清楚：1、他必须清楚在对方球门与自己之间存在着哪些阻碍；2、他必须清楚如何破除这些障碍将球直至门网….. 他也应该要是所有队员中对这两点最为清楚的人。</p>\n<p>每个球队都有自己的明星，可以是锋线杀手、可以是中场战车、可以是超级后卫、也可以是神奇 门将、甚至可以是救火教练。而且相信球场上任何一个位置的优秀球员，都有可能在后场断球长途盘带奔袭射门，球进！但任何一支优秀的球队都必须有两类分工， 前场球员想的是赢得比赛，后场球员想的是不能输掉比赛，各司其职才能卓越。\n而作为一名称职的前锋，你必须是球队里，进球最多、射门技术最好的那一个，否则你还有什么价值可言呢….</p>\n<h2 id=\"-\">百度前端：</h2>\n<p>应该来讲有三条路，一个是向前走，一个是向后走，另外一个是一直做前端，深入下去。向前即是克军所说的往用户体验与交互设计甚至产品设计师上走，这是最能体现前端价值的了，即用户体验，大多人会往这方面走；\n向后走就是做Web开发，往数据库和后台开发方面走，不再区分前后端，大家深入产品的研发实现，这条路就是与软件工程师融合的路，这是的价值就体现在对于业务功能的实现上；</p>\n<p>最 后还有的是一直深入做前端开发，比如前端各类库与框架的架构设计，W3C各种标准深入研究，对于JavaScript语言本身的研究，对浏览器的原理分 析，对于网络传输协议的原理分析等等，这条路要深入下去很不容易，因为涉及很多原理与根本性的东西，所以走的人也不是很多。\n当然了，还有一些彻底离开了前端甚至软件开发，转行专门做产品或者做业务运营。可能会因为有不错的技术背景有一定的优势呢。</p>\n","like":1}
{"_id":{"$oid":"563742517a23dedc251837bd"},"title":" 用ToString生成验证码、字母序列","classid":"100","content":"想要以更优的算法生成 \"1d3ade\",\"9ded19\" 之类的验证码么？\r\n想要快速生成\"ABCDEFGHIJKL\"之类的字母序列么？\r\n\r\n通过 toString 的一些\"trick\",你可以以极简的算法复杂度实现上面的需求。\r\n\r\n## 什么是toString？\r\n\r\n其实不想用过多的笔墨介绍toString , 但是如果你真的还不知道什么是toString，那么你可能需要梳理一下你的前端知识了。\r\n\r\ntoSring 其实有2种形态\r\n\r\n### 1. obj.toString()\r\n\r\n所有的obj都有toString方法，大多数的自定义对象会返回`[object type]`,当然你也可以自定义修改toString方法达到各种目的。但这并不是今天的目的，想了解更多的话可以通过这个链接 [Object.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString) 查看详细的内容。\r\n\r\n### 2. numObj.toString([radix])\r\n\r\n第二种是针对`Number`对象的toString，主要的作用是将数字转换成字符串，细节可以参考 [Number.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString) ，但是很多时候，我们会忽略后面的参数`radix`。\r\n\r\n`radix`主要用来指定原始数据的位数，是`2-36`之间的整数，那么为什么最大是36呢？看看键盘或许就可以更好的理解了，阿拉伯数字`0-9`共10个字符，英文`a-z`共26个字符，加在一起正好是36。这就是我们所说的base-36，当然有些情况下会把大写字母`A-Z`也算进来，就是我们通常说的base-62，在有些情况下中，base-62用来描述时间戳，例如:\r\n\r\n| Date (UTC) | Base 62 epoch |\r\n| -------  | ------- |\r\n| 1970-06-21 00:32:16 | 10000 |\r\n| 1975-01-01 00:00:00 | AfyFM |\r\n| 1980-01-01 00:00:00 | LLwUi |\r\n| 2015-01-01 00:00:00 | 1Y6TBI |\r\n| 2020-01-01 00:00:00 | 1imRQe |\r\n\r\nok, 啰嗦了一大堆，下面我们进入正题。\r\n\r\n## 用toString()生成随机验证码\r\n\r\n如果有这样的一个需求，生成4位验证码，要求每一位是`0-9a-z`中的一个，那么你会怎么去实现？\r\n\r\n比较笨一点的方法是我们先做一个map表\r\n\r\n```\r\nvar map = [0,1,2,3,4,5,6,7,8,9,a,b,c,d,...,x,y,z]\r\n```\r\n\r\n然后在生成4个随机的序列，然后拼成一个验证码\r\n\r\n```\r\nvar count = 4;\r\nvar code = [];\r\nwhile(count--) {\r\n\tvar index = Math.random() * 35 | 0;\r\n\tcode.push(map[index])\r\n}\r\nvar code = code.join('');\r\n```\r\n\r\n上面的方法我们用`for(while)`产生了4个随机数，并且，用了array的`join()`去拼凑这些结果（当然了string相加的方法也是可行的）。\r\n\r\n其实如果我们很了解toString()的话，可以只用一个随机数，并且可以免去`for`以及字符串的拼接，更方便的是你可以完完全全抛弃上面的`map`。\r\n\r\n首先我们知道`0-9a-z`其实就是36位数字的组成，那么问题就变得很简单了，我们生成长度为4位的36位数字，然后转换成string，问题就解决了。\r\n\r\n举个栗子\r\n\r\n```\r\n(1231312).toString(36)   \\\\ qe34 (数字1231312对于的36进制的字符)\r\n(642312).toString(36)    \\\\ drm0 (数字642312对于的36进制的字符)\r\n```\r\n\r\n下面就是简单的数学问题了，如果要产生4位的36进制的数字，那么他的范围是 `1000` to `zzzz` ，对应的10进制就是 `Math.pow(36,3)` to `(Math.pow(36,4)-1)`\r\n\r\n那么完整的代码入下：\r\n\r\n```\r\nvar start = Math.pow(36,3);\r\nvar end = (Math.pow(36,4)-1);\r\nvar number = start + Math.random()*(end-start) | 0;\r\nvar code = number.toString(36);\r\n```\r\n\r\n非常简单，2个数字外加一个随机数，就完成了所有的事情。\r\n\r\n那么有人要问了，我如果需要改变验证码的长度怎么办？简单，我们来封装一下。\r\n\r\n```\r\nfunction getCode(len) {\r\n\tlen = len || 4;\r\n\tvar start = Math.pow(36,len-1);\r\n\tvar end = (Math.pow(36,len)-1);\r\n\tvar number = start + Math.random()*(end-start) | 0;\r\n\tvar code = number.toString(36);\r\n\treturn code;\r\n}\r\n```\r\n\r\nok, 看起来已经很爽了，但是当我们生成7位的数字的时候，你会发现变成一个负数，机智的你一定知道了答案。现在我们来处理这种情况。\r\n\r\n\r\n```\r\nfunction getCode(len) {\r\n\tlen = len || 4;\r\n    if (len > 6) {\r\n    \t// 如果大于6位，我们采用生成多组的方法来处理，每组6位\r\n        var time = len/6|0;\r\n        var lastNum = len%6;\r\n        var code = [];\r\n        for(var i=0; i<time; i++){\r\n            code.push(generate(6));\r\n        }\r\n        if (lastNum) {\r\n            code.push(generate(lastNum));\r\n        }\r\n        return code.join('');\r\n    }else{\r\n        return generate(len);\r\n    }\r\n\tfunction generate(len) {\r\n\t\t\tvar start = Math.pow(36,len-1);\r\n\t\t\tvar end = (Math.pow(36,len)-1);\r\n\t\t\tvar number = start + Math.random()*(end-start) | 0;\r\n\t\t\tvar code = number.toString(36);\r\n\t\t\treturn code;\r\n\t}\r\n}\r\n```\r\n\r\n我们尝试一下\r\n\r\n```\r\ngetCode(40) //pvbj7mmri1l1q8x28baqs3sfp4hiczmiyh1pb40v\r\n```\r\n\r\n## 用toString()生成字母序列\r\n\r\n其实如果上面的方法看明白之后，如何生成字母序列就不用我细说了。只要从10开始累加即可。\r\n\r\n","visited":985,"comment":3,"pubtime":{"$date":1446462033159},"html":"<p>想要以更优的算法生成 &quot;1d3ade&quot;,&quot;9ded19&quot; 之类的验证码么？\n想要快速生成&quot;ABCDEFGHIJKL&quot;之类的字母序列么？</p>\n<p>通过 toString 的一些&quot;trick&quot;,你可以以极简的算法复杂度实现上面的需求。</p>\n<h2 id=\"-tostring-\">什么是toString？</h2>\n<p>其实不想用过多的笔墨介绍toString , 但是如果你真的还不知道什么是toString，那么你可能需要梳理一下你的前端知识了。</p>\n<p>toSring 其实有2种形态</p>\n<h3 id=\"1-obj-tostring-\">1. obj.toString()</h3>\n<p>所有的obj都有toString方法，大多数的自定义对象会返回<code>[object type]</code>,当然你也可以自定义修改toString方法达到各种目的。但这并不是今天的目的，想了解更多的话可以通过这个链接 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\">Object.prototype.toString()</a> 查看详细的内容。</p>\n<h3 id=\"2-numobj-tostring-radix-\">2. numObj.toString([radix])</h3>\n<p>第二种是针对<code>Number</code>对象的toString，主要的作用是将数字转换成字符串，细节可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString\">Number.prototype.toString()</a> ，但是很多时候，我们会忽略后面的参数<code>radix</code>。</p>\n<p><code>radix</code>主要用来指定原始数据的位数，是<code>2-36</code>之间的整数，那么为什么最大是36呢？看看键盘或许就可以更好的理解了，阿拉伯数字<code>0-9</code>共10个字符，英文<code>a-z</code>共26个字符，加在一起正好是36。这就是我们所说的base-36，当然有些情况下会把大写字母<code>A-Z</code>也算进来，就是我们通常说的base-62，在有些情况下中，base-62用来描述时间戳，例如:</p>\n<table>\n<thead>\n<tr>\n<th>Date (UTC)</th>\n<th>Base 62 epoch</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1970-06-21 00:32:16</td>\n<td>10000</td>\n</tr>\n<tr>\n<td>1975-01-01 00:00:00</td>\n<td>AfyFM</td>\n</tr>\n<tr>\n<td>1980-01-01 00:00:00</td>\n<td>LLwUi</td>\n</tr>\n<tr>\n<td>2015-01-01 00:00:00</td>\n<td>1Y6TBI</td>\n</tr>\n<tr>\n<td>2020-01-01 00:00:00</td>\n<td>1imRQe</td>\n</tr>\n</tbody>\n</table>\n<p>ok, 啰嗦了一大堆，下面我们进入正题。</p>\n<h2 id=\"-tostring-\">用toString()生成随机验证码</h2>\n<p>如果有这样的一个需求，生成4位验证码，要求每一位是<code>0-9a-z</code>中的一个，那么你会怎么去实现？</p>\n<p>比较笨一点的方法是我们先做一个map表</p>\n<pre><code>var map = [0,1,2,3,4,5,6,7,8,9,a,b,c,d,...,x,y,z]\n</code></pre><p>然后在生成4个随机的序列，然后拼成一个验证码</p>\n<pre><code>var count = 4;\nvar code = [];\nwhile(count--) {\n    var index = Math.random() * 35 | 0;\n    code.push(map[index])\n}\nvar code = code.join(&#39;&#39;);\n</code></pre><p>上面的方法我们用<code>for(while)</code>产生了4个随机数，并且，用了array的<code>join()</code>去拼凑这些结果（当然了string相加的方法也是可行的）。</p>\n<p>其实如果我们很了解toString()的话，可以只用一个随机数，并且可以免去<code>for</code>以及字符串的拼接，更方便的是你可以完完全全抛弃上面的<code>map</code>。</p>\n<p>首先我们知道<code>0-9a-z</code>其实就是36位数字的组成，那么问题就变得很简单了，我们生成长度为4位的36位数字，然后转换成string，问题就解决了。</p>\n<p>举个栗子</p>\n<pre><code>(1231312).toString(36)   \\\\ qe34 (数字1231312对于的36进制的字符)\n(642312).toString(36)    \\\\ drm0 (数字642312对于的36进制的字符)\n</code></pre><p>下面就是简单的数学问题了，如果要产生4位的36进制的数字，那么他的范围是 <code>1000</code> to <code>zzzz</code> ，对应的10进制就是 <code>Math.pow(36,3)</code> to <code>(Math.pow(36,4)-1)</code></p>\n<p>那么完整的代码入下：</p>\n<pre><code>var start = Math.pow(36,3);\nvar end = (Math.pow(36,4)-1);\nvar number = start + Math.random()*(end-start) | 0;\nvar code = number.toString(36);\n</code></pre><p>非常简单，2个数字外加一个随机数，就完成了所有的事情。</p>\n<p>那么有人要问了，我如果需要改变验证码的长度怎么办？简单，我们来封装一下。</p>\n<pre><code>function getCode(len) {\n    len = len || 4;\n    var start = Math.pow(36,len-1);\n    var end = (Math.pow(36,len)-1);\n    var number = start + Math.random()*(end-start) | 0;\n    var code = number.toString(36);\n    return code;\n}\n</code></pre><p>ok, 看起来已经很爽了，但是当我们生成7位的数字的时候，你会发现变成一个负数，机智的你一定知道了答案。现在我们来处理这种情况。</p>\n<pre><code>function getCode(len) {\n    len = len || 4;\n    if (len &gt; 6) {\n        // 如果大于6位，我们采用生成多组的方法来处理，每组6位\n        var time = len/6|0;\n        var lastNum = len%6;\n        var code = [];\n        for(var i=0; i&lt;time; i++){\n            code.push(generate(6));\n        }\n        if (lastNum) {\n            code.push(generate(lastNum));\n        }\n        return code.join(&#39;&#39;);\n    }else{\n        return generate(len);\n    }\n    function generate(len) {\n            var start = Math.pow(36,len-1);\n            var end = (Math.pow(36,len)-1);\n            var number = start + Math.random()*(end-start) | 0;\n            var code = number.toString(36);\n            return code;\n    }\n}\n</code></pre><p>我们尝试一下</p>\n<pre><code>getCode(40) //pvbj7mmri1l1q8x28baqs3sfp4hiczmiyh1pb40v\n</code></pre><h2 id=\"-tostring-\">用toString()生成字母序列</h2>\n<p>其实如果上面的方法看明白之后，如何生成字母序列就不用我细说了。只要从10开始累加即可。</p>\n","like":2}
{"_id":{"$oid":"53eb8e22b55b886a13000001"},"title":"我是如何发布版本的","classid":"500","content":"## 碎碎念\r\n很久之前，当我最初接触后端代码的时候，并没有太过关心文件版本什么的问题，那时候简单粗暴的直接在服务器上修改。\r\n\r\n后来慢慢的程序写的多了，功能复杂了，突然发现传统的简单粗暴带来的结果是，长时间的暂停服务。在你发布或者修改文件的时候，冷不丁的会出现个什么特殊情况，然后系统就会很无辜的无法正常运行，这时候你会发现，这个BUG或者问题可能你之前根本没有遇到过。接下来就是紧张的排查和修复了，快的话几分钟慢的话可能以天为单位，极端情况最后不得不还原之前的版本。\r\n\r\n经过一段时间的折磨之后，终于开始想方设法的去优化这个发布流程了，于是：\r\n\r\n## 前期准备\r\n\r\n在解决新的发布流程之前，我做了下面一些或多或少和发布有关的工作：\r\n\r\n   * 开启CDN服务\r\n   * 前端资源的版本控制（这里用到的是我自己开发的mStaticizem，staticize.zhuwenlong.com，它可以把说有的静态资源文件加上版本号，并且替换所有引用的文件，这样可以最大程度的发挥CDN的价值）\r\n\r\n## 发布流程&测试流程\r\n\r\n通常情况下，会有开发服、测试服，甚至有些公司还会有预发服等一系列的测试环境。目的只有一个，为了更加可靠的发布代码。但是！这些服务器的存在某种程度上大大影响了发布时间。而且很多情况下是靠手动去传输文件，听说过这样的一个新闻:\r\n> 国外某知名互联网公司CTO因为没有有效的手段控制发布故障、减少发布日的加班而引咎辞职。其继任提出了网站火车发布模型，自动化发布流程：人的干预越少，自动化程度越高，引入故障的可能性就越小，大家按时下班的可能性就越大。\r\n\r\n可见发布流程其实应该是一件比较严肃且重要的事情，如果处理的好的话可以带来不少的好处。\r\n\r\n### 实际流程\r\n\r\n在和很多一线的小伙伴交流之后，我采用了这样的一套发布流程：\r\n#### 1.首先是开发\r\n\r\n这个和大多数人采用的作法是一样的，有一套专门用于开发的服务器，所有新的`featrue`分支的开发，以及自测都是在这台服务器上进行，接下来就是发布。\r\n\r\n#### 2.前端资源的处理\r\n\r\n由于前端资源的特殊性，发布之前要对前端资源进行处理，包括以下的几个自动化步骤：\r\n* CSS、JS文件的自动化合并压缩\r\n* Image图片的自动化无损压缩，上面两部都是通过使用比较广泛的自动化工具 [Grunt](http://gruntjs.cn/) 来实现的\r\n* 前端资源的版本处理，经常可以看到BAT公司的页面引入的CSS、JS地址是 `xxx.b3adg.css` `xxx.dgt6d.js` 他们的所有静态资源都增加了版本号，包括所有引用的地方，如果是手动来做这样的实情，几乎就是不可能完成的任务，这里我用了自己的开发的一个前端集成工具 [mStaticize](http://mstaticize.zhuwenlong.com/) 来实现的，它不仅可以替换文件名，甚至可以替换所有（比如说CSS，JS）中引用到这个文件的地址。\r\n\r\n#### 3.打包预发布\r\n\r\n当前面的两部完成之后，我会把所有涉及到的文件，做成一个带有时间戳压缩包（比如zhuwenlong.com_20140301），并自动的上传到正式服务器上。\r\n\r\n#### 4.测试\r\n\r\n当正式服务器接收到文件之后，会自动将相应的压缩包解压到指定的位置，并以端口递增的方式运行该服务，比如说之前运行的版本是 `127.0.0.1:8999`，那么接下来新包的服务就是 `127.0.0.1:9000`，请注意这些端口并不对外开放，只有内网可以访问到。你可呢会留意到，这时候其实线上会有很多个版本的服务同时运行，这点会在下一步阐述。到此，我们的新的包已经传到服务器上，并且以一个新的端口运行了，接下来就是测试了，这里其实不需要很多的人力的，简单的自动化跑一下新功能的单元测试脚本，然后如果不放心再人工去点点看，基本上问题不大。\r\n\r\n#### 5.一秒钟正式发布以及回滚\r\n\r\n上一步有说到同时运行的多个服务，这里就派上用场了。当测试完成之后，只需要简单的修改`nginx`的域名对应的端口映射，比如目前是`127.0.0.1:8999`只需要修改成`127.0.0.1:9000` 那么就可以相当一个新的版本发布了，真的只需要1秒钟（可能有人会问这样切换的话，前端文件的浏览器缓存怎么办，这时候我们前面的第2部就派上用场了， [mStaticize](http://mstaticize.zhuwenlong.com/) 已经很早就将修改过的静态资源替换成新的版本号了，你可以随意的在各个版本之间切换）。\r\n接下来线上的老的服务怎么办？这里可以更具喜好选择保留时间，比如说1个月或者你喜欢永久保留。保留的目的是，当你发现新的版本有严重bug的时候，你可以1秒钟回滚到回老的服务。\r\n\r\n这样一个完整的发布流程就轻松的结束了。\r\n\r\n\r\n\r\n\r\n","visited":1552,"comment":10,"pubtime":{"$date":1407946274007},"links":[["51f6519532ffd70b27000001",{"present":0.052631578947368418131,"title":"HTML5 File api 实现断点续传"}],["51d3de558ece70c43800000b",{"present":0.052631578947368418131,"title":"前端工程师的价值体现在哪里?  "}],["52bd036287e7903949000001",{"present":0.025641025641025640136,"title":"怎样成长为一个优秀的 Web 前端开发工程师？"}],["51d3db3b8ece70c438000001",{"present":0.025641025641025640136,"title":"开张啦！"}],["5524f05cfd9753d106000001",{"present":0.025641025641025640136,"title":"Window.postMessage() HTML5 跨域解决方案"}],["527100b5ce7d63c80c000001",{"present":0.025641025641025640136,"title":"跨域iframe高度自适应实现方案"}],["52cfc44ad4cf86262b000001",{"present":0.025641025641025640136,"title":"HTML5 拖动（Drag）文件到文件夹下载"}],["51d3de728ece70c43800000d",{"present":0.025641025641025640136,"title":"javascript区分判断ie6、ie7、ie8"}],["5349905d7eeca8ec50000001",{"present":0.025641025641025640136,"title":"manifest 详解以及规范"}],["52d6769f93dcae3050000003",{"present":0.025641025641025640136,"title":"HTML5 file api 读取文件MD5码"}]],"like":2,"html":"<h2 id=\"-\">碎碎念</h2>\n<p>很久之前，当我最初接触后端代码的时候，并没有太过关心文件版本什么的问题，那时候简单粗暴的直接在服务器上修改。</p>\n<p>后来慢慢的程序写的多了，功能复杂了，突然发现传统的简单粗暴带来的结果是，长时间的暂停服务。在你发布或者修改文件的时候，冷不丁的会出现个什么特殊情况，然后系统就会很无辜的无法正常运行，这时候你会发现，这个BUG或者问题可能你之前根本没有遇到过。接下来就是紧张的排查和修复了，快的话几分钟慢的话可能以天为单位，极端情况最后不得不还原之前的版本。</p>\n<p>经过一段时间的折磨之后，终于开始想方设法的去优化这个发布流程了，于是：</p>\n<h2 id=\"-\">前期准备</h2>\n<p>在解决新的发布流程之前，我做了下面一些或多或少和发布有关的工作：</p>\n<ul>\n<li>开启CDN服务</li>\n<li>前端资源的版本控制（这里用到的是我自己开发的mStaticizem，staticize.zhuwenlong.com，它可以把说有的静态资源文件加上版本号，并且替换所有引用的文件，这样可以最大程度的发挥CDN的价值）</li>\n</ul>\n<h2 id=\"-\">发布流程&amp;测试流程</h2>\n<p>通常情况下，会有开发服、测试服，甚至有些公司还会有预发服等一系列的测试环境。目的只有一个，为了更加可靠的发布代码。但是！这些服务器的存在某种程度上大大影响了发布时间。而且很多情况下是靠手动去传输文件，听说过这样的一个新闻:</p>\n<blockquote>\n<p>国外某知名互联网公司CTO因为没有有效的手段控制发布故障、减少发布日的加班而引咎辞职。其继任提出了网站火车发布模型，自动化发布流程：人的干预越少，自动化程度越高，引入故障的可能性就越小，大家按时下班的可能性就越大。</p>\n</blockquote>\n<p>可见发布流程其实应该是一件比较严肃且重要的事情，如果处理的好的话可以带来不少的好处。</p>\n<h3 id=\"-\">实际流程</h3>\n<p>在和很多一线的小伙伴交流之后，我采用了这样的一套发布流程：</p>\n<h4 id=\"1-\">1.首先是开发</h4>\n<p>这个和大多数人采用的作法是一样的，有一套专门用于开发的服务器，所有新的<code>featrue</code>分支的开发，以及自测都是在这台服务器上进行，接下来就是发布。</p>\n<h4 id=\"2-\">2.前端资源的处理</h4>\n<p>由于前端资源的特殊性，发布之前要对前端资源进行处理，包括以下的几个自动化步骤：</p>\n<ul>\n<li>CSS、JS文件的自动化合并压缩</li>\n<li>Image图片的自动化无损压缩，上面两部都是通过使用比较广泛的自动化工具 <a href=\"http://gruntjs.cn/\">Grunt</a> 来实现的</li>\n<li>前端资源的版本处理，经常可以看到BAT公司的页面引入的CSS、JS地址是 <code>xxx.b3adg.css</code> <code>xxx.dgt6d.js</code> 他们的所有静态资源都增加了版本号，包括所有引用的地方，如果是手动来做这样的实情，几乎就是不可能完成的任务，这里我用了自己的开发的一个前端集成工具 <a href=\"http://mstaticize.zhuwenlong.com/\">mStaticize</a> 来实现的，它不仅可以替换文件名，甚至可以替换所有（比如说CSS，JS）中引用到这个文件的地址。</li>\n</ul>\n<h4 id=\"3-\">3.打包预发布</h4>\n<p>当前面的两部完成之后，我会把所有涉及到的文件，做成一个带有时间戳压缩包（比如zhuwenlong.com_20140301），并自动的上传到正式服务器上。</p>\n<h4 id=\"4-\">4.测试</h4>\n<p>当正式服务器接收到文件之后，会自动将相应的压缩包解压到指定的位置，并以端口递增的方式运行该服务，比如说之前运行的版本是 <code>127.0.0.1:8999</code>，那么接下来新包的服务就是 <code>127.0.0.1:9000</code>，请注意这些端口并不对外开放，只有内网可以访问到。你可呢会留意到，这时候其实线上会有很多个版本的服务同时运行，这点会在下一步阐述。到此，我们的新的包已经传到服务器上，并且以一个新的端口运行了，接下来就是测试了，这里其实不需要很多的人力的，简单的自动化跑一下新功能的单元测试脚本，然后如果不放心再人工去点点看，基本上问题不大。</p>\n<h4 id=\"5-\">5.一秒钟正式发布以及回滚</h4>\n<p>上一步有说到同时运行的多个服务，这里就派上用场了。当测试完成之后，只需要简单的修改<code>nginx</code>的域名对应的端口映射，比如目前是<code>127.0.0.1:8999</code>只需要修改成<code>127.0.0.1:9000</code> 那么就可以相当一个新的版本发布了，真的只需要1秒钟（可能有人会问这样切换的话，前端文件的浏览器缓存怎么办，这时候我们前面的第2部就派上用场了， <a href=\"http://mstaticize.zhuwenlong.com/\">mStaticize</a> 已经很早就将修改过的静态资源替换成新的版本号了，你可以随意的在各个版本之间切换）。\n接下来线上的老的服务怎么办？这里可以更具喜好选择保留时间，比如说1个月或者你喜欢永久保留。保留的目的是，当你发现新的版本有严重bug的时候，你可以1秒钟回滚到回老的服务。</p>\n<p>这样一个完整的发布流程就轻松的结束了。</p>\n"}
{"_id":{"$oid":"561520457a23dedc251837b9"},"title":"黄山的黄，黄山的山","classid":"400","content":"￼![封面](http://static.zhuwenlong.com/upload/article/2015_10_7_lftg2_1.jpg)\r\n\r\n很长一段时间，我把\"身体与灵魂，必须有一个在路上\"用作自己的各种签名，最初也仅仅是因为它看起来逼格比较高罢了。\r\n\r\n一年又一年，我去过了很多地方：和同事一起跃起在敦煌的沙丘上，带着老娘踏上了人间仙境九寨沟，牵着妹纸的手在普吉岛上留下一串串脚印。也体验到了无数个第一次：第一次用冒汗的手紧紧的握着飞机的安全带，第一次在沙漠中追逐骆驼，第一次吐着嘴里的海水大喊道”我cao，这么咸！\"\r\n\r\n伴随着每一次的出行，旅行的意义变得越来越清晰——不是因为“身体与灵魂”的鸡汤，不是为了晒朋友圈，而是为了走出自己的世界，看更多，走更远。我喜欢旅行中，陌生人之间的那种毫无戒备的沟通，那种被被浮华掩盖了的发自内心的祝福，当你亲自踏上神秘的异土他乡，当你听到同行的阿哥阿妹述说着不同风土人情下的迥异人生，当你在困难的时候听到身边甚至是异国的路人口中蹦出的“fighting”，你才感叹，在一成不变的朝九晚五的生活之外，生命的意义可以无穷无尽的放大！\r\n\r\n一、出发\r\n\r\n我喜欢说走就走的旅行，没有任何详细的计划，走走停停，随遇而安，好过跟着导游匆忙的穿梭在景区之间，有量没质。\r\n这次旅行安排了5天时间，相对比较充裕，除了去时的火车票、回程的机票外，没有定酒店，没有看攻略，没有做任何的功课，倒也潇洒自在。\r\n\r\n第一天，漫漫长征路的开始，除了送我们去车站的师傅，一路上很是亢奋，唱了不少的红歌外，一路上了无生趣。下午到达黄山市区，一座徽州风格的小城出现在眼前，虽然是全新的徽州风格的城市，但是对于我这个在安徽长大的“当地人”来说，并没有多少的新鲜感。走在老街上，相机都懒得掏出来，看着一群群不停拍照的游客，感受着久违的“家乡”的感觉。\r\n\r\n￼￼![当地比较有名的老街](http://static.zhuwenlong.com/upload/article/2015_10_7_qtj3i_2.jpg)\r\n\r\n【图：当地比较有名的老街】\r\n\r\n\r\n第一天就在火车和市区度过了，没有什么新奇的，但是令我意想不到是黄山的当地人比我想象的要有好的多。\r\n\r\n说到徽州大多数人都能联想到徽商这个词，常年混迹在北上广的人对中关村、不夜城、华强北的“商人”应该有着独特的理解，鉴于此，来之前我心里也是多了份提防，但是逛了一天之后改变了我的看法。当地人很乐于帮助别人，往往问路的时候，对方都是面带微笑，很认真很细心的帮你解释，没有遇到任何一个人说“不知道”，或者直接不搭理你的情况。 \r\n\r\n￼￼![买东西的老奶奶](http://static.zhuwenlong.com/upload/article/2015_10_7_ybuiv_3.jpg)\r\n\r\n卖东西的商人，有不少是年长的阿叔阿妈，虽然他们是以挣钱为目的的销售东西，但多数时候，还还价，他们绝大多数会笑脸相迎，以很低的价钱卖给你。\r\n\r\n\r\n￼￼![人力黄包车](http://static.zhuwenlong.com/upload/article/2015_10_7_qfhax_4.jpg)\r\n\r\n当地的人力黄包车很多很多，骑车的通常是年长的大叔，他们并不会漫天开价，基本上都是很合理的价格，我们从老街到大润发，骑行大约20分钟的路程，其中有一些上坡的路，我们加在一起300近的俩个人一共才要了6块钱，看着师傅满头的汗水，确实不忍心，给了10块钱说不用找了，师傅很是开心，一个劲地说“谢谢、谢谢”。\r\n\r\n二、黄山\r\n\r\n第二天，快9点了才懒洋洋地爬起来，按计划，我们准备在山顶上住上一宿，所以也就没那么着急，吃完早饭，打车去汽车站，一个小时后的车程就到了黄山脚下。\r\n\r\n到了黄山之后Robin立刻开启了他那令人羡慕的聊天模式，得益于这种技能，我们2天的在山上“爬行”的过程并不“孤单”，先是遇到一对上海来的母女，因为和我们是同一个旅馆，一起爬了一大段的距离；后来遇到一个天还没亮就上山的小妹妹，在我们还在往某个景点前进的过程中，她已经去过了大部分的景点；第一天下午，我们遇到了一对来自北京的40多岁的夫妇，应该是经常出来玩的那种，他们本来只打算在山上玩一天，后来发现，一天其实是很紧的，遇到我们之后，在Robin的推荐下，我们帮他们在百度地图上定了我们宾馆的2个床位；上山的过程中，还遇到一对广州的妹纸，由于路划相仿，一路结伴到宏村。\r\n\r\nRobin一直很想爬上去，而我偏偏是属于比较懒得型号，上山前问了一些当地人的意见，最终决定还是做缆车上去。\r\n\r\n￼￼![上山的缆车](http://static.zhuwenlong.com/upload/article/2015_10_7_rgu5x_5.jpg)\r\n\r\n上山的缆车从外表上看和其他景区没有什么区别，但是真正坐上去之后，才感慨道工程的浩大。\r\n\r\n￼￼￼![上山的缆车](http://static.zhuwenlong.com/upload/article/2015_10_7_lj49w_5.1.jpg)\r\n\r\n黄山的奇在缆车上感受最深刻，第一次是在上山的玉屏索道上，第二次是在西海大峡谷的云谷索道，两次都让我情不自禁的感慨起来。脚下万丈深渊、飞流瀑布、茂密丛林不停地变换着，是什么样的力量才能在这种极其复杂、极其险峻的山上矗立起一座座铁搭，我们甚至一度不敢相信自己的眼镜，一度怀疑这样的工程是现在技术所能到达的么？\r\n\r\n黄山的奇、黄山的险是这次上山感受最深的。游览路线并不是特别的复杂，一天可能特别赶，如果有条件的话，山顶上住上一宿，晚上看星空，早上看日出，则是极好的。一路上，教科书中所说的诸如“迎客松”、“猴子观海”、“梦笔生花”等都能一一看到，当然了除了这些耳熟能详的的景点外，西海大峡谷则可以算得上“必去”的景点之一，美到无法用文字表达。\r\n\r\n￼￼￼￼![上山的缆车](http://static.zhuwenlong.com/upload/article/2015_10_7_o19d4_6.jpg)\r\n\r\n卖萌的我与Robin在迎客松下\r\n\r\n￼￼￼￼![有轨缆车](http://static.zhuwenlong.com/upload/article/2015_10_7_ybujx_7.jpg)\r\n\r\n西海大峡谷的有轨缆车，从山顶做下去只要7分钟，但是再从石阶爬上来的话，就要2个小时左右了。建议走下去，然后做缆车上去，我们选择了“逆行”，那个滋味是如此的“酸爽”。\r\n\r\n￼￼￼￼![缆车轨道](http://static.zhuwenlong.com/upload/article/2015_10_7_vi74h_8.jpg)\r\n\r\n下了缆车，回头望上去，又是一大“奇迹”。\r\n\r\n￼￼￼￼![谷底上山的石阶](http://static.zhuwenlong.com/upload/article/2015_10_7_ovyav_9.jpg)\r\n\r\n谷底上山的石阶，平均坡度70°，真的可以累成狗。。。\r\n\r\n\r\n￼￼￼￼![每走一小段距离都要停下来休息一下](http://static.zhuwenlong.com/upload/article/2015_10_7_ok0i0_10.jpg)\r\n\r\n爬了数小时的台阶后，每走一小段距离都要停下来休息一下\r\n\r\n\r\n上山的过程中，Robin一直很兴奋，不停地和下山的路人说：“加油，马上就到了！”，路人也都会给予回应，甚是和谐。后来路过一堆人马，所有人都当做什么都没有听见，连头也不抬一下，气氛甚是尴尬，就在这个时候，突然发现他们自己之间说的韩语，原来是外国团。打那以后，Robin看见人再也不说加油了，而是换成了“fighting!”，这下好了，换成了世界通用语言，再也没有遇到“冷落”，最有意思的是，有些韩国的年长大妈也很风趣的回着“fighting！fighting！”。\r\n\r\n￼￼￼￼![爬山的大爷大妈](http://static.zhuwenlong.com/upload/article/2015_10_7_yb6tt_11.jpg)\r\n\r\n路上遇到的一对大爷大妈，Robin拍照得时候，老人说：“拍吧拍吧，以后就拍不了了，这都75了，最后一次爬黄山喽”。\r\n\r\n￼￼￼￼![看日出的人们](http://static.zhuwenlong.com/upload/article/2015_10_7_r4r2d_12.jpg)\r\n\r\n第二天一大早，光明顶上看日出，很是幸运的看到了日出，一起裹着床单，千奇百怪的看日出的人。\r\n\r\n￼￼￼￼![全景](http://static.zhuwenlong.com/upload/article/2015_10_7_111o78_13.jpg)\r\n\r\n除了黄山后面两天顺带去了宏村，本来想一起写的，但介于篇幅，还是等有空再写吧。\r\n\r\n山上两天的行程，不多不少，恰合适，爬坡、汗水、日出、闲看人生，何尝不是一段有意义的行程呢。\r\n\r\n ","visited":678,"comment":3,"pubtime":{"$date":1444225093963},"html":"<p>￼<img src=\"http://static.zhuwenlong.com/upload/article/2015_10_7_lftg2_1.jpg\" alt=\"封面\"></p>\n<p>很长一段时间，我把&quot;身体与灵魂，必须有一个在路上&quot;用作自己的各种签名，最初也仅仅是因为它看起来逼格比较高罢了。</p>\n<p>一年又一年，我去过了很多地方：和同事一起跃起在敦煌的沙丘上，带着老娘踏上了人间仙境九寨沟，牵着妹纸的手在普吉岛上留下一串串脚印。也体验到了无数个第一次：第一次用冒汗的手紧紧的握着飞机的安全带，第一次在沙漠中追逐骆驼，第一次吐着嘴里的海水大喊道”我cao，这么咸！&quot;</p>\n<p>伴随着每一次的出行，旅行的意义变得越来越清晰——不是因为“身体与灵魂”的鸡汤，不是为了晒朋友圈，而是为了走出自己的世界，看更多，走更远。我喜欢旅行中，陌生人之间的那种毫无戒备的沟通，那种被被浮华掩盖了的发自内心的祝福，当你亲自踏上神秘的异土他乡，当你听到同行的阿哥阿妹述说着不同风土人情下的迥异人生，当你在困难的时候听到身边甚至是异国的路人口中蹦出的“fighting”，你才感叹，在一成不变的朝九晚五的生活之外，生命的意义可以无穷无尽的放大！</p>\n<p>一、出发</p>\n<p>我喜欢说走就走的旅行，没有任何详细的计划，走走停停，随遇而安，好过跟着导游匆忙的穿梭在景区之间，有量没质。\n这次旅行安排了5天时间，相对比较充裕，除了去时的火车票、回程的机票外，没有定酒店，没有看攻略，没有做任何的功课，倒也潇洒自在。</p>\n<p>第一天，漫漫长征路的开始，除了送我们去车站的师傅，一路上很是亢奋，唱了不少的红歌外，一路上了无生趣。下午到达黄山市区，一座徽州风格的小城出现在眼前，虽然是全新的徽州风格的城市，但是对于我这个在安徽长大的“当地人”来说，并没有多少的新鲜感。走在老街上，相机都懒得掏出来，看着一群群不停拍照的游客，感受着久违的“家乡”的感觉。</p>\n<p>￼￼<img src=\"http://static.zhuwenlong.com/upload/article/2015_10_7_qtj3i_2.jpg\" alt=\"当地比较有名的老街\"></p>\n<p>【图：当地比较有名的老街】</p>\n<p>第一天就在火车和市区度过了，没有什么新奇的，但是令我意想不到是黄山的当地人比我想象的要有好的多。</p>\n<p>说到徽州大多数人都能联想到徽商这个词，常年混迹在北上广的人对中关村、不夜城、华强北的“商人”应该有着独特的理解，鉴于此，来之前我心里也是多了份提防，但是逛了一天之后改变了我的看法。当地人很乐于帮助别人，往往问路的时候，对方都是面带微笑，很认真很细心的帮你解释，没有遇到任何一个人说“不知道”，或者直接不搭理你的情况。 </p>\n<p>￼￼<img src=\"http://static.zhuwenlong.com/upload/article/2015_10_7_ybuiv_3.jpg\" alt=\"买东西的老奶奶\"></p>\n<p>卖东西的商人，有不少是年长的阿叔阿妈，虽然他们是以挣钱为目的的销售东西，但多数时候，还还价，他们绝大多数会笑脸相迎，以很低的价钱卖给你。</p>\n<p>￼￼<img src=\"http://static.zhuwenlong.com/upload/article/2015_10_7_qfhax_4.jpg\" alt=\"人力黄包车\"></p>\n<p>当地的人力黄包车很多很多，骑车的通常是年长的大叔，他们并不会漫天开价，基本上都是很合理的价格，我们从老街到大润发，骑行大约20分钟的路程，其中有一些上坡的路，我们加在一起300近的俩个人一共才要了6块钱，看着师傅满头的汗水，确实不忍心，给了10块钱说不用找了，师傅很是开心，一个劲地说“谢谢、谢谢”。</p>\n<p>二、黄山</p>\n<p>第二天，快9点了才懒洋洋地爬起来，按计划，我们准备在山顶上住上一宿，所以也就没那么着急，吃完早饭，打车去汽车站，一个小时后的车程就到了黄山脚下。</p>\n<p>到了黄山之后Robin立刻开启了他那令人羡慕的聊天模式，得益于这种技能，我们2天的在山上“爬行”的过程并不“孤单”，先是遇到一对上海来的母女，因为和我们是同一个旅馆，一起爬了一大段的距离；后来遇到一个天还没亮就上山的小妹妹，在我们还在往某个景点前进的过程中，她已经去过了大部分的景点；第一天下午，我们遇到了一对来自北京的40多岁的夫妇，应该是经常出来玩的那种，他们本来只打算在山上玩一天，后来发现，一天其实是很紧的，遇到我们之后，在Robin的推荐下，我们帮他们在百度地图上定了我们宾馆的2个床位；上山的过程中，还遇到一对广州的妹纸，由于路划相仿，一路结伴到宏村。</p>\n<p>Robin一直很想爬上去，而我偏偏是属于比较懒得型号，上山前问了一些当地人的意见，最终决定还是做缆车上去。</p>\n<p>￼￼<img src=\"http://static.zhuwenlong.com/upload/article/2015_10_7_rgu5x_5.jpg\" alt=\"上山的缆车\"></p>\n<p>上山的缆车从外表上看和其他景区没有什么区别，但是真正坐上去之后，才感慨道工程的浩大。</p>\n<p>￼￼￼<img src=\"http://static.zhuwenlong.com/upload/article/2015_10_7_lj49w_5.1.jpg\" alt=\"上山的缆车\"></p>\n<p>黄山的奇在缆车上感受最深刻，第一次是在上山的玉屏索道上，第二次是在西海大峡谷的云谷索道，两次都让我情不自禁的感慨起来。脚下万丈深渊、飞流瀑布、茂密丛林不停地变换着，是什么样的力量才能在这种极其复杂、极其险峻的山上矗立起一座座铁搭，我们甚至一度不敢相信自己的眼镜，一度怀疑这样的工程是现在技术所能到达的么？</p>\n<p>黄山的奇、黄山的险是这次上山感受最深的。游览路线并不是特别的复杂，一天可能特别赶，如果有条件的话，山顶上住上一宿，晚上看星空，早上看日出，则是极好的。一路上，教科书中所说的诸如“迎客松”、“猴子观海”、“梦笔生花”等都能一一看到，当然了除了这些耳熟能详的的景点外，西海大峡谷则可以算得上“必去”的景点之一，美到无法用文字表达。</p>\n<p>￼￼￼￼<img src=\"http://static.zhuwenlong.com/upload/article/2015_10_7_o19d4_6.jpg\" alt=\"上山的缆车\"></p>\n<p>卖萌的我与Robin在迎客松下</p>\n<p>￼￼￼￼<img src=\"http://static.zhuwenlong.com/upload/article/2015_10_7_ybujx_7.jpg\" alt=\"有轨缆车\"></p>\n<p>西海大峡谷的有轨缆车，从山顶做下去只要7分钟，但是再从石阶爬上来的话，就要2个小时左右了。建议走下去，然后做缆车上去，我们选择了“逆行”，那个滋味是如此的“酸爽”。</p>\n<p>￼￼￼￼<img src=\"http://static.zhuwenlong.com/upload/article/2015_10_7_vi74h_8.jpg\" alt=\"缆车轨道\"></p>\n<p>下了缆车，回头望上去，又是一大“奇迹”。</p>\n<p>￼￼￼￼<img src=\"http://static.zhuwenlong.com/upload/article/2015_10_7_ovyav_9.jpg\" alt=\"谷底上山的石阶\"></p>\n<p>谷底上山的石阶，平均坡度70°，真的可以累成狗。。。</p>\n<p>￼￼￼￼<img src=\"http://static.zhuwenlong.com/upload/article/2015_10_7_ok0i0_10.jpg\" alt=\"每走一小段距离都要停下来休息一下\"></p>\n<p>爬了数小时的台阶后，每走一小段距离都要停下来休息一下</p>\n<p>上山的过程中，Robin一直很兴奋，不停地和下山的路人说：“加油，马上就到了！”，路人也都会给予回应，甚是和谐。后来路过一堆人马，所有人都当做什么都没有听见，连头也不抬一下，气氛甚是尴尬，就在这个时候，突然发现他们自己之间说的韩语，原来是外国团。打那以后，Robin看见人再也不说加油了，而是换成了“fighting!”，这下好了，换成了世界通用语言，再也没有遇到“冷落”，最有意思的是，有些韩国的年长大妈也很风趣的回着“fighting！fighting！”。</p>\n<p>￼￼￼￼<img src=\"http://static.zhuwenlong.com/upload/article/2015_10_7_yb6tt_11.jpg\" alt=\"爬山的大爷大妈\"></p>\n<p>路上遇到的一对大爷大妈，Robin拍照得时候，老人说：“拍吧拍吧，以后就拍不了了，这都75了，最后一次爬黄山喽”。</p>\n<p>￼￼￼￼<img src=\"http://static.zhuwenlong.com/upload/article/2015_10_7_r4r2d_12.jpg\" alt=\"看日出的人们\"></p>\n<p>第二天一大早，光明顶上看日出，很是幸运的看到了日出，一起裹着床单，千奇百怪的看日出的人。</p>\n<p>￼￼￼￼<img src=\"http://static.zhuwenlong.com/upload/article/2015_10_7_111o78_13.jpg\" alt=\"全景\"></p>\n<p>除了黄山后面两天顺带去了宏村，本来想一起写的，但介于篇幅，还是等有空再写吧。</p>\n<p>山上两天的行程，不多不少，恰合适，爬坡、汗水、日出、闲看人生，何尝不是一段有意义的行程呢。</p>\n","like":1}
{"_id":{"$oid":"55d5f0f48cf91c7157121a0d"},"title":"ES6 Module","classid":"100","content":"相对比起`Python`,`PHP`等其他语言，`JavaScript` 在设计上视乎缺失了模块管理的部分，不过好消息是这些问题很快就会得到解决，在下一代JavaScript `ECMASCRIPT 6`中，这个问题被很好的解决了。\r\n\r\n\r\n## ES6 Module 特性\r\n\r\nModule 特性是在14年的7月被完全确认的，这就意味着到目前为止，语法相对比较稳定。\r\n\r\n`Module` 包含了2个主要的部分，模块的定义 `export` 和模块的引入 `import`，如果是写过 Python 的同学对这个部分的概念会很容易理解，因为语法真的很像、很像。\r\n\r\n\r\n### 一、Export \r\n\r\n`export` 顾名思义，就是定义模块的输出，基础语法很简单：\r\n\r\n```javascript\r\nexport {export Name}\r\n```\r\n\r\n但根据输出的参数不同，它的表现形式也有所区别。\r\n\r\n```javascript\r\nexport var a = '123';\r\n\r\nexport function name(arguments){ //... }\r\n\r\nexport {nameA, nameB}\r\n\r\nexport default function name(arguments){ //.. }\r\n\r\nexport *\r\n```\r\n\r\n#### 1. 直接输出\r\n\r\n在前两行中，我们对外输出了一个`变量a`, 一个`方法name`, 你可能已经留意到了，我们的方法和变量的声明都是直接写在的export的后面，那么你会想如果`export`关键字后面直接填变量名会怎么样呢？\r\n\r\n尝试如下:\r\n\r\n```javascript\r\n// BAD EXAMPLE !!\r\n\r\nvar a = '123';\r\n\r\nfunction name(arguments) { //... }\r\n\r\nexport a;\r\n\r\n// or\r\n// export name;\r\n```\r\n\r\n执行之后会发现，这种在export后面直接写变量名的方式是会触发Error的，这种情况下我们只能吧定义写在export的后面。那么问题来了，如果所有的定义都写在export后面的话，相信处女做的同学们可能会坐不住了，别急，我们有第二种的方法。\r\n\r\n#### 2. 输出变量\r\n\r\n这种情况应该比第一种方法要常见，很多时候我们会在输出之前定义好方法或者变量，如果需要输出可以加一个花括号，同样拿上面的例子来说明：\r\n\r\n```javascript\r\nvar a = '123';\r\n\r\nfunction name(arguments) { //... }\r\n\r\nexport {a,name};\r\n\r\n// or\r\n// export {a}\r\n// export {name}\r\n```\r\n\r\n这样就能愉快的输出变量了，不过和 `retrun` 略有区别的是，我们在export 之后还能继续输出。\r\n\r\n也就是说下面的两条语句的表现完全相同：\r\n\r\n##### 单行模式\r\n\r\n```javascript\r\nexport {a,name}\r\n```\r\n\r\n##### 多行模式\r\n\r\n```javascript\r\nexport {a}\r\nexport {name}\r\n```\r\n\r\n#### 3. default\r\n\r\ndefault模式比较特殊，也比较有用，先看例子吧：\r\n\r\n##### a.js\r\n\r\n```javascript\r\nvar $ = function(){}\r\n\r\n$.prototype.show = function(){ //.. }\r\n\r\nexport default $\r\n```\r\n##### b.js\r\n```javascript\r\nimport jQuery from 'a.js'\r\n```\r\n\r\n由于还没有说到`import`所以占时忽略`b.js` , 这里的`export default $` 是指该文件返回`$`方法/类，import 调用的时候可以自定义导入的名称。\r\n\r\n简单来说，这种情况多用于封装大型类库，比如引入`jQuery`,`backbone`等之类的类库的时候，非常方便。\r\n\r\n#### 4. *\r\n\r\n据说可以导出所有的变量和方法，但是没有实际测试过，后续接触到之后在详细解说。\r\n\r\n\r\n\r\n### 二、Import\r\n\r\n介绍完`export`之后`import`应该就不用再细说概念了，其实就是导入的意思，其使基本方法也异常简单：\r\n\r\n```javascript\r\nimport Name from Module\r\n```\r\n\r\n同样它也有几种表现形式：\r\n\r\n```javascript\r\nimport CustomerName from 'module';\r\n\r\nimport {nameA,nameB} from 'module'\r\n\r\nimport CustomerName,{nameA} from 'module'\r\n\r\nimport {name as alias} from 'module'\r\n\r\nimport 'module'\r\n```\r\n\r\n#### 1. 导入default\r\n\r\n正如`export`时候说到的default，在export中通过default定义的输出，我们可以简单的通过自定义方法名来导入默认模块。\r\n\r\n例子参考`export`的default的例子，就不多说了。\r\n\r\n#### 2. 导读独立变量/方法\r\n\r\n通过花括号，我们可以导入在exprot中声明的多个或一个变量/方法\r\n\r\n例如：\r\n \r\n##### a.js\r\n```javascript\r\nvar a = 1;\r\nvar b = 2;\r\nvar c = function(){ return 3 }\r\n\r\nexport {a,b,c}\r\n```\r\n\r\n##### b.js\r\n```javascript\r\n// 一次导入一个变量/方法\r\nimport {a} from 'a.js'\r\n\r\n// 一次导入多个变量/方法\r\nimport {b,c} from 'a.js'\r\n\r\nconsole.log(a,b,c());\r\n```\r\n#### 3. default 和 变量/方法 导入混用\r\n\r\n实际上再使用过程中，import灰常灵活，我们甚至可以混合导入一些东西，例如：\r\n\r\n \r\n##### a.js\r\n```javascript\r\nvar a = 1;\r\nvar b = 2;\r\nvar c = function(){ return 3 };\r\nvar d = function(){ return 4 };\r\nexport {a,b,c};\r\nexport default d;\r\n```\r\n\r\n##### b.js\r\n```javascript\r\n// default 混合导入\r\nimport funD,{a,b,c} from 'a.js'\r\nconsole.log(funD(), a, b, c())\r\n```\r\n\r\n#### 4. 别名导入\r\n\r\n除了default导入可以自定义名称外，我们可以通过`as`来声明别名\r\n\r\n```javascript\r\nimport {a as vara,c as func} from 'a.js'\r\n```\r\n\r\n#### 5. 执行导入\r\n\r\n很奇怪的一个方法，他会执行导入的方法中的js，但不会返回任何值。\r\n\r\n##### a.js\r\n```javascript\r\nvar a = 1;\r\nconsole.log(a)\r\nexport {a}\r\n```\r\n\r\n##### b.js\r\n```javascript\r\nimport 'a.js'\r\n// 会执行a.js 在控制台输出 1\r\n\r\nconsole.log(a)\r\n// 返回 undefine 因为，import moudle 不会返回任何值，并且执行的环境也是在独立的scope\r\n```\r\n\r\n## 结尾\r\n\r\n总的来说 ES6 的模块管理让我们看到了很多的希望，也给我们带了了更多的可能，不知道它会不会让AMD，CMD慢慢的走向坟墓。\r\n至于大家问的比较多的问题，究竟什么时候可以使用 ES6 ，答案是现在就可以用，我们有很多编译工具，可以平稳的把ES6代码降级为兼容的ES5代码，后面有空我会单独来聊聊ES6的在项目中使用的方法的，今天就先说到这里吧。","visited":1062,"comment":2,"pubtime":{"$date":1440084212044},"html":"<p>相对比起<code>Python</code>,<code>PHP</code>等其他语言，<code>JavaScript</code> 在设计上视乎缺失了模块管理的部分，不过好消息是这些问题很快就会得到解决，在下一代JavaScript <code>ECMASCRIPT 6</code>中，这个问题被很好的解决了。</p>\n<h2 id=\"es6-module-\">ES6 Module 特性</h2>\n<p>Module 特性是在14年的7月被完全确认的，这就意味着到目前为止，语法相对比较稳定。</p>\n<p><code>Module</code> 包含了2个主要的部分，模块的定义 <code>export</code> 和模块的引入 <code>import</code>，如果是写过 Python 的同学对这个部分的概念会很容易理解，因为语法真的很像、很像。</p>\n<h3 id=\"-export\">一、Export</h3>\n<p><code>export</code> 顾名思义，就是定义模块的输出，基础语法很简单：</p>\n<pre><code class=\"lang-javascript\">export {export Name}\n</code></pre>\n<p>但根据输出的参数不同，它的表现形式也有所区别。</p>\n<pre><code class=\"lang-javascript\">export var a = &#39;123&#39;;\n\nexport function name(arguments){ //... }\n\nexport {nameA, nameB}\n\nexport default function name(arguments){ //.. }\n\nexport *\n</code></pre>\n<h4 id=\"1-\">1. 直接输出</h4>\n<p>在前两行中，我们对外输出了一个<code>变量a</code>, 一个<code>方法name</code>, 你可能已经留意到了，我们的方法和变量的声明都是直接写在的export的后面，那么你会想如果<code>export</code>关键字后面直接填变量名会怎么样呢？</p>\n<p>尝试如下:</p>\n<pre><code class=\"lang-javascript\">// BAD EXAMPLE !!\n\nvar a = &#39;123&#39;;\n\nfunction name(arguments) { //... }\n\nexport a;\n\n// or\n// export name;\n</code></pre>\n<p>执行之后会发现，这种在export后面直接写变量名的方式是会触发Error的，这种情况下我们只能吧定义写在export的后面。那么问题来了，如果所有的定义都写在export后面的话，相信处女做的同学们可能会坐不住了，别急，我们有第二种的方法。</p>\n<h4 id=\"2-\">2. 输出变量</h4>\n<p>这种情况应该比第一种方法要常见，很多时候我们会在输出之前定义好方法或者变量，如果需要输出可以加一个花括号，同样拿上面的例子来说明：</p>\n<pre><code class=\"lang-javascript\">var a = &#39;123&#39;;\n\nfunction name(arguments) { //... }\n\nexport {a,name};\n\n// or\n// export {a}\n// export {name}\n</code></pre>\n<p>这样就能愉快的输出变量了，不过和 <code>retrun</code> 略有区别的是，我们在export 之后还能继续输出。</p>\n<p>也就是说下面的两条语句的表现完全相同：</p>\n<h5 id=\"-\">单行模式</h5>\n<pre><code class=\"lang-javascript\">export {a,name}\n</code></pre>\n<h5 id=\"-\">多行模式</h5>\n<pre><code class=\"lang-javascript\">export {a}\nexport {name}\n</code></pre>\n<h4 id=\"3-default\">3. default</h4>\n<p>default模式比较特殊，也比较有用，先看例子吧：</p>\n<h5 id=\"a-js\">a.js</h5>\n<pre><code class=\"lang-javascript\">var $ = function(){}\n\n$.prototype.show = function(){ //.. }\n\nexport default $\n</code></pre>\n<h5 id=\"b-js\">b.js</h5>\n<pre><code class=\"lang-javascript\">import jQuery from &#39;a.js&#39;\n</code></pre>\n<p>由于还没有说到<code>import</code>所以占时忽略<code>b.js</code> , 这里的<code>export default $</code> 是指该文件返回<code>$</code>方法/类，import 调用的时候可以自定义导入的名称。</p>\n<p>简单来说，这种情况多用于封装大型类库，比如引入<code>jQuery</code>,<code>backbone</code>等之类的类库的时候，非常方便。</p>\n<h4 id=\"4-\">4. *</h4>\n<p>据说可以导出所有的变量和方法，但是没有实际测试过，后续接触到之后在详细解说。</p>\n<h3 id=\"-import\">二、Import</h3>\n<p>介绍完<code>export</code>之后<code>import</code>应该就不用再细说概念了，其实就是导入的意思，其使基本方法也异常简单：</p>\n<pre><code class=\"lang-javascript\">import Name from Module\n</code></pre>\n<p>同样它也有几种表现形式：</p>\n<pre><code class=\"lang-javascript\">import CustomerName from &#39;module&#39;;\n\nimport {nameA,nameB} from &#39;module&#39;\n\nimport CustomerName,{nameA} from &#39;module&#39;\n\nimport {name as alias} from &#39;module&#39;\n\nimport &#39;module&#39;\n</code></pre>\n<h4 id=\"1-default\">1. 导入default</h4>\n<p>正如<code>export</code>时候说到的default，在export中通过default定义的输出，我们可以简单的通过自定义方法名来导入默认模块。</p>\n<p>例子参考<code>export</code>的default的例子，就不多说了。</p>\n<h4 id=\"2-\">2. 导读独立变量/方法</h4>\n<p>通过花括号，我们可以导入在exprot中声明的多个或一个变量/方法</p>\n<p>例如：</p>\n<h5 id=\"a-js\">a.js</h5>\n<pre><code class=\"lang-javascript\">var a = 1;\nvar b = 2;\nvar c = function(){ return 3 }\n\nexport {a,b,c}\n</code></pre>\n<h5 id=\"b-js\">b.js</h5>\n<pre><code class=\"lang-javascript\">// 一次导入一个变量/方法\nimport {a} from &#39;a.js&#39;\n\n// 一次导入多个变量/方法\nimport {b,c} from &#39;a.js&#39;\n\nconsole.log(a,b,c());\n</code></pre>\n<h4 id=\"3-default-\">3. default 和 变量/方法 导入混用</h4>\n<p>实际上再使用过程中，import灰常灵活，我们甚至可以混合导入一些东西，例如：</p>\n<h5 id=\"a-js\">a.js</h5>\n<pre><code class=\"lang-javascript\">var a = 1;\nvar b = 2;\nvar c = function(){ return 3 };\nvar d = function(){ return 4 };\nexport {a,b,c};\nexport default d;\n</code></pre>\n<h5 id=\"b-js\">b.js</h5>\n<pre><code class=\"lang-javascript\">// default 混合导入\nimport funD,{a,b,c} from &#39;a.js&#39;\nconsole.log(funD(), a, b, c())\n</code></pre>\n<h4 id=\"4-\">4. 别名导入</h4>\n<p>除了default导入可以自定义名称外，我们可以通过<code>as</code>来声明别名</p>\n<pre><code class=\"lang-javascript\">import {a as vara,c as func} from &#39;a.js&#39;\n</code></pre>\n<h4 id=\"5-\">5. 执行导入</h4>\n<p>很奇怪的一个方法，他会执行导入的方法中的js，但不会返回任何值。</p>\n<h5 id=\"a-js\">a.js</h5>\n<pre><code class=\"lang-javascript\">var a = 1;\nconsole.log(a)\nexport {a}\n</code></pre>\n<h5 id=\"b-js\">b.js</h5>\n<pre><code class=\"lang-javascript\">import &#39;a.js&#39;\n// 会执行a.js 在控制台输出 1\n\nconsole.log(a)\n// 返回 undefine 因为，import moudle 不会返回任何值，并且执行的环境也是在独立的scope\n</code></pre>\n<h2 id=\"-\">结尾</h2>\n<p>总的来说 ES6 的模块管理让我们看到了很多的希望，也给我们带了了更多的可能，不知道它会不会让AMD，CMD慢慢的走向坟墓。\n至于大家问的比较多的问题，究竟什么时候可以使用 ES6 ，答案是现在就可以用，我们有很多编译工具，可以平稳的把ES6代码降级为兼容的ES5代码，后面有空我会单独来聊聊ES6的在项目中使用的方法的，今天就先说到这里吧。</p>\n","like":1}
{"_id":{"$oid":"558d74f22eacbd9648000001"},"title":"Nodejs实现可训练的中文分词实践","classid":"100","content":"前段时间在研究 TF-IDF、杰卡德相似系数计算文本的相似度的时候（目前我的博客中部分文章底部的“猜你喜欢”推荐的文章就是用这种算法计算出来的），用到了中文分词的一些东西，由于当时精力有限，直接用了python的“结巴分词”来实现。\r\n\r\n恰巧听说老东家最近出了个算法大赛，题目就是就是对小说《三体》进行中文分词！闲下来简单的动手写了一个Node版的算法，100行代码，虽然还是很初级的，但是还是想写些东西“纪念”一下。\r\n\r\n### 背景\r\n\r\n分词是搜索、自然语言分析等领域应用的比较多的比较基础的技术之一。由于英文本身每个单词间使用空格分隔，所以分词对于英语系的文本来说，就没有那么的复杂了，难题出现在类似于中文之类的语言，这类语言在每个词之间并没有明显的分隔，想要对这样的语言进行分词确实比较困难。\r\n\r\n市面上常用的几种方法是，第一种通过统计分析来拆词，第二种是通过自然语言的分析，判断句子成分，来进行分词，等等。这些方法各有利弊，没有明确的说法说哪一种方法完胜于另外一种。\r\n\r\n### 思考\r\n\r\n由于条件有限，大规模机器学习什么的并不现实，所以我们采用了第一种基于统计的方法进行分词。\r\n\r\n方法有了，那么问题来了，如何知道一句话中的哪些字的组合是一个词呢？ 维护一个字典通过字典来判断？ 但问题又来了，字典哪里来？ 网上找？ 但这样和直接用别人的库又有什么区别呢？ 有没有一种方法可以让机器自己去学习，去判断词呢？ \r\n\r\n当然可以，我们可以把一句话中所有可能的词语组合都找到，然后判断这写组合出现的频次，大于某些频次的，就可以判定为是一个词组。\r\n\r\nOK，到此为止我们想到了一种“可行”的方法，但是把所有的字的组合都找到对于一篇文章来说靠谱么？这会是一个天文数字吧？！！ 别急，我们一步一步来。 这里先买个关子，后面我会结合 [trie树(字典树)](http://baike.baidu.com/view/2759664.htm) 和 [HMM(隐马尔可夫模型)](http://baike.baidu.com/view/1174010.htm) 来实现。\r\n\r\n### 实现过程\r\n\r\n我们开动吧！\r\n\r\n开始前还是先奉贤上 [实现代码](https://gist.github.com/zmofei/a1c8fe8610a5f1771189)。\r\n\r\nOK, Let's Do It!\r\n\r\n首先是拿到我们的素材  [三体II-黑暗森林](https://gist.githubusercontent.com/zmofei/4a49473e253e49a1a3bc/raw/text.txt) 这里我们暂且把它存为 `text.txt` .\r\n\r\n新建一个 `task.js` 文件，接下来我们开始搬砖。\r\n\r\n```\r\n// 引用fs模块\r\nvar fs = require('fs')\r\n\r\n// 创建一些变量，后面会说到\r\nvar trie = {}\r\nvar tempWords = {};\r\n\r\n// 开始读取文件text.txt\r\nfs.readFile('./text.txt',function(err,callback){\r\n    // 将读取的二进制转换成String，\r\n    // 注意，大文件的话要小心的分片处理，当心内存爆掉。\r\n    var str = callback.toString();\r\n    \r\n    // 接下来，我们需要“清理”我们的素材，\r\n    // 首先，把所有的不是中文的字符统统替换成“@”，\r\n    // “@”只是个临时字符串，如果你喜欢，可以是任意字符\r\n    // 例如：\r\n    //     \"大家好！：）我是Mofei\" => \"大家好@@@我是@@@@@\"\r\n    str = str.replace(/[^\\u4e00-\\u9fa5]/g,'@');\r\n    // 把替换下来的@替换成空格\r\n    // 例如：\r\n    //     \"大家好@@@我是@@@@@\" => \"大家好 我是 \"\r\n    str = str.replace(/@+/g,' ')\r\n    split(str);\r\n})\r\n```\r\n\r\n通过上面的操作，我们拿到的就是一份比较干净的数据了，接下来是我们的重点了。\r\n\r\n这里我们要处理一句话中的字符串的所有可能的组合，介于通常情况下中文的词汇大多数都是4个字以内的，我们以4个字来举个例子：\r\n\r\n比如字符串 “欢迎大家关注” 可以组合成：\r\n\r\n`欢迎大家`  `迎大家关` `大家关注` `欢迎大` `迎大家` `大家关`  `家关注` `欢迎`  `迎大` `大家` `家关` `关注`\r\n\r\n简简单单的6个字可以有12种组合，那么我们要把所有的组合都记录下来么？STOP！当你有这种想法的时候，你的计算机一定在痛哭流涕，对于一篇长篇小说来说，这真的是一场灾难！那么能不能用什么比较好的方法来实现呢？对那就是 [trie树(字典树)](http://baike.baidu.com/view/2759664.htm) 原理什么的不说了，大家可以自己去看。\r\n\r\n我在trie的基础上又增加了计数`len`字段，来帮助我们辅助判断\r\n\r\n树化之后我们得到的是这样的结构：\r\n\r\n```\r\n{\r\n    \"欢\": {\r\n        \"迎\": {\r\n            \"大\": {\r\n                \"家\": {\r\n                    \"len\": 1\r\n                },\r\n                \"len\": 2\r\n            },\r\n            \"len\": 3\r\n        },\r\n        \"len\": 3\r\n    },\r\n    \"迎\": {\r\n        \"大\": {\r\n            \"家\": {\r\n                \"关\": {\r\n                    \"len\": 1\r\n                },\r\n                \"len\": 2\r\n            },\r\n            \"len\": 3\r\n        },\r\n        \"len\": 3\r\n    },\r\n    \"大\": {\r\n        \"家\": {\r\n            \"关\": {\r\n                \"注\": {\r\n                    \"len\": 1\r\n                },\r\n                \"len\": 2\r\n            },\r\n            \"len\": 3\r\n        },\r\n        \"len\": 3\r\n    },\r\n    \"家\": {\r\n        \"关\": {\r\n            \"注\": {\r\n                \"len\": 1\r\n            },\r\n            \"len\": 2\r\n        },\r\n        \"len\": 2\r\n    },\r\n    \"关\": {\r\n        \"注\": {\r\n            \"len\": 1\r\n        },\r\n        \"len\": 1\r\n    }\r\n}\r\n```\r\n\r\n通过上面的数的`len`我们可以精简到如下的几个“词” （从根节点的不停深入，直到len有异常变化为止）：\r\n\r\n`欢迎` `迎大` `大家` `家关` `关注`\r\n\r\nOK，这里我们从12个组合中精简到5个\r\n\r\n> 等等！ WTF！！！ `迎大` `家关` 是什么东西？耍我呢？这是词么？\r\n\r\n到这里，大家先别着急，有没有注意到我们后面的`len`字段？而且我们现在用的也仅仅才是一句话而已。我们暂且叫这个`trie树`是我们的模型（其实他只是`训练`的结果罢了）。\r\n\r\n> ”卧了个槽？`训练`？“ \r\n\r\n没错！！如果我们拿更多的语句来训练的话，这里的len会有显著的变化，最终我们可以自己定一个策略，比如len小于10的全部废弃，从根节点开始，len的偏移量大于一定的值再舍去等等。\r\n\r\n尝试多跑一些文章之后，你会发现你真的`训练`出了一个字典！ 如果你成功实现了的话，让我们开瓶香槟庆祝一下！\r\n\r\n好，回到我们的代码：\r\n\r\n```\r\n// 处理句子\r\nfunction split(str) {\r\n    // 将clean的字符串按照空格拆分，\r\n    // 最终我们拿到的是一句一句的数组\r\n    str = str.split(' ');\r\n    \r\n    for (var i = 0; i < str.length; i++) {\r\n        // 把每句话拆分成一个一个的字\r\n        var words = str[i];\r\n    \r\n        if (words.length <= 1) {\r\n            // 废弃一个字的“词”\r\n            continue;\r\n        }\r\n\r\n        if (words.length === 2) {\r\n            // 如果是两个长度的直接处理\r\n            wordsToTrie(words);\r\n        } else {\r\n            // 如果是大于2个长度的，\r\n            // 找到所有字的组合进行处理\r\n            for (var j = 0; j < words.length - 2; j++) {\r\n                // 阀值我们取4，即默认一个词的最大字数是4\r\n                // 当然你可以取更大的值，越大越耗费性能\r\n                wordsToTrie(words.substr(j, 4));\r\n            }\r\n        }\r\n    }\r\n    \r\n    // 把trie数转换成 词的字典\r\n    // 即 {\"你好\":14,\"大楼\":45}\r\n    trieToWords();\r\n    // 输出结果\r\n    wordsToArrAndRank()\r\n}\r\n\r\nfunction wordsToTrie(str) {\r\n    \r\n    var words = str.split('');\r\n\r\n    // stopWords 很好理解，在语言中有些词出现的频率过高没有实际意义，\r\n    // 比如 “我的” “这个” 等，这些词对搜索、判断文章的特征来说没有任何帮助，\r\n    // 我们可以将它们过滤掉\r\n    // 网上有现成的stopwords的字典，这里我选取了一小部分\r\n    var stopWords = [\"和\", \"与\", \"你\", \"我\", \"两\", \"这\", \"把\", \"那\", \"个\", \"他\", \"您\", \"它\", \"们\", \"是\", \"的\", \"一\", \"了\", \"在\"]\r\n    if (stopWords.indexOf(words[0]) !== -1) {\r\n        return false;\r\n    }\r\n    \r\n    var temp = trie;\r\n    for (var i = 0; i < words.length; i++) {\r\n        // 把字符串存储到trie数上\r\n        temp = saveToTrie(temp, words[i]);\r\n    }\r\n\r\n}\r\n\r\n// 把字符串存储到trie数上\r\nfunction saveToTrie(obj, chart) {\r\n\r\n    // 如果不存在就新创建一个空间\r\n    // 如 {“你”:{len:0}} + \"我\" => \r\n    // {“你”:{\"我\":{len:0},len:0}}\r\n    obj[chart] = obj[chart] || {\r\n        len: 0\r\n    }\r\n    \r\n    // 如果存在，计数加1\r\n    obj[chart].len += 1;\r\n    return obj[chart];\r\n}\r\n\r\nfunction trieToWords() {\r\n    var words = [];\r\n    conmbine(trie, '');\r\n\r\n}\r\n```\r\n\r\n自此，我们的trie树就“调教”好了，接下来就是一些小小的善后工作了\r\n\r\n```\r\n// 把trie树转换成 词的字典\r\n// 比如：\r\n//     {\"你好\":14,\"大楼\":45}\r\n// 这里你可以设置成自己的规则\r\n// 比如设置len的阀值，len的变化异常时候停止等\r\n// 举例：\r\n// {\"你:{\r\n//      \"好\":{\r\n//          \"明\":{\r\n//              \"天\":{\r\n//                  len: 2,\r\n//              }\r\n//              len: 2,\r\n//          },\r\n//          len: 14\r\n//      },\r\n//      len: 14\r\n//   }\r\n// }\r\n// 这种情况下，我们可以判断这个词到“好”就结束了，\r\n// 因为后面的“明”的权只有 2，明显的低于前面的14\r\nfunction conmbine(obj, str) {\r\n    var retObj = [];\r\n    var haveSone = false;\r\n    var pow = obj.len;\r\n    for (i in obj) {\r\n        if (obj[i].len <= 6) {\r\n            continue;\r\n        }\r\n        if (i !== 'len') {\r\n            conmbine(obj[i], str + i);\r\n        }\r\n    }\r\n\r\n    if (!haveSone && str.length >= 2) {\r\n        tempWords[str] = tempWords[str] || 0\r\n        tempWords[str] = Math.max(tempWords[str], pow)\r\n    }\r\n}\r\n```\r\n\r\n接下来就是输出结果的时候了\r\n\r\n```\r\n// 输出结果，并按照词频排序\r\nfunction wordsToArrAndRank() {\r\n    var wordsArr = [];\r\n    var keys = [];\r\n    for (var i in tempWords) {\r\n        keys.push(i);\r\n    }\r\n    \r\n    keys = '|' + keys.join('|') + '|'\r\n    for (var i in tempWords) {\r\n        // 注意这个正则，它是为了满足比赛规则而出现的\r\n        // 其实可以去掉,\r\n        // 规则是： \r\n        // 对于“苹果”,“青苹果”只取 “青苹果”\r\n        // 对于“宝石”,“红宝石”只取 “红宝石”\r\n        // 当然了如果需要判断权值的话，这里也可以判断，就不做演示了\r\n        var noLeft = !RegExp('[^|]+' + i + '\\\\|').test(keys);\r\n        var noRight = !RegExp('\\\\|+' + i + '[^|]+').test(keys)\r\n        if (noLeft && noRight) {\r\n            wordsArr.push([i, tempWords[i]])\r\n        }\r\n    }\r\n    // 按照词频排序\r\n    wordsArr.sort(function (a, b) {\r\n        return a[1] - b[1]\r\n    })\r\n    // 输出\r\n    console.log(JSON.stringify(wordsArr))\r\n    console.log(wordsArr)\r\n}\r\n```\r\n\r\n下面是用这套算法跑出来的结果（仅取了前20个结果供参考）\r\n```\r\n  ['必须', 59 ],\r\n  [ '第一次', 60 ],\r\n  [ '眼睛', 60 ],\r\n  [ '首先', 61 ],\r\n  [ '来自', 62 ],\r\n  [ '三体世界', 63 ],\r\n  [ '似乎', 64 ],\r\n  [ '立刻', 64 ],\r\n  [ '变得', 65 ],\r\n  [ '突然', 69 ],\r\n  [ '信息', 69 ],\r\n  [ '字幕', 70 ],\r\n  [ '虽然', 76 ],\r\n  [ '东方延绪', 81 ],\r\n  [ '几乎', 81 ],\r\n  [ '正在', 85 ],\r\n  [ '完全', 87 ],\r\n  [ '自然选择', 91 ],\r\n  [ '面壁计划', 94 ],\r\n  [ '雷迪亚兹', 195 ]\r\n```\r\n\r\n附录：[代码传送门](https://gist.github.com/zmofei/a1c8fe8610a5f1771189)\r\n","visited":2687,"comment":3,"pubtime":{"$date":1435333874014},"links":[["51d3de728ece70c43800000d",{"present":0.025641025641025640136,"title":"javascript区分判断ie6、ie7、ie8"}]],"html":"<p>前段时间在研究 TF-IDF、杰卡德相似系数计算文本的相似度的时候（目前我的博客中部分文章底部的“猜你喜欢”推荐的文章就是用这种算法计算出来的），用到了中文分词的一些东西，由于当时精力有限，直接用了python的“结巴分词”来实现。</p>\n<p>恰巧听说老东家最近出了个算法大赛，题目就是就是对小说《三体》进行中文分词！闲下来简单的动手写了一个Node版的算法，100行代码，虽然还是很初级的，但是还是想写些东西“纪念”一下。</p>\n<h3 id=\"-\">背景</h3>\n<p>分词是搜索、自然语言分析等领域应用的比较多的比较基础的技术之一。由于英文本身每个单词间使用空格分隔，所以分词对于英语系的文本来说，就没有那么的复杂了，难题出现在类似于中文之类的语言，这类语言在每个词之间并没有明显的分隔，想要对这样的语言进行分词确实比较困难。</p>\n<p>市面上常用的几种方法是，第一种通过统计分析来拆词，第二种是通过自然语言的分析，判断句子成分，来进行分词，等等。这些方法各有利弊，没有明确的说法说哪一种方法完胜于另外一种。</p>\n<h3 id=\"-\">思考</h3>\n<p>由于条件有限，大规模机器学习什么的并不现实，所以我们采用了第一种基于统计的方法进行分词。</p>\n<p>方法有了，那么问题来了，如何知道一句话中的哪些字的组合是一个词呢？ 维护一个字典通过字典来判断？ 但问题又来了，字典哪里来？ 网上找？ 但这样和直接用别人的库又有什么区别呢？ 有没有一种方法可以让机器自己去学习，去判断词呢？ </p>\n<p>当然可以，我们可以把一句话中所有可能的词语组合都找到，然后判断这写组合出现的频次，大于某些频次的，就可以判定为是一个词组。</p>\n<p>OK，到此为止我们想到了一种“可行”的方法，但是把所有的字的组合都找到对于一篇文章来说靠谱么？这会是一个天文数字吧？！！ 别急，我们一步一步来。 这里先买个关子，后面我会结合 <a href=\"http://baike.baidu.com/view/2759664.htm\">trie树(字典树)</a> 和 <a href=\"http://baike.baidu.com/view/1174010.htm\">HMM(隐马尔可夫模型)</a> 来实现。</p>\n<h3 id=\"-\">实现过程</h3>\n<p>我们开动吧！</p>\n<p>开始前还是先奉贤上 <a href=\"https://gist.github.com/zmofei/a1c8fe8610a5f1771189\">实现代码</a>。</p>\n<p>OK, Let&#39;s Do It!</p>\n<p>首先是拿到我们的素材  <a href=\"https://gist.githubusercontent.com/zmofei/4a49473e253e49a1a3bc/raw/text.txt\">三体II-黑暗森林</a> 这里我们暂且把它存为 <code>text.txt</code> .</p>\n<p>新建一个 <code>task.js</code> 文件，接下来我们开始搬砖。</p>\n<pre><code>// 引用fs模块\nvar fs = require(&#39;fs&#39;)\n\n// 创建一些变量，后面会说到\nvar trie = {}\nvar tempWords = {};\n\n// 开始读取文件text.txt\nfs.readFile(&#39;./text.txt&#39;,function(err,callback){\n    // 将读取的二进制转换成String，\n    // 注意，大文件的话要小心的分片处理，当心内存爆掉。\n    var str = callback.toString();\n\n    // 接下来，我们需要“清理”我们的素材，\n    // 首先，把所有的不是中文的字符统统替换成“@”，\n    // “@”只是个临时字符串，如果你喜欢，可以是任意字符\n    // 例如：\n    //     &quot;大家好！：）我是Mofei&quot; =&gt; &quot;大家好@@@我是@@@@@&quot;\n    str = str.replace(/[^\\u4e00-\\u9fa5]/g,&#39;@&#39;);\n    // 把替换下来的@替换成空格\n    // 例如：\n    //     &quot;大家好@@@我是@@@@@&quot; =&gt; &quot;大家好 我是 &quot;\n    str = str.replace(/@+/g,&#39; &#39;)\n    split(str);\n})\n</code></pre><p>通过上面的操作，我们拿到的就是一份比较干净的数据了，接下来是我们的重点了。</p>\n<p>这里我们要处理一句话中的字符串的所有可能的组合，介于通常情况下中文的词汇大多数都是4个字以内的，我们以4个字来举个例子：</p>\n<p>比如字符串 “欢迎大家关注” 可以组合成：</p>\n<p><code>欢迎大家</code>  <code>迎大家关</code> <code>大家关注</code> <code>欢迎大</code> <code>迎大家</code> <code>大家关</code>  <code>家关注</code> <code>欢迎</code>  <code>迎大</code> <code>大家</code> <code>家关</code> <code>关注</code></p>\n<p>简简单单的6个字可以有12种组合，那么我们要把所有的组合都记录下来么？STOP！当你有这种想法的时候，你的计算机一定在痛哭流涕，对于一篇长篇小说来说，这真的是一场灾难！那么能不能用什么比较好的方法来实现呢？对那就是 <a href=\"http://baike.baidu.com/view/2759664.htm\">trie树(字典树)</a> 原理什么的不说了，大家可以自己去看。</p>\n<p>我在trie的基础上又增加了计数<code>len</code>字段，来帮助我们辅助判断</p>\n<p>树化之后我们得到的是这样的结构：</p>\n<pre><code>{\n    &quot;欢&quot;: {\n        &quot;迎&quot;: {\n            &quot;大&quot;: {\n                &quot;家&quot;: {\n                    &quot;len&quot;: 1\n                },\n                &quot;len&quot;: 2\n            },\n            &quot;len&quot;: 3\n        },\n        &quot;len&quot;: 3\n    },\n    &quot;迎&quot;: {\n        &quot;大&quot;: {\n            &quot;家&quot;: {\n                &quot;关&quot;: {\n                    &quot;len&quot;: 1\n                },\n                &quot;len&quot;: 2\n            },\n            &quot;len&quot;: 3\n        },\n        &quot;len&quot;: 3\n    },\n    &quot;大&quot;: {\n        &quot;家&quot;: {\n            &quot;关&quot;: {\n                &quot;注&quot;: {\n                    &quot;len&quot;: 1\n                },\n                &quot;len&quot;: 2\n            },\n            &quot;len&quot;: 3\n        },\n        &quot;len&quot;: 3\n    },\n    &quot;家&quot;: {\n        &quot;关&quot;: {\n            &quot;注&quot;: {\n                &quot;len&quot;: 1\n            },\n            &quot;len&quot;: 2\n        },\n        &quot;len&quot;: 2\n    },\n    &quot;关&quot;: {\n        &quot;注&quot;: {\n            &quot;len&quot;: 1\n        },\n        &quot;len&quot;: 1\n    }\n}\n</code></pre><p>通过上面的数的<code>len</code>我们可以精简到如下的几个“词” （从根节点的不停深入，直到len有异常变化为止）：</p>\n<p><code>欢迎</code> <code>迎大</code> <code>大家</code> <code>家关</code> <code>关注</code></p>\n<p>OK，这里我们从12个组合中精简到5个</p>\n<blockquote>\n<p>等等！ WTF！！！ <code>迎大</code> <code>家关</code> 是什么东西？耍我呢？这是词么？</p>\n</blockquote>\n<p>到这里，大家先别着急，有没有注意到我们后面的<code>len</code>字段？而且我们现在用的也仅仅才是一句话而已。我们暂且叫这个<code>trie树</code>是我们的模型（其实他只是<code>训练</code>的结果罢了）。</p>\n<blockquote>\n<p>”卧了个槽？<code>训练</code>？“ </p>\n</blockquote>\n<p>没错！！如果我们拿更多的语句来训练的话，这里的len会有显著的变化，最终我们可以自己定一个策略，比如len小于10的全部废弃，从根节点开始，len的偏移量大于一定的值再舍去等等。</p>\n<p>尝试多跑一些文章之后，你会发现你真的<code>训练</code>出了一个字典！ 如果你成功实现了的话，让我们开瓶香槟庆祝一下！</p>\n<p>好，回到我们的代码：</p>\n<pre><code>// 处理句子\nfunction split(str) {\n    // 将clean的字符串按照空格拆分，\n    // 最终我们拿到的是一句一句的数组\n    str = str.split(&#39; &#39;);\n\n    for (var i = 0; i &lt; str.length; i++) {\n        // 把每句话拆分成一个一个的字\n        var words = str[i];\n\n        if (words.length &lt;= 1) {\n            // 废弃一个字的“词”\n            continue;\n        }\n\n        if (words.length === 2) {\n            // 如果是两个长度的直接处理\n            wordsToTrie(words);\n        } else {\n            // 如果是大于2个长度的，\n            // 找到所有字的组合进行处理\n            for (var j = 0; j &lt; words.length - 2; j++) {\n                // 阀值我们取4，即默认一个词的最大字数是4\n                // 当然你可以取更大的值，越大越耗费性能\n                wordsToTrie(words.substr(j, 4));\n            }\n        }\n    }\n\n    // 把trie数转换成 词的字典\n    // 即 {&quot;你好&quot;:14,&quot;大楼&quot;:45}\n    trieToWords();\n    // 输出结果\n    wordsToArrAndRank()\n}\n\nfunction wordsToTrie(str) {\n\n    var words = str.split(&#39;&#39;);\n\n    // stopWords 很好理解，在语言中有些词出现的频率过高没有实际意义，\n    // 比如 “我的” “这个” 等，这些词对搜索、判断文章的特征来说没有任何帮助，\n    // 我们可以将它们过滤掉\n    // 网上有现成的stopwords的字典，这里我选取了一小部分\n    var stopWords = [&quot;和&quot;, &quot;与&quot;, &quot;你&quot;, &quot;我&quot;, &quot;两&quot;, &quot;这&quot;, &quot;把&quot;, &quot;那&quot;, &quot;个&quot;, &quot;他&quot;, &quot;您&quot;, &quot;它&quot;, &quot;们&quot;, &quot;是&quot;, &quot;的&quot;, &quot;一&quot;, &quot;了&quot;, &quot;在&quot;]\n    if (stopWords.indexOf(words[0]) !== -1) {\n        return false;\n    }\n\n    var temp = trie;\n    for (var i = 0; i &lt; words.length; i++) {\n        // 把字符串存储到trie数上\n        temp = saveToTrie(temp, words[i]);\n    }\n\n}\n\n// 把字符串存储到trie数上\nfunction saveToTrie(obj, chart) {\n\n    // 如果不存在就新创建一个空间\n    // 如 {“你”:{len:0}} + &quot;我&quot; =&gt; \n    // {“你”:{&quot;我&quot;:{len:0},len:0}}\n    obj[chart] = obj[chart] || {\n        len: 0\n    }\n\n    // 如果存在，计数加1\n    obj[chart].len += 1;\n    return obj[chart];\n}\n\nfunction trieToWords() {\n    var words = [];\n    conmbine(trie, &#39;&#39;);\n\n}\n</code></pre><p>自此，我们的trie树就“调教”好了，接下来就是一些小小的善后工作了</p>\n<pre><code>// 把trie树转换成 词的字典\n// 比如：\n//     {&quot;你好&quot;:14,&quot;大楼&quot;:45}\n// 这里你可以设置成自己的规则\n// 比如设置len的阀值，len的变化异常时候停止等\n// 举例：\n// {&quot;你:{\n//      &quot;好&quot;:{\n//          &quot;明&quot;:{\n//              &quot;天&quot;:{\n//                  len: 2,\n//              }\n//              len: 2,\n//          },\n//          len: 14\n//      },\n//      len: 14\n//   }\n// }\n// 这种情况下，我们可以判断这个词到“好”就结束了，\n// 因为后面的“明”的权只有 2，明显的低于前面的14\nfunction conmbine(obj, str) {\n    var retObj = [];\n    var haveSone = false;\n    var pow = obj.len;\n    for (i in obj) {\n        if (obj[i].len &lt;= 6) {\n            continue;\n        }\n        if (i !== &#39;len&#39;) {\n            conmbine(obj[i], str + i);\n        }\n    }\n\n    if (!haveSone &amp;&amp; str.length &gt;= 2) {\n        tempWords[str] = tempWords[str] || 0\n        tempWords[str] = Math.max(tempWords[str], pow)\n    }\n}\n</code></pre><p>接下来就是输出结果的时候了</p>\n<pre><code>// 输出结果，并按照词频排序\nfunction wordsToArrAndRank() {\n    var wordsArr = [];\n    var keys = [];\n    for (var i in tempWords) {\n        keys.push(i);\n    }\n\n    keys = &#39;|&#39; + keys.join(&#39;|&#39;) + &#39;|&#39;\n    for (var i in tempWords) {\n        // 注意这个正则，它是为了满足比赛规则而出现的\n        // 其实可以去掉,\n        // 规则是： \n        // 对于“苹果”,“青苹果”只取 “青苹果”\n        // 对于“宝石”,“红宝石”只取 “红宝石”\n        // 当然了如果需要判断权值的话，这里也可以判断，就不做演示了\n        var noLeft = !RegExp(&#39;[^|]+&#39; + i + &#39;\\\\|&#39;).test(keys);\n        var noRight = !RegExp(&#39;\\\\|+&#39; + i + &#39;[^|]+&#39;).test(keys)\n        if (noLeft &amp;&amp; noRight) {\n            wordsArr.push([i, tempWords[i]])\n        }\n    }\n    // 按照词频排序\n    wordsArr.sort(function (a, b) {\n        return a[1] - b[1]\n    })\n    // 输出\n    console.log(JSON.stringify(wordsArr))\n    console.log(wordsArr)\n}\n</code></pre><p>下面是用这套算法跑出来的结果（仅取了前20个结果供参考）</p>\n<pre><code>  [&#39;必须&#39;, 59 ],\n  [ &#39;第一次&#39;, 60 ],\n  [ &#39;眼睛&#39;, 60 ],\n  [ &#39;首先&#39;, 61 ],\n  [ &#39;来自&#39;, 62 ],\n  [ &#39;三体世界&#39;, 63 ],\n  [ &#39;似乎&#39;, 64 ],\n  [ &#39;立刻&#39;, 64 ],\n  [ &#39;变得&#39;, 65 ],\n  [ &#39;突然&#39;, 69 ],\n  [ &#39;信息&#39;, 69 ],\n  [ &#39;字幕&#39;, 70 ],\n  [ &#39;虽然&#39;, 76 ],\n  [ &#39;东方延绪&#39;, 81 ],\n  [ &#39;几乎&#39;, 81 ],\n  [ &#39;正在&#39;, 85 ],\n  [ &#39;完全&#39;, 87 ],\n  [ &#39;自然选择&#39;, 91 ],\n  [ &#39;面壁计划&#39;, 94 ],\n  [ &#39;雷迪亚兹&#39;, 195 ]\n</code></pre><p>附录：<a href=\"https://gist.github.com/zmofei/a1c8fe8610a5f1771189\">代码传送门</a></p>\n","like":1}
{"_id":{"$oid":"5284bfd167e841743e000001"},"classid":"400","comment":8,"content":"4年前冬天，我在博客上给自己写了一封信，信的内容是这样的：\r\n\r\n> 总是认为时间还有很长很长，未来的机会还有很多很多，看了茂神州的经历才明白很多很多。求职简历不是在毕业时候写的，而是大一就写未来的简历，先写出简历框架，接下来结合简历磨练实力，做出成绩后再反过来填满简历！\r\n\r\n>本来是准备毕业后走创业这条路的，所以也就觉得学历什么的对我来说并不是占据着首要位置，很巧的是十一的一趟马鞍山之行，突然也让我明白了一些道理，自己的理想是走计算机这条路，创业是一条路，就业也是一条路，一个很好的工作并不是没有创业的好！\r\n\r\n>于是给自己的未来写规划了一条新的道路，算是自己简历的开始吧。\r\n\r\n>一、剩下不到两年的时间，通过计算机三级，过英语四级考试（尽力通过六级）。\r\n\r\n>二、毕业后专升本（上海理工大学）\r\n\r\n>三、如果条件允许的话尝试考研。\r\n\r\n>四、进入大型公司或者企业从事计算机工作，或者自己创业。\r\n\r\n>任重而道远，不知道未来是成功还是失败，但是只要努力就不会有遗憾！ 加油！\r\n\r\n当时应该是大二，现在回过头来再看看，算是一个总结，亦或是一个崭新的开始。\r\n\r\n在这四年里，我通过了计算机三级、英语四级，完成了专升本的学业，正在尝试考研的事情，工作也还算可以。基本上算是之前许下的愿望都实现了。嘿嘿，实践证明我还是蛮勤奋的呢~\r\n\r\n之后还要继续加油。\r\n\r\n我希望未来的我可以：\r\n\r\n> 有稳定并且可以引以为傲的工作或者事业。\r\n\r\n> 房子车子要有的。\r\n\r\n> 去一趟西藏吧。\r\n\r\n> 应该结婚了吧。\r\n\r\n总之，我还要继续加油，嘿嘿！ 加油！加油！\r\n","pubtime":{"$date":1384431569860},"title":"曾经写给自己的信","visited":11022,"links":[["52836b510d1662a510000001",{"present":0.025641025641025640136,"title":"懵懂的季节（原标题 “等待=放弃？ ” ）"}],["52fefd3ebd0c693905000007",{"present":0.025641025641025640136,"title":"未来的6大高薪职业"}],["52288399917d2e280e000001",{"present":0.025641025641025640136,"title":"给正在实习和将要实习的大学生——实习经验分享"}]],"html":"<p>4年前冬天，我在博客上给自己写了一封信，信的内容是这样的：</p>\n<blockquote>\n<p>总是认为时间还有很长很长，未来的机会还有很多很多，看了茂神州的经历才明白很多很多。求职简历不是在毕业时候写的，而是大一就写未来的简历，先写出简历框架，接下来结合简历磨练实力，做出成绩后再反过来填满简历！</p>\n<p>本来是准备毕业后走创业这条路的，所以也就觉得学历什么的对我来说并不是占据着首要位置，很巧的是十一的一趟马鞍山之行，突然也让我明白了一些道理，自己的理想是走计算机这条路，创业是一条路，就业也是一条路，一个很好的工作并不是没有创业的好！</p>\n<p>于是给自己的未来写规划了一条新的道路，算是自己简历的开始吧。</p>\n<p>一、剩下不到两年的时间，通过计算机三级，过英语四级考试（尽力通过六级）。</p>\n<p>二、毕业后专升本（上海理工大学）</p>\n<p>三、如果条件允许的话尝试考研。</p>\n<p>四、进入大型公司或者企业从事计算机工作，或者自己创业。</p>\n<p>任重而道远，不知道未来是成功还是失败，但是只要努力就不会有遗憾！ 加油！</p>\n</blockquote>\n<p>当时应该是大二，现在回过头来再看看，算是一个总结，亦或是一个崭新的开始。</p>\n<p>在这四年里，我通过了计算机三级、英语四级，完成了专升本的学业，正在尝试考研的事情，工作也还算可以。基本上算是之前许下的愿望都实现了。嘿嘿，实践证明我还是蛮勤奋的呢~</p>\n<p>之后还要继续加油。</p>\n<p>我希望未来的我可以：</p>\n<blockquote>\n<p>有稳定并且可以引以为傲的工作或者事业。</p>\n<p>房子车子要有的。</p>\n<p>去一趟西藏吧。</p>\n<p>应该结婚了吧。</p>\n</blockquote>\n<p>总之，我还要继续加油，嘿嘿！ 加油！加油！</p>\n"}
{"_id":{"$oid":"51d3dfbb8ece70c438000010"},"classid":"400","comment":0,"content":"作个大胆的猜想，1%的人是很成功的，而其他99%的人只能梦想着成功却得不到它，我认为这样说没什么不妥的。\r\n我注意到大多数人在人生中从未真正取得成就，对这一点我很无奈。尽管很多人都有成功的梦想和愿望，希望能过上真正快乐的生活，但是他们也只能那样了。只是梦想和愿望。\r\n从另一方面说，为什么一些人就能事事都成功呢？就好像他们有超能力。\r\n有没有可能去学习一下如何成功呢？是否可以采取一些行动、养成一些习惯来确保你事事都成功，或者说成功从某种角度来说是通过DNA来选取寥寥几个成功人士的。\r\n一些人好似什么都有：广泛的人脉、爱情、友情、金钱以及各方面的成功，那么是什么让这些人与众不同的呢？\r\n这个问题的讨论是很开放的，因为我只想表达一下我自己的观点，以及那些对我的成功产生影响的别人的观点。\r\n\r\n\r\n### 成功秘诀1--你的童年\r\n我个人认为你的童年和你早些时候的经验在你的成功与否方面扮演着重要角色。\r\n仅仅是出生过程就可能决定你将来会成为什么样的人。虽然我想不出来任何具体的事例，但是我记得我读过一个成功人士的故事，而他有着坎坷的经历。他比预产期提前一个月出生，当时情况十分危险。医生说恐怕他活不了，但是他活下来了。他不断抵抗，最终活了下来。并且在他的余生，他与一切困难斗争，取得了成功。\r\n这是不是真的并不重要，我相信一切东西比如你的出生（尽管你什么也不记得了）会很大程度上影响你意志力的优点以及你生活里的性格特点。\r\n出生之后，你对外部所有的影响都是主观的，而父母在你的少年时期对你的影响是最大的。\r\n你是天生就拥有你想要的一切，还是说你必须去为它们打拼？有没有人说过你什么时候也成不了大器，还是说有人鼓励你要永远追随你的梦想并且相信自己？\r\n也许你会很纳闷为什么我会说起童年这个话题。尽管童年对你的成功与否起很大的作用，但是你没法控制它，你也改变不了它。\r\n我谈论童年的原因很简单。尽管你不能改变你的过去和童年，但是通过了解你是如何成长的，仔细考虑你的早期经验，你可能会做出一些必要的改变，从而让你更成功。\r\n举个例子来说，如果你总是被动的，并且你的所得也并非通过你自身的努力所得，那你之所以不成功，原因很简单，就是因为你工作不够努力，并且你得不到自己想要的东西时你就选择了放弃。\r\n你把握不了过去，但是从今往后，你行动起来，你会有改变未来的能力的。\r\n\r\n\r\n### 成功秘诀2--相信自己\r\n\r\n我注意到成功的人对自己都有着坚定地信仰.\r\n对于别人来说，这种信仰看似是愚蠢的固执，但我认为，相信自己是取得成功的灵丹妙药。\r\n你必须全心全意的相信你会成功的。不管花费多长时间，也不管你尝试了多少次或者失败了多少次，要100%地相信你会成功，在你取得这理应得到的成功之前，这只是一个时间和坚持的问题。\r\n生活总是会抛给我们一些巨大的糟糕的挫折，这很容易让我们放弃对我们所坚持的一切的信仰。我觉得放弃对许多事情的信念可以，但是绝对不要放弃对自己的信仰。要始终相信自己，相信你会得到你想要的一切如果你拥有了这样的思想倾向，那么就像我刚才说到的，取得成功只是一个时间问题。\r\n这就引导我到了第3个成功因素：坚持不懈。\r\n\r\n\r\n### 成功秘诀3—决不放弃\r\n\r\n大多数（如果不是所有的话）成功人士都曾经遇到过你难以想象的很多的挫折和失败。\r\n你知不知道开创可口可乐的那个人曾经失败了17次，就为了给他的公司取个名字？但是这个公司现在拥有几十亿的资产。因为各种各样的商业想法，成功之前他失败了17次，但是他坚持相信自己，决不放弃。\r\n就拿专业运动员来说吧，你知道他们倾注了多少个小时、多少天、多少周、多少个月的训练，才得以用那样好的状态来展示自己吗？\r\n你要是想成功的话，就必须有持之以恒的精神。\r\n你必须把失败当作一次让你离成功更近的学习经验，而不是把它当作你无能的证据。\r\n你可能需要改变你所运用的取得成功的方法，但是你绝对不能放弃，知道你实现最终的成功目标。\r\n威尔史密斯对于取得成功和决不放弃有一伟大的观点。这是我最喜欢的他的语录之一：\r\n我和别人唯一的明显的不同之处就在于我不怕死在跑步机上。你可能比我有才，你也可能比我聪明，但是如果我们一起去跑步机上锻炼的话，结果只有两个：一个是你累的受不了会先下来，第二个结果就是我会死在跑步机上。就是那么简单。\r\n\r\n\r\n### 成功秘诀4—每天设想一下你的目标\r\n\r\n年龄越大，对于生活我就了解的越多，我更加认识到你可以吸引一些东西进入到你的生活中。\r\n是的，我就是在说人们所说的“吸引力法则”。我不会谈论各种各样的魔法或者神秘的骗人的方法，好让你仅仅通过心想就能得到你渴望的生活。坚决不会。\r\n我注意到，你心里的想法和你表达出来的想法以及你同别人相互交往的方式，这些会让你看到机遇，而这些机遇会引领你离你的目标和你的生活愿望更近。\r\n我读过也听说过一些成功人士的故事，他们取得成功之前成功的影像已经在他们脑海中存在多年。他们清楚的知道他们想要什么，也知道要如何取得成功，成功之前一切都只是时间和努力工作的问题。\r\n一些人甚至把他们的成功归功于每天深思熟虑，每天花费10到15分钟把精力放在设想他们的目标上他们会坐在一个安静的远离尘嚣的地方来想象他们的成功（不管是法拉利汽车，高楼大厦还是他们心仪的女人）。\r\n这不仅仅是我个人的一些理论，它在拿破仑�希尔的一本叫《思考与致富》的书中被证明过了的。这本书研究的是500个令人难以置信的成功人士他们的思维倾向，态度和方法以及他们是如何取得今天的成就的。\r\n每天设想一下你的未来是取得成功的另一剂良药。我建议你可以把你希望取得的目标的图片或者海报张贴出来。把这些图片贴在一个你早上醒来和晚上睡觉时就能看到的地方。\r\n\r\n\r\n### 成功秘诀5—量入为出\r\n\r\n要想使你的成功有些进展，通常你需要做出牺牲。\r\n我不是说要牺牲一只山羊或者一些其他疯狂的例行仪式。我说的是牺牲你当前想快速成功的渴望。\r\n我知道你现在就想要结果。你想要战利品、金钱、房子、伴侣、朋友，你想要所有的这些，并且是现在就想要。\r\n但是你现在不能拥有它，因为你必须先赚得它。\r\n如果你不去争取就想要得到成功，那你就不可能会成功。\r\n举个例子，比如说你想享受一下一个百万富翁的生活方式而你又不知道如何享受。你决定忽略迟来的报酬的原则（牺牲短暂的快乐来换取长期的愉悦）并且你从尽可能多的银行贷款。\r\n你买了你心驰神往的汽车，买了你梦寐以求的房子，也买了每一样你想要的东西。你正享受着一个百万富翁的生活，但是代价是你负债累累，你几乎不可能偿还的了，你也不可能挣得足够的钱，不可能真正成为百万富翁来享受你所拥有的一切。\r\n沃伦�巴菲特，世界上最富有的人之一。他量入为出，摸滚打爬，创造了财富。他花费的总是远远少于他拥有的或者他赚得的，这样他就可以存钱来让他的理念付诸行动。这（还有运气或者独一无二的才智）帮助他让他变的像今天那样成功。\r\n你要是没钱的话就不要花。事实上，花费的钱比你拥有的要少，然后你才能节省足够的钱来投资到你的商业理念中，而这些理念最终会让你真正获得你想要的成功。\r\n\r\n\r\n### 成功秘诀6—有建设性的批评\r\n\r\n我注意到另一个关于成功人士的事情是他们对自己很苛刻。\r\n他们时不时的分析总结他们的方法、长进、行为等等，看是否有提升的空间。成功的人对别人的观点总是很开明的（他们听取别人的意见，但是只有同意他们的观点了他们才会采纳）。\r\n尽管成功人士对他们自己以及他们的行为很挑剔，但是这些批评是有建设意义的批评，我添加这样的一个事实是很重要的。\r\n成功的人对自己和自己的行为要求很苛刻，以便能够有所提高。这就意味着任何一个批判都是以求提升空间为目的的。成功的人不会摧毁他们自己，也不会给自己灌输消极思想。\r\n要想成功，就必须对自己严格要求，对自己的行为和他人的行为严格要求，但是你必须做出有帮助的批评，不要消极，不要厌烦，也不要有破坏性，仅仅针对有所提高而要求苛刻。\r\n\r\n\r\n### 成功秘诀7-管理事务，而不是干活\r\n\r\n你肯定很少听说成功的人在生意场上干杂活。\r\n的确，大多数成功的人都是从各种各样的小事和体力劳动起家的，并且他们可以做好每一件事。但是成功的人知道成功的方法就是要在工作中处于领导地位，让别人来做那些琐细耗时的事情。\r\n如果你是工作的领导人，那么你的想法和创新性就是最有价值的东西。对你工作的整个环节要求严格，跳到你应该所处的位置，好让事情顺利进展。总之，要处在领导地位，监督凡事，让一切按照它应该的发展方式来发展，不要在小事上浪费你宝贵的时间和精力。\r\n比如说，我可以花费好几个小时来为我的博客建立联系，以便在搜索引擎上获得更好的排名（这样会让我的博客有更多的访客），再或者，我可以花钱请别人来为我做这些，而我就可以把时间花费在写高质量的文章上（这样会让人们订购我的文章，我也可以和他们建立某种联系，最终获得更多的利润）。\r\n如果可以的话，花费时间来做那些你擅长的，剩余的事情可以外购。\r\n我强烈推荐阅读拿破仑�希尔的《思考与致富》，以及鲍勃�普罗克特的《11个人被遗忘的吸引力法则》。\r\n这两者都会很大程度上帮助你，让你在生活中取得更多成功。\r\n","pubtime":{"$date":1353253543175},"title":"99%的人不知道或者不用的7大成功秘诀","visited":77063,"links":[["52288399917d2e280e000001",{"present":0.025641025641025640136,"title":"给正在实习和将要实习的大学生——实习经验分享"}],["51d3dd1b8ece70c438000009",{"present":0.025641025641025640136,"title":"人的一生，到底在追求什么？"}]],"html":"<p>作个大胆的猜想，1%的人是很成功的，而其他99%的人只能梦想着成功却得不到它，我认为这样说没什么不妥的。\n我注意到大多数人在人生中从未真正取得成就，对这一点我很无奈。尽管很多人都有成功的梦想和愿望，希望能过上真正快乐的生活，但是他们也只能那样了。只是梦想和愿望。\n从另一方面说，为什么一些人就能事事都成功呢？就好像他们有超能力。\n有没有可能去学习一下如何成功呢？是否可以采取一些行动、养成一些习惯来确保你事事都成功，或者说成功从某种角度来说是通过DNA来选取寥寥几个成功人士的。\n一些人好似什么都有：广泛的人脉、爱情、友情、金钱以及各方面的成功，那么是什么让这些人与众不同的呢？\n这个问题的讨论是很开放的，因为我只想表达一下我自己的观点，以及那些对我的成功产生影响的别人的观点。</p>\n<h3 id=\"-1-\">成功秘诀1--你的童年</h3>\n<p>我个人认为你的童年和你早些时候的经验在你的成功与否方面扮演着重要角色。\n仅仅是出生过程就可能决定你将来会成为什么样的人。虽然我想不出来任何具体的事例，但是我记得我读过一个成功人士的故事，而他有着坎坷的经历。他比预产期提前一个月出生，当时情况十分危险。医生说恐怕他活不了，但是他活下来了。他不断抵抗，最终活了下来。并且在他的余生，他与一切困难斗争，取得了成功。\n这是不是真的并不重要，我相信一切东西比如你的出生（尽管你什么也不记得了）会很大程度上影响你意志力的优点以及你生活里的性格特点。\n出生之后，你对外部所有的影响都是主观的，而父母在你的少年时期对你的影响是最大的。\n你是天生就拥有你想要的一切，还是说你必须去为它们打拼？有没有人说过你什么时候也成不了大器，还是说有人鼓励你要永远追随你的梦想并且相信自己？\n也许你会很纳闷为什么我会说起童年这个话题。尽管童年对你的成功与否起很大的作用，但是你没法控制它，你也改变不了它。\n我谈论童年的原因很简单。尽管你不能改变你的过去和童年，但是通过了解你是如何成长的，仔细考虑你的早期经验，你可能会做出一些必要的改变，从而让你更成功。\n举个例子来说，如果你总是被动的，并且你的所得也并非通过你自身的努力所得，那你之所以不成功，原因很简单，就是因为你工作不够努力，并且你得不到自己想要的东西时你就选择了放弃。\n你把握不了过去，但是从今往后，你行动起来，你会有改变未来的能力的。</p>\n<h3 id=\"-2-\">成功秘诀2--相信自己</h3>\n<p>我注意到成功的人对自己都有着坚定地信仰.\n对于别人来说，这种信仰看似是愚蠢的固执，但我认为，相信自己是取得成功的灵丹妙药。\n你必须全心全意的相信你会成功的。不管花费多长时间，也不管你尝试了多少次或者失败了多少次，要100%地相信你会成功，在你取得这理应得到的成功之前，这只是一个时间和坚持的问题。\n生活总是会抛给我们一些巨大的糟糕的挫折，这很容易让我们放弃对我们所坚持的一切的信仰。我觉得放弃对许多事情的信念可以，但是绝对不要放弃对自己的信仰。要始终相信自己，相信你会得到你想要的一切如果你拥有了这样的思想倾向，那么就像我刚才说到的，取得成功只是一个时间问题。\n这就引导我到了第3个成功因素：坚持不懈。</p>\n<h3 id=\"-3-\">成功秘诀3—决不放弃</h3>\n<p>大多数（如果不是所有的话）成功人士都曾经遇到过你难以想象的很多的挫折和失败。\n你知不知道开创可口可乐的那个人曾经失败了17次，就为了给他的公司取个名字？但是这个公司现在拥有几十亿的资产。因为各种各样的商业想法，成功之前他失败了17次，但是他坚持相信自己，决不放弃。\n就拿专业运动员来说吧，你知道他们倾注了多少个小时、多少天、多少周、多少个月的训练，才得以用那样好的状态来展示自己吗？\n你要是想成功的话，就必须有持之以恒的精神。\n你必须把失败当作一次让你离成功更近的学习经验，而不是把它当作你无能的证据。\n你可能需要改变你所运用的取得成功的方法，但是你绝对不能放弃，知道你实现最终的成功目标。\n威尔史密斯对于取得成功和决不放弃有一伟大的观点。这是我最喜欢的他的语录之一：\n我和别人唯一的明显的不同之处就在于我不怕死在跑步机上。你可能比我有才，你也可能比我聪明，但是如果我们一起去跑步机上锻炼的话，结果只有两个：一个是你累的受不了会先下来，第二个结果就是我会死在跑步机上。就是那么简单。</p>\n<h3 id=\"-4-\">成功秘诀4—每天设想一下你的目标</h3>\n<p>年龄越大，对于生活我就了解的越多，我更加认识到你可以吸引一些东西进入到你的生活中。\n是的，我就是在说人们所说的“吸引力法则”。我不会谈论各种各样的魔法或者神秘的骗人的方法，好让你仅仅通过心想就能得到你渴望的生活。坚决不会。\n我注意到，你心里的想法和你表达出来的想法以及你同别人相互交往的方式，这些会让你看到机遇，而这些机遇会引领你离你的目标和你的生活愿望更近。\n我读过也听说过一些成功人士的故事，他们取得成功之前成功的影像已经在他们脑海中存在多年。他们清楚的知道他们想要什么，也知道要如何取得成功，成功之前一切都只是时间和努力工作的问题。\n一些人甚至把他们的成功归功于每天深思熟虑，每天花费10到15分钟把精力放在设想他们的目标上他们会坐在一个安静的远离尘嚣的地方来想象他们的成功（不管是法拉利汽车，高楼大厦还是他们心仪的女人）。\n这不仅仅是我个人的一些理论，它在拿破仑�希尔的一本叫《思考与致富》的书中被证明过了的。这本书研究的是500个令人难以置信的成功人士他们的思维倾向，态度和方法以及他们是如何取得今天的成就的。\n每天设想一下你的未来是取得成功的另一剂良药。我建议你可以把你希望取得的目标的图片或者海报张贴出来。把这些图片贴在一个你早上醒来和晚上睡觉时就能看到的地方。</p>\n<h3 id=\"-5-\">成功秘诀5—量入为出</h3>\n<p>要想使你的成功有些进展，通常你需要做出牺牲。\n我不是说要牺牲一只山羊或者一些其他疯狂的例行仪式。我说的是牺牲你当前想快速成功的渴望。\n我知道你现在就想要结果。你想要战利品、金钱、房子、伴侣、朋友，你想要所有的这些，并且是现在就想要。\n但是你现在不能拥有它，因为你必须先赚得它。\n如果你不去争取就想要得到成功，那你就不可能会成功。\n举个例子，比如说你想享受一下一个百万富翁的生活方式而你又不知道如何享受。你决定忽略迟来的报酬的原则（牺牲短暂的快乐来换取长期的愉悦）并且你从尽可能多的银行贷款。\n你买了你心驰神往的汽车，买了你梦寐以求的房子，也买了每一样你想要的东西。你正享受着一个百万富翁的生活，但是代价是你负债累累，你几乎不可能偿还的了，你也不可能挣得足够的钱，不可能真正成为百万富翁来享受你所拥有的一切。\n沃伦�巴菲特，世界上最富有的人之一。他量入为出，摸滚打爬，创造了财富。他花费的总是远远少于他拥有的或者他赚得的，这样他就可以存钱来让他的理念付诸行动。这（还有运气或者独一无二的才智）帮助他让他变的像今天那样成功。\n你要是没钱的话就不要花。事实上，花费的钱比你拥有的要少，然后你才能节省足够的钱来投资到你的商业理念中，而这些理念最终会让你真正获得你想要的成功。</p>\n<h3 id=\"-6-\">成功秘诀6—有建设性的批评</h3>\n<p>我注意到另一个关于成功人士的事情是他们对自己很苛刻。\n他们时不时的分析总结他们的方法、长进、行为等等，看是否有提升的空间。成功的人对别人的观点总是很开明的（他们听取别人的意见，但是只有同意他们的观点了他们才会采纳）。\n尽管成功人士对他们自己以及他们的行为很挑剔，但是这些批评是有建设意义的批评，我添加这样的一个事实是很重要的。\n成功的人对自己和自己的行为要求很苛刻，以便能够有所提高。这就意味着任何一个批判都是以求提升空间为目的的。成功的人不会摧毁他们自己，也不会给自己灌输消极思想。\n要想成功，就必须对自己严格要求，对自己的行为和他人的行为严格要求，但是你必须做出有帮助的批评，不要消极，不要厌烦，也不要有破坏性，仅仅针对有所提高而要求苛刻。</p>\n<h3 id=\"-7-\">成功秘诀7-管理事务，而不是干活</h3>\n<p>你肯定很少听说成功的人在生意场上干杂活。\n的确，大多数成功的人都是从各种各样的小事和体力劳动起家的，并且他们可以做好每一件事。但是成功的人知道成功的方法就是要在工作中处于领导地位，让别人来做那些琐细耗时的事情。\n如果你是工作的领导人，那么你的想法和创新性就是最有价值的东西。对你工作的整个环节要求严格，跳到你应该所处的位置，好让事情顺利进展。总之，要处在领导地位，监督凡事，让一切按照它应该的发展方式来发展，不要在小事上浪费你宝贵的时间和精力。\n比如说，我可以花费好几个小时来为我的博客建立联系，以便在搜索引擎上获得更好的排名（这样会让我的博客有更多的访客），再或者，我可以花钱请别人来为我做这些，而我就可以把时间花费在写高质量的文章上（这样会让人们订购我的文章，我也可以和他们建立某种联系，最终获得更多的利润）。\n如果可以的话，花费时间来做那些你擅长的，剩余的事情可以外购。\n我强烈推荐阅读拿破仑�希尔的《思考与致富》，以及鲍勃�普罗克特的《11个人被遗忘的吸引力法则》。\n这两者都会很大程度上帮助你，让你在生活中取得更多成功。</p>\n"}
{"_id":{"$oid":"51d3dcfc8ece70c438000007"},"classid":"100","comment":1,"content":"一、关于textarea文本域以及高度自适应\r\ntextarea标签为表单元素，一般用在多行文字的输入。在web应用上常见的是评论输入框，微博信息输入框等。例如企鹅微博的输入框：\r\n   ![div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog](http://img.ph.126.net/ilct0NNd-CTGRdGcY34cPQ==/2376211753391835323.jpg)\r\n作为多行文本域功能来讲，textarea满足了我们大部分的需求。然而，textarea有一个不足就是不能像普通div标签一样高度可以跟随内容自适应。textarea总是很自信地显摆它的滚动条，高度固执地岿然不动。所以，有时候，为了增加交互体验想让文本域高度自适应的时候，就会遇到麻烦。并不是不能实现，例如Google的Buzz的输入框就是高度自适应里面的内容的，如下截图：\r\n   ![div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog](http://img.ph.126.net/RYunkHY0bLlWxCSeUzF7yg==/2376211753391835326.jpg)\r\n   ![div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog](http://img.ph.126.net/N9dzcD2-U4jVM3gaBsji1w==/2376211753391835328.jpg)\r\n不说远的，我个人网站的提问与交流页面中的回答输入框（需登录）：\r\n   ![div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog](http://img.ph.126.net/3gjHIqZXXIQF34IGJZVofQ==/2376211753391835330.jpg)\r\n当输入一些文字后，文本域的高度自动随内容多少撑高了：\r\n   ![div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog](http://img.ph.126.net/7AYTEaO11KOTOo4TNm-PaA==/2376211753391835332.jpg)\r\n然而，这些文本域的高度自适应都是通过JavaScript脚本实现的。拿我个人站点上的高度自适应文本框来说，要克隆一个隐藏的 textarea，通过实时的文字赋值，检测是否产生滚动条来确定显示文本域的高度是否动态增加。对于JavaScript不熟悉的人来讲，这种方法的实现比想办法跟校花约会还麻烦。\r\n然而，实际上，如果你要求不是很高，是个非常简便，且老少皆宜的实现方法的。这种方法就是使用普通的div标签模拟textarea文本域，同时又利用了div标签的高度自适应性。于是，textarea文本域的高度自适应效果就可以轻松实现。\r\n二、div模拟textarea文本域及高度自适应\r\n我之前翻译过一篇文章，名为“你必须知道的28个HTML5特征、窍门和技术”，其中在“六、内容可编辑”部分介绍了一个标签属性，为contenteditable，顾名思意，就是允许用户编辑元素内容包含的任意文本，包括子元素。\r\n应用了此属性后，普通的div标签也会像文本域一样可以获得焦点，同时有一个光标在那里闪啊闪，闪啊闪，你越看她她越闪。web QQ 2.0 的聊天对话框的输入框就是应用了此属性。\r\n   ![div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog](http://img.ph.126.net/3SqsiGkr6zEyBnoCn7tpMw==/2376211753391835334.jpg)\r\n//zxx:企鹅的圣诞主题界面很nice，视觉效果很赞，下雪的效果也很有爱，连cup也为之奔腾。\r\n使用很简单，一个普通的block元素上加个contenteditable=\"true\"就ok了，如下：\r\ntrue外面的引号甚至去掉都没关系。\r\ncontenteditable属性虽是HTML5里面的内容，但是IE似乎老早就支持此标签属性了。所以，兼容性方面还是不用太担心的。\r\nok，最麻烦的模拟textarea的可编辑效果已经解决了，现在想要使用div实现高度自适应那就像是给花花草草松松土一样容易的。使用min- height属性基本上就一步到位了，考虑到IE6浏览器对min/max家族不屑一顾，结合其内部元素溢出会撑开父标签高宽的特性，IE6浏览器直接定高就可以了。于是，假设我们要实现默认200像素高度，高度可随内容自适应的效果，直接下面两个样式就可以了：\r\n```css\r\n{ min-height: 200px; _height: 200px; }\r\n```\r\n于是，把说到现在的内容结合一起，就可以使用div模拟textarea文本域轻松实现高度自适应了。\r\n如下测试代码——\r\n       CSS代码：\r\n```css\r\n.test_box { width: 400px; min-height: 120px; max-height: 300px; _height: 120px; margin-left: auto; margin-right: auto; padding: 3px; outline: 0; border: 1px solid #a0b3d6; font-size: 12px; word-wrap: break-word; overflow-x: hidden; overflow-y: auto; _overflow-y: visible;}\r\n```\r\nHTML代码：\r\n\r\n结果如下图（全部截自IE6浏览器）：\r\n   ![div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog](http://img.ph.126.net/iUQi9BgVX-uUSZvu-KxWZQ==/2376211753391835336.jpg)\r\n然后从新浪博客首页随便找篇文章，拷点文字复制进去，结果如下图：\r\n   ![div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog](http://img.ph.126.net/ax8X3yJ0dMseptDGUmgSYg==/2376211753391835337.jpg)\r\n可以看到可编辑标签高度自带撑开了。完全的CSS，没有杂碎的js代码。我们设置可以设定一个最大高度(max-height)，让其超出的时候出现滚动条，正如下面demo页面所做的一样。\r\n您可以狠狠地点击这里：div模拟textarea以实现高度自适应demo\r\n   ![div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog](http://img.ph.126.net/kjTykMnRjWLV57FjlK1n5g==/2376211753391835338.jpg)\r\n然而，事情并不会如此一帆风顺，还有不少注意事项值得一提。\r\n三、一些注意与说明\r\n1、 现代浏览器如Firefox在可编辑模式下的div获取焦点的时候会有虚框，而实际上textarea是没有虚框显示的，此迹象会暴露出div是个冒牌货，所以，需要添加下面的样式：\r\noutline:0;\r\n2、 Firefox浏览器下可编辑模式的div如果内部元素是空空的，那么其在获取焦点是时候，光标不可见或是与外部div齐高，这也是会暴露出自己是 textarea冒牌货的，所以，默认情况下，我们可以在此div中增加一个孤单的\r\n换行标签。但是，IE8下，如果有个默认的br标签，光标位置可能会在第二行闪来闪去，所以，IE8下可编辑div里面默认是不能有br标签的，这个嘛，您自己想办法清掉吧。\r\n3、 IE浏览器下（IE6~8），输入文字回车的时候，div内部是会自动产生p标签包含每行元素的，而其他浏览器貌似是产生br标签（这里尚未全部测试，如有不准，欢迎指正）。由于默认的p标签是有1em大小的上下margin值的，为了效果统一，我们可以设置诸如下面的样式清除p标签的margin值：\r\n.test_box p{ margin: 0; }\r\n4、可编辑模式的div输入的内容都会是很正宗的HTML代码，如果作为内容提交的话需要进行HTML字符过滤。还有，如果您是从其他页面上拷贝一段内容过来，然后粘贴到可编辑模式下的div中，会连HTML也完整的复制过来的（不同于textarea），所以，这里也有必要进行HTML字符过滤（例如web QQ）。\r\n   ![div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog](http://img.ph.126.net/FtifpuxUEWhT7zQmiPkQhA==/2376211753391835339.jpg)\r\n5、 IE6浏览器不支持max-height属性，所以，只用CSS是无法实现超过一定高度出现滚动条的效果，需要js配合实现。\r\n6、 可编辑模式的div标签与textarea一样，是支持focus, blur事件的。自然也支持focus伪类，demo页面中Firefox等现代浏览器获取焦点时的外发光就是使用的:focus。\r\n","pubtime":{"$date":1372839164220},"title":"div模拟textarea文本域轻松实现高度自适应","visited":118597,"links":[["527100b5ce7d63c80c000001",{"present":0.081081081081081085582,"title":"跨域iframe高度自适应实现方案"}],["528611f363c705fc73000001",{"present":0.052631578947368418131,"title":"javascript 文字大小自动适应文本框 （文字大小自动调整）"}],["5242d5fc9ab354383d000001",{"present":0.052631578947368418131,"title":"CSS3 实现iOS7毛玻璃模糊效果 (iOS7 live blur)"}],["51d3dd2e8ece70c43800000a",{"present":0.025641025641025640136,"title":"CSS的优先级特性 "}],["51d3de8e8ece70c43800000f",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（二） 用HTML5构建应用程序"}]],"html":"<p>一、关于textarea文本域以及高度自适应\ntextarea标签为表单元素，一般用在多行文字的输入。在web应用上常见的是评论输入框，微博信息输入框等。例如企鹅微博的输入框：\n   <img src=\"http://img.ph.126.net/ilct0NNd-CTGRdGcY34cPQ==/2376211753391835323.jpg\" alt=\"div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog\">\n作为多行文本域功能来讲，textarea满足了我们大部分的需求。然而，textarea有一个不足就是不能像普通div标签一样高度可以跟随内容自适应。textarea总是很自信地显摆它的滚动条，高度固执地岿然不动。所以，有时候，为了增加交互体验想让文本域高度自适应的时候，就会遇到麻烦。并不是不能实现，例如Google的Buzz的输入框就是高度自适应里面的内容的，如下截图：\n   <img src=\"http://img.ph.126.net/RYunkHY0bLlWxCSeUzF7yg==/2376211753391835326.jpg\" alt=\"div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog\">\n   <img src=\"http://img.ph.126.net/N9dzcD2-U4jVM3gaBsji1w==/2376211753391835328.jpg\" alt=\"div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog\">\n不说远的，我个人网站的提问与交流页面中的回答输入框（需登录）：\n   <img src=\"http://img.ph.126.net/3gjHIqZXXIQF34IGJZVofQ==/2376211753391835330.jpg\" alt=\"div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog\">\n当输入一些文字后，文本域的高度自动随内容多少撑高了：\n   <img src=\"http://img.ph.126.net/7AYTEaO11KOTOo4TNm-PaA==/2376211753391835332.jpg\" alt=\"div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog\">\n然而，这些文本域的高度自适应都是通过JavaScript脚本实现的。拿我个人站点上的高度自适应文本框来说，要克隆一个隐藏的 textarea，通过实时的文字赋值，检测是否产生滚动条来确定显示文本域的高度是否动态增加。对于JavaScript不熟悉的人来讲，这种方法的实现比想办法跟校花约会还麻烦。\n然而，实际上，如果你要求不是很高，是个非常简便，且老少皆宜的实现方法的。这种方法就是使用普通的div标签模拟textarea文本域，同时又利用了div标签的高度自适应性。于是，textarea文本域的高度自适应效果就可以轻松实现。\n二、div模拟textarea文本域及高度自适应\n我之前翻译过一篇文章，名为“你必须知道的28个HTML5特征、窍门和技术”，其中在“六、内容可编辑”部分介绍了一个标签属性，为contenteditable，顾名思意，就是允许用户编辑元素内容包含的任意文本，包括子元素。\n应用了此属性后，普通的div标签也会像文本域一样可以获得焦点，同时有一个光标在那里闪啊闪，闪啊闪，你越看她她越闪。web QQ 2.0 的聊天对话框的输入框就是应用了此属性。\n   <img src=\"http://img.ph.126.net/3SqsiGkr6zEyBnoCn7tpMw==/2376211753391835334.jpg\" alt=\"div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog\">\n//zxx:企鹅的圣诞主题界面很nice，视觉效果很赞，下雪的效果也很有爱，连cup也为之奔腾。\n使用很简单，一个普通的block元素上加个contenteditable=&quot;true&quot;就ok了，如下：\ntrue外面的引号甚至去掉都没关系。\ncontenteditable属性虽是HTML5里面的内容，但是IE似乎老早就支持此标签属性了。所以，兼容性方面还是不用太担心的。\nok，最麻烦的模拟textarea的可编辑效果已经解决了，现在想要使用div实现高度自适应那就像是给花花草草松松土一样容易的。使用min- height属性基本上就一步到位了，考虑到IE6浏览器对min/max家族不屑一顾，结合其内部元素溢出会撑开父标签高宽的特性，IE6浏览器直接定高就可以了。于是，假设我们要实现默认200像素高度，高度可随内容自适应的效果，直接下面两个样式就可以了：</p>\n<pre><code class=\"lang-css\">{ min-height: 200px; _height: 200px; }\n</code></pre>\n<p>于是，把说到现在的内容结合一起，就可以使用div模拟textarea文本域轻松实现高度自适应了。\n如下测试代码——\n       CSS代码：</p>\n<pre><code class=\"lang-css\">.test_box { width: 400px; min-height: 120px; max-height: 300px; _height: 120px; margin-left: auto; margin-right: auto; padding: 3px; outline: 0; border: 1px solid #a0b3d6; font-size: 12px; word-wrap: break-word; overflow-x: hidden; overflow-y: auto; _overflow-y: visible;}\n</code></pre>\n<p>HTML代码：</p>\n<p>结果如下图（全部截自IE6浏览器）：\n   <img src=\"http://img.ph.126.net/iUQi9BgVX-uUSZvu-KxWZQ==/2376211753391835336.jpg\" alt=\"div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog\">\n然后从新浪博客首页随便找篇文章，拷点文字复制进去，结果如下图：\n   <img src=\"http://img.ph.126.net/ax8X3yJ0dMseptDGUmgSYg==/2376211753391835337.jpg\" alt=\"div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog\">\n可以看到可编辑标签高度自带撑开了。完全的CSS，没有杂碎的js代码。我们设置可以设定一个最大高度(max-height)，让其超出的时候出现滚动条，正如下面demo页面所做的一样。\n您可以狠狠地点击这里：div模拟textarea以实现高度自适应demo\n   <img src=\"http://img.ph.126.net/kjTykMnRjWLV57FjlK1n5g==/2376211753391835338.jpg\" alt=\"div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog\">\n然而，事情并不会如此一帆风顺，还有不少注意事项值得一提。\n三、一些注意与说明\n1、 现代浏览器如Firefox在可编辑模式下的div获取焦点的时候会有虚框，而实际上textarea是没有虚框显示的，此迹象会暴露出div是个冒牌货，所以，需要添加下面的样式：\noutline:0;\n2、 Firefox浏览器下可编辑模式的div如果内部元素是空空的，那么其在获取焦点是时候，光标不可见或是与外部div齐高，这也是会暴露出自己是 textarea冒牌货的，所以，默认情况下，我们可以在此div中增加一个孤单的\n换行标签。但是，IE8下，如果有个默认的br标签，光标位置可能会在第二行闪来闪去，所以，IE8下可编辑div里面默认是不能有br标签的，这个嘛，您自己想办法清掉吧。\n3、 IE浏览器下（IE6~8），输入文字回车的时候，div内部是会自动产生p标签包含每行元素的，而其他浏览器貌似是产生br标签（这里尚未全部测试，如有不准，欢迎指正）。由于默认的p标签是有1em大小的上下margin值的，为了效果统一，我们可以设置诸如下面的样式清除p标签的margin值：\n.test_box p{ margin: 0; }\n4、可编辑模式的div输入的内容都会是很正宗的HTML代码，如果作为内容提交的话需要进行HTML字符过滤。还有，如果您是从其他页面上拷贝一段内容过来，然后粘贴到可编辑模式下的div中，会连HTML也完整的复制过来的（不同于textarea），所以，这里也有必要进行HTML字符过滤（例如web QQ）。\n   <img src=\"http://img.ph.126.net/FtifpuxUEWhT7zQmiPkQhA==/2376211753391835339.jpg\" alt=\"div模拟textarea文本域轻松实现高度自适应 - 朱文龙 （Z.Mofei） - 朱文龙(Z.Mofei)的blog\">\n5、 IE6浏览器不支持max-height属性，所以，只用CSS是无法实现超过一定高度出现滚动条的效果，需要js配合实现。\n6、 可编辑模式的div标签与textarea一样，是支持focus, blur事件的。自然也支持focus伪类，demo页面中Firefox等现代浏览器获取焦点时的外发光就是使用的:focus。</p>\n"}
{"_id":{"$oid":"547f1ccfa02135883f000003"},"title":"webGL 学习手记 | webGL 教程 （二）","classid":"100","content":"上一篇的文章 [《webGL 学习手记 | webGL 教程 （一）》](http://www.zhuwenlong.com/blog/54687208a02135883f000002) 说到如何获取webGL的上下文 ， 这是webGL的第一步，就好比上画家拿到了绘画的纸。接下来，在拿到webGL的上下文之后，我们就可以愉快的和webGL玩耍了。\r\n\r\n* [DEMO预览](http://zmofei.github.io/yes-webgl/demo/drawpoint.html) \r\n* [http://zmofei.github.io/yes-webgl/demo/drawpoint.html](http://zmofei.github.io/yes-webgl/demo/drawpoint.html)\r\n* [DEMO源码](https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoint.html)\r\n* [https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoint.html](https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoint.html)\r\n\r\n## 渲染流程\r\n\r\n![http://static.zhuwenlong.com/upload/article/webgl2-1.png](http://static.zhuwenlong.com/upload/article/webgl2-1.png)\r\n\r\n> 图片说明，本来自己画了一张漂漂亮亮的图，结果改版的时候貌似弄丢了，翻遍了全网都没有找到，那些偷文章的也不好好偷，图片都没有帮我缓存，只能网上找一张了，虽然心中一万头羊驼奔过，但是还是感谢图片的作者。\r\n\r\n\t简单描述一下，绘制webGL你需要Program,Shader两样东西。\r\n\t1. 通过 createProgram() 创建了 program 对象\r\n\t2. 通过 createShader() 创建 sharder 对象，\r\n       并通过 shaderSource() 绑定原始的 sharder 程序，这个后续有介绍，\r\n       绑定完成之后执行 complieShader() 完成 sharder 对象的创建\r\n\t3. 通过 attachShader 将 shader 绑定到 project 上\r\n\t4. 链接、使用、绘制\r\n\r\n\r\n## 着色器(shader)\r\n\r\n代码中我们看到了如下两段着色器\r\n\r\n```\r\nvar VSHADER_SOURCE =\r\n    'attribute vec4 a_Position;\\n' +\r\n    'void main() {\\n' +\r\n    '  gl_Position = a_Position;\\n' +\r\n    '  gl_PointSize = 10.0;\\n' +\r\n    '}\\n';\r\nvar FSHADER_SOURCE =\r\n    'void main() {\\n' +\r\n    '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n' + \r\n    '}\\n';\r\n```\r\n\r\nwebGL，主要通过 vertex shader （顶点着色器），fragment shader （片元着色器）来进行渲染。\r\n\r\n这里我们看到，着色器中的代码都是JavaScript中的string类型的 GLSL（openGL shader language）语言。\r\n\r\nGLSL类似于 C 语言，和JavaScript相比起来，要尤其注意变量类型，如果你声明了一个 float 然后传给了一个 int（比如10）就会出错，正确的应该是10.0，这点对于JSer来说还是有点不一样的。\r\n\r\n通常情况下，我们会去声明一些变量：\r\n\r\n```\r\nattribute vec4 a_Position;\r\n```\r\n\r\n声明变量通常由上以下格式组成\r\n\r\n`存储限定符`(attribute) `类型`(vec4) `变量名`(a_Position)\r\n\r\n然后声明“入口函数”：\r\n\r\n```\r\nvoid main(){\r\n\t//code\r\n}\r\n```\r\n\r\n代码再执行的时候会去执行main函数中的代码，这点和C类语言很像。\r\n\r\n\r\n### vertex shader 顶点着色器\r\n\r\n顾名思义，顶点着色器主要负责定义图形的顶点坐标，大小等位置相关的信息。\r\n\r\n如上代码 `VSHADER_SOURCE` 片段所示，我们定义了一个存储限定符号 `attribute` ，类型为 `vec4`(4个长度的矢量)的变量 `a_Position`。\r\n\r\n在`main`函数中，我们将位置信息赋给`gl_Position`，将顶点大小赋值给`gl_PointSize`.\r\n\r\n### fragment shader 片元着色器\r\n\r\n片元着色器主要是定义颜色等属性。\r\n\r\n这里我们简单的通过 `gl_FragColor` 告诉着色器点的颜色为 `vec4(1.0, 0.0, 0.0, 1.0)` \r\n\r\n## 渲染开始\r\n\r\n前面我们定义了两个最重要的着色器，接下来就是简单的赋值，渲染了，更多的是流程。\r\n\r\n1. 首先我们需要创建一个GL的项目\r\n\r\n\t```\r\n\tvar program = webgl.createProgram();\r\n\t//这个program将会在后续绑定顶点、片元时候用到。\r\n\t```\r\n\t\r\n2. 创建shader对象并绑定到（1）中的 `program` 上\r\n\r\n\t这里我们以定点着色器为例来说明，片元着色器的过程和定点着色器一致。\r\n\r\n\t2.1\t创建 shader 对象\r\n\t\t\r\n\t```\r\n\tvar VShader = webgl.createShader(webgl.VERTEX_SHADER);\r\n\t//createShader方法\r\n\t//webgl.VERTEX_SHADER告诉webgl绑定的是顶点着色器\r\n\t//同理片元着色器应该是webgl.FRAGMENT_SHADER\r\n\t```\r\n\t\t\r\n\t2.2 绑定 shader 脚本\r\n\t\t\r\n\t```\r\n\twebgl.shaderSource(VShader, VSHADER_SOURCE);\r\n\t//shaderSource方法\r\n\t//VShader是上一步创建的shader对象\r\n\t//VSHADER_SOURCE 是我们之前准备的脚本\r\n\t```\r\n\t\t\r\n\t2.3\t完成 sharder 对象的脚本绑定\r\n\t\r\n\t```\r\n\twebgl.compileShader(VShader);\r\n\t//compileShader 完成脚本的绑定\r\n\t```\r\n\t\t\r\n\t2.4 将 sharder 对象绑定到 program 上\r\n\t\r\n\t```\r\n\twebgl.attachShader(program, VShader);\r\n\t//program 是我们第一步创建的对象\r\n\t//VShader 是我们2.1时候创建的sharder对象\r\n\t```\r\n\t\r\n3. 连接 program 和 webgl\r\n\r\n\t```\r\n\twebgl.linkProgram(program);\r\n\t```\r\n\t\r\n4. 使用 program\r\n\r\n\t```\r\n\t webgl.useProgram(program);\r\n\t```\r\n\r\n5. 绘制\r\n\r\n\t```\r\n\twebgl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n    webgl.clear(webgl.COLOR_BUFFER_BIT);\r\n    //上面两步是为了清除画布，并且将画布重置成我们需要的颜色。\r\n\twebgl.drawArrays(webgl.POINTS, 0, 1);\r\n\t//drawArrays方法有多重绘制方法，这里我们需要的是点所以使用了webgl.POINTS\r\n\t```\r\n\r\n\r\n上述步骤第一眼看起来很麻烦，总结一下：\r\n\r\n`创建program` -> `创建shader` -> `绑定shader到program` -> `绘制`\r\n\r\nPS：还是解释一下，`drawArrays`方法吧，drawArrays第一个参数决定了如何“连接”这些点，偷来一张图，大家看了自然会明白。（BTW：网上找的图，不知道是哪家的，如果作者看到了，麻烦通知我加一下链接）\r\n\r\n` * 请注意点的顺序`\r\n\r\n![drawArrays](http://static.zhuwenlong.com/upload/article/webgl2-2.jpg?)\r\n\r\n至于第二个、第三个参数就很好理解了，分别是，起始点（从0开始），和点的个数，比如一个三角形可以写成0，3\r\n\r\n##总结\r\n\r\n好了，至此我们已经完成了一个DEMO的开发，WebGL前期学习成本还是比较高的，前面的基础知识搞定之后，后面的学习将会很快。后续有新的进展会及时和大家沟通的。\r\n\r\n---\r\n\r\n#### 快速链接\r\n\r\n* [《webGL 学习手记 | webGL 教程 （一）》](http://www.zhuwenlong.com/blog/54687208a02135883f000002)\r\n","visited":1824,"comment":0,"pubtime":{"$date":1417616591887},"links":[["54687208a02135883f000002",{"present":0.17647058823529412908,"title":"webGL 学习手记 | webGL 教程 （一）"}],["54817f6ea02135883f000004",{"present":0.14285714285714284921,"title":"使用缓冲区以及GLSL变量 - webGL 学习手记 | webGL 教程 （三）"}],["51d3dc6c8ece70c438000006",{"present":0.025641025641025640136,"title":"jQuery.proxy(function,obj)"}],["53a9475819a5a13617000001",{"present":0.025641025641025640136,"title":"Javascript获取服务器系统时间"}],["51d3dfda8ece70c438000012",{"present":0.025641025641025640136,"title":"jQuery新的事件绑定机制on()"}]],"html":"<p>上一篇的文章 <a href=\"http://www.zhuwenlong.com/blog/54687208a02135883f000002\">《webGL 学习手记 | webGL 教程 （一）》</a> 说到如何获取webGL的上下文 ， 这是webGL的第一步，就好比上画家拿到了绘画的纸。接下来，在拿到webGL的上下文之后，我们就可以愉快的和webGL玩耍了。</p>\n<ul>\n<li><a href=\"http://zmofei.github.io/yes-webgl/demo/drawpoint.html\">DEMO预览</a> </li>\n<li><a href=\"http://zmofei.github.io/yes-webgl/demo/drawpoint.html\">http://zmofei.github.io/yes-webgl/demo/drawpoint.html</a></li>\n<li><a href=\"https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoint.html\">DEMO源码</a></li>\n<li><a href=\"https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoint.html\">https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoint.html</a></li>\n</ul>\n<h2 id=\"-\">渲染流程</h2>\n<p><img src=\"http://static.zhuwenlong.com/upload/article/webgl2-1.png\" alt=\"http://static.zhuwenlong.com/upload/article/webgl2-1.png\"></p>\n<blockquote>\n<p>图片说明，本来自己画了一张漂漂亮亮的图，结果改版的时候貌似弄丢了，翻遍了全网都没有找到，那些偷文章的也不好好偷，图片都没有帮我缓存，只能网上找一张了，虽然心中一万头羊驼奔过，但是还是感谢图片的作者。</p>\n</blockquote>\n<pre><code>简单描述一下，绘制webGL你需要Program,Shader两样东西。\n1. 通过 createProgram() 创建了 program 对象\n2. 通过 createShader() 创建 sharder 对象，\n   并通过 shaderSource() 绑定原始的 sharder 程序，这个后续有介绍，\n   绑定完成之后执行 complieShader() 完成 sharder 对象的创建\n3. 通过 attachShader 将 shader 绑定到 project 上\n4. 链接、使用、绘制\n</code></pre><h2 id=\"-shader-\">着色器(shader)</h2>\n<p>代码中我们看到了如下两段着色器</p>\n<pre><code>var VSHADER_SOURCE =\n    &#39;attribute vec4 a_Position;\\n&#39; +\n    &#39;void main() {\\n&#39; +\n    &#39;  gl_Position = a_Position;\\n&#39; +\n    &#39;  gl_PointSize = 10.0;\\n&#39; +\n    &#39;}\\n&#39;;\nvar FSHADER_SOURCE =\n    &#39;void main() {\\n&#39; +\n    &#39;  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n&#39; + \n    &#39;}\\n&#39;;\n</code></pre><p>webGL，主要通过 vertex shader （顶点着色器），fragment shader （片元着色器）来进行渲染。</p>\n<p>这里我们看到，着色器中的代码都是JavaScript中的string类型的 GLSL（openGL shader language）语言。</p>\n<p>GLSL类似于 C 语言，和JavaScript相比起来，要尤其注意变量类型，如果你声明了一个 float 然后传给了一个 int（比如10）就会出错，正确的应该是10.0，这点对于JSer来说还是有点不一样的。</p>\n<p>通常情况下，我们会去声明一些变量：</p>\n<pre><code>attribute vec4 a_Position;\n</code></pre><p>声明变量通常由上以下格式组成</p>\n<p><code>存储限定符</code>(attribute) <code>类型</code>(vec4) <code>变量名</code>(a_Position)</p>\n<p>然后声明“入口函数”：</p>\n<pre><code>void main(){\n    //code\n}\n</code></pre><p>代码再执行的时候会去执行main函数中的代码，这点和C类语言很像。</p>\n<h3 id=\"vertex-shader-\">vertex shader 顶点着色器</h3>\n<p>顾名思义，顶点着色器主要负责定义图形的顶点坐标，大小等位置相关的信息。</p>\n<p>如上代码 <code>VSHADER_SOURCE</code> 片段所示，我们定义了一个存储限定符号 <code>attribute</code> ，类型为 <code>vec4</code>(4个长度的矢量)的变量 <code>a_Position</code>。</p>\n<p>在<code>main</code>函数中，我们将位置信息赋给<code>gl_Position</code>，将顶点大小赋值给<code>gl_PointSize</code>.</p>\n<h3 id=\"fragment-shader-\">fragment shader 片元着色器</h3>\n<p>片元着色器主要是定义颜色等属性。</p>\n<p>这里我们简单的通过 <code>gl_FragColor</code> 告诉着色器点的颜色为 <code>vec4(1.0, 0.0, 0.0, 1.0)</code> </p>\n<h2 id=\"-\">渲染开始</h2>\n<p>前面我们定义了两个最重要的着色器，接下来就是简单的赋值，渲染了，更多的是流程。</p>\n<ol>\n<li><p>首先我们需要创建一个GL的项目</p>\n<pre><code> var program = webgl.createProgram();\n //这个program将会在后续绑定顶点、片元时候用到。\n</code></pre></li>\n<li><p>创建shader对象并绑定到（1）中的 <code>program</code> 上</p>\n<p> 这里我们以定点着色器为例来说明，片元着色器的过程和定点着色器一致。</p>\n<p> 2.1    创建 shader 对象</p>\n<pre><code> var VShader = webgl.createShader(webgl.VERTEX_SHADER);\n //createShader方法\n //webgl.VERTEX_SHADER告诉webgl绑定的是顶点着色器\n //同理片元着色器应该是webgl.FRAGMENT_SHADER\n</code></pre><p> 2.2 绑定 shader 脚本</p>\n<pre><code> webgl.shaderSource(VShader, VSHADER_SOURCE);\n //shaderSource方法\n //VShader是上一步创建的shader对象\n //VSHADER_SOURCE 是我们之前准备的脚本\n</code></pre><p> 2.3    完成 sharder 对象的脚本绑定</p>\n<pre><code> webgl.compileShader(VShader);\n //compileShader 完成脚本的绑定\n</code></pre><p> 2.4 将 sharder 对象绑定到 program 上</p>\n<pre><code> webgl.attachShader(program, VShader);\n //program 是我们第一步创建的对象\n //VShader 是我们2.1时候创建的sharder对象\n</code></pre></li>\n<li><p>连接 program 和 webgl</p>\n<pre><code> webgl.linkProgram(program);\n</code></pre></li>\n<li><p>使用 program</p>\n<pre><code>  webgl.useProgram(program);\n</code></pre></li>\n<li><p>绘制</p>\n<pre><code> webgl.clearColor(0.0, 0.0, 0.0, 1.0);\n webgl.clear(webgl.COLOR_BUFFER_BIT);\n //上面两步是为了清除画布，并且将画布重置成我们需要的颜色。\n webgl.drawArrays(webgl.POINTS, 0, 1);\n //drawArrays方法有多重绘制方法，这里我们需要的是点所以使用了webgl.POINTS\n</code></pre></li>\n</ol>\n<p>上述步骤第一眼看起来很麻烦，总结一下：</p>\n<p><code>创建program</code> -&gt; <code>创建shader</code> -&gt; <code>绑定shader到program</code> -&gt; <code>绘制</code></p>\n<p>PS：还是解释一下，<code>drawArrays</code>方法吧，drawArrays第一个参数决定了如何“连接”这些点，偷来一张图，大家看了自然会明白。（BTW：网上找的图，不知道是哪家的，如果作者看到了，麻烦通知我加一下链接）</p>\n<p><code>* 请注意点的顺序</code></p>\n<p><img src=\"http://static.zhuwenlong.com/upload/article/webgl2-2.jpg?\" alt=\"drawArrays\"></p>\n<p>至于第二个、第三个参数就很好理解了，分别是，起始点（从0开始），和点的个数，比如一个三角形可以写成0，3</p>\n<p>##总结</p>\n<p>好了，至此我们已经完成了一个DEMO的开发，WebGL前期学习成本还是比较高的，前面的基础知识搞定之后，后面的学习将会很快。后续有新的进展会及时和大家沟通的。</p>\n<hr>\n<h4 id=\"-\">快速链接</h4>\n<ul>\n<li><a href=\"http://www.zhuwenlong.com/blog/54687208a02135883f000002\">《webGL 学习手记 | webGL 教程 （一）》</a></li>\n</ul>\n","like":1}
{"_id":{"$oid":"5534ec4efd9753d106000002"},"title":"JavaScript 对象转换,toString,valueOf","classid":"100","content":"开始这个话题之前，我们先看一下下面的几个例子：\r\n\r\n```\r\nparseInt(0.0000004)  // 4\r\n![]==[] //true\r\n['x','y'] == 'x,y' //true\r\nalert({name:'mofei'})  //\"[object Object]\"\r\n```\r\n\r\n结果有时候会让我大吃一惊，这是为什么呢？今天就和大家讨论一下JavaScript的对象转换。\r\n\r\n## 基础类型\r\n\r\n先让我们了解一下JavasScript转换的“原始类型(primitive value)”：\r\n\r\n> Number\r\n> \r\n> String\r\n> \r\n> Boolean\r\n\r\n在JavaScript进行对比或者各种运算的时候会把对象转换成这些类型，从而进行后续的操作，下面逐一说明：\r\n\r\n\r\n## String转换\r\n\r\n在某个操作或者运算需要字符串的时候，往往会触发Object的String转换，举个例子\r\n\r\n\r\n```\r\nvar obj={name:'Mofei'}\r\nvar str = ' ' + obj\r\nconsole.log(str);  //   [object Object]\r\n```\r\n上述的例子中，在字符串相加的过程中，系统调用了`obj`的String转换，具体规则如下：\r\n\r\n1. 如果`toString`方法存在并且返回“原始类型”，返回toString的结果。\r\n2. 如果toString方法不存在或者返回的不是“原始类型”，调用`valueOf`方法，如果valueOf方法存在，并且返回“原始类型”数据，返回valueOf的结果。\r\n3. 其他情况，抛出错误。\r\n\r\n我们可以用下面的方法简单的证明上面的规则：\r\n\r\n首先我们尝试改写一个对象的toString方法\r\n\r\n```\r\nvar a={\r\n\ttoString:function(){\r\n\t\tconsole.log('调用了 a.toString');\r\n\t\treturn '111';\r\n\t}\r\n}\r\nalert(a);\r\n\r\n//调用了 a.toString\r\n// 111\r\n```\r\n\r\n可以看到，系统在执行 `' '+a` 的时候，自动调用了a的toString方法，将a(Object)转换成了String。\r\n\r\n下面我们尝试证明如果toString()方法不可用的时候系统会调用valueOf()方法\r\n\r\n```\r\nvar a={\r\n\ttoString:function(){\r\n\t\tconsole.log('调用了 a.toString');\r\n\t\treturn '111';\r\n\t},\r\n\tvalueOf:function(){\r\n\t\tconsole.log('调用了 a.valueOf');\r\n\t\treturn '111';\r\n\t}\r\n}\r\nalert(a);\r\n\r\n//调用了 a.toString\r\n```\r\n\r\n这里我们增加了valueOf方法，但是发现系统并没有调用，这是因为，第一步toString返回的是原始类型，我们尝试把第一步返回的值改成一个对象 ` {} `\r\n\r\n```\r\nvar a={\r\n\ttoString:function(){\r\n\t\tconsole.log('调用了 a.toString');\r\n\t\treturn {};\r\n\t},\r\n\tvalueOf:function(){\r\n\t\tconsole.log('调用了 a.valueOf');\r\n\t\treturn '111';\r\n\t}\r\n}\r\nalert(a);\r\n\r\n// 调用了 a.toString\r\n// 调用了 a.valueOf\r\n```\r\n\r\n从结果可以看到，当toString不可用的时候，系统会再尝试valueOf方法，我们继续修改valueOf方法，把valueOf方法也改成返回对象 `{}`\r\n\r\n```\r\nvar a={\r\n\ttoString:function(){\r\n\t\tconsole.log('调用了 a.toString');\r\n\t\treturn {};\r\n\t},\r\n\tvalueOf:function(){\r\n\t\tconsole.log('调用了 a.valueOf');\r\n\t\treturn {};\r\n\t}\r\n}\r\nalert(a);\r\n\r\n// 调用了 a.toString\r\n// 调用了 a.valueOf\r\n//  Uncaught TypeError: Cannot convert object to primitive value\r\n```\r\n\r\n可以发现，如果toString和valueOf方法均不可用的情况下，系统会直接返回一个错误。\r\n\r\n\r\n## Number转换\r\n\r\n下面说说Number转换，同理，当需要使用Number时，（ 如Math.sin() ）等，解释器会尝试将对象转换成Number对象。\r\n\r\n通常有如下的情况会触发Number转换\r\n\r\n1. 方法参数需要Number的时候，如Math.sin(obj)等\r\n2. 对比的时候，如 obj == 'abc'\r\n3. 运算的时候，如 obj + 123\r\n\r\n转换规则如下：\r\n\r\n1. 如果valueOf存在，且返回“原始类型”数据，返回valueOf的结果。\r\n2. 如果toString存在，且返回“原始类型”数据，返回toString的结果。\r\n3. 报错。\r\n\r\n可以参考String转换的方法进行验证，这里只列出一种典型的方法，其他的可以自己动手来修改\r\n\r\n```\r\nvar a={\r\n\ttoString:function(){\r\n\t\tconsole.log('调用了 a.toString');\r\n\t\treturn 12;\r\n\t},\r\n\tvalueOf:function(){\r\n\t\tconsole.log('调用了 a.valueOf');\r\n\t\treturn {};\r\n\t}\r\n}\r\na+1\r\n//调用了 a.valueOf\r\n//调用了 a.toString\r\n//13\r\n```\r\n\r\n可以看到，这里我们改写了valueOf和toString方法，系统在调用valueOf方法之后发现返回的不是“原始类型”数据，于是又尝试调用了toString方法，并返回了该方法返回的值12，最后+1变成了13。\r\n\r\n\r\n## Boolean转换\r\n\r\n在进行布尔比较的时候，比如 if(obj) , while(obj)等等，会进行布尔转换，布尔转换遵循如下规则：\r\n\r\n|  值  |  布尔值  |\r\n| :----: | :----: |\r\n| true/false | true/false |\r\n| undefined,null |  false |\r\n| Number | 0,NaN 对应 false, 其他的对应 true |\r\n| String | \"\"对应false,其他对应true（'0'对应的是true） |\r\n| Object  |  true  |\r\n\r\n\r\n举个比较典型的例子\r\n\r\n```\r\n[] == ![]  //true\r\n\r\n// 首先第一步右边的是逻辑判断![]，说以先转成boolean\r\n// [] == !true\r\n// [] == false\r\n// 左边不是原始类型，尝试把左边转成原始类型，变成\r\n// '' == false\r\n// 转成Number\r\n// 0 == 0\r\n```\r\n\r\n## 总结\r\n\r\n通过上述的介绍，一开始提到的问题应该都很容易得到答案了。\r\n\r\n```\r\nparseInt(0.0000004)  // 4\r\n![]==[] //true\r\n['x','y'] == 'x,y' //true\r\nalert({name:'mofei'})  //\"[object Object]\"\r\n```\r\n关于这些转换，有时确实很让人费解，不过在了解原理之后，就会变得很容易了。有什么问题，可以给我留言，我会第一时间回复。","visited":1341,"comment":7,"pubtime":{"$date":1429531726346},"links":[["51d3dff38ece70c438000014",{"present":0.052631578947368418131,"title":"css cursor 属性 示例"}],["51d3dfe68ece70c438000013",{"present":0.025641025641025640136,"title":"javascript获取元素的宽度、高度"}],["51d3de728ece70c43800000d",{"present":0.025641025641025640136,"title":"javascript区分判断ie6、ie7、ie8"}]],"html":"<p>开始这个话题之前，我们先看一下下面的几个例子：</p>\n<pre><code>parseInt(0.0000004)  // 4\n![]==[] //true\n[&#39;x&#39;,&#39;y&#39;] == &#39;x,y&#39; //true\nalert({name:&#39;mofei&#39;})  //&quot;[object Object]&quot;\n</code></pre><p>结果有时候会让我大吃一惊，这是为什么呢？今天就和大家讨论一下JavaScript的对象转换。</p>\n<h2 id=\"-\">基础类型</h2>\n<p>先让我们了解一下JavasScript转换的“原始类型(primitive value)”：</p>\n<blockquote>\n<p>Number</p>\n<p>String</p>\n<p>Boolean</p>\n</blockquote>\n<p>在JavaScript进行对比或者各种运算的时候会把对象转换成这些类型，从而进行后续的操作，下面逐一说明：</p>\n<h2 id=\"string-\">String转换</h2>\n<p>在某个操作或者运算需要字符串的时候，往往会触发Object的String转换，举个例子</p>\n<pre><code>var obj={name:&#39;Mofei&#39;}\nvar str = &#39; &#39; + obj\nconsole.log(str);  //   [object Object]\n</code></pre><p>上述的例子中，在字符串相加的过程中，系统调用了<code>obj</code>的String转换，具体规则如下：</p>\n<ol>\n<li>如果<code>toString</code>方法存在并且返回“原始类型”，返回toString的结果。</li>\n<li>如果toString方法不存在或者返回的不是“原始类型”，调用<code>valueOf</code>方法，如果valueOf方法存在，并且返回“原始类型”数据，返回valueOf的结果。</li>\n<li>其他情况，抛出错误。</li>\n</ol>\n<p>我们可以用下面的方法简单的证明上面的规则：</p>\n<p>首先我们尝试改写一个对象的toString方法</p>\n<pre><code>var a={\n    toString:function(){\n        console.log(&#39;调用了 a.toString&#39;);\n        return &#39;111&#39;;\n    }\n}\nalert(a);\n\n//调用了 a.toString\n// 111\n</code></pre><p>可以看到，系统在执行 <code>&#39; &#39;+a</code> 的时候，自动调用了a的toString方法，将a(Object)转换成了String。</p>\n<p>下面我们尝试证明如果toString()方法不可用的时候系统会调用valueOf()方法</p>\n<pre><code>var a={\n    toString:function(){\n        console.log(&#39;调用了 a.toString&#39;);\n        return &#39;111&#39;;\n    },\n    valueOf:function(){\n        console.log(&#39;调用了 a.valueOf&#39;);\n        return &#39;111&#39;;\n    }\n}\nalert(a);\n\n//调用了 a.toString\n</code></pre><p>这里我们增加了valueOf方法，但是发现系统并没有调用，这是因为，第一步toString返回的是原始类型，我们尝试把第一步返回的值改成一个对象 <code>{}</code></p>\n<pre><code>var a={\n    toString:function(){\n        console.log(&#39;调用了 a.toString&#39;);\n        return {};\n    },\n    valueOf:function(){\n        console.log(&#39;调用了 a.valueOf&#39;);\n        return &#39;111&#39;;\n    }\n}\nalert(a);\n\n// 调用了 a.toString\n// 调用了 a.valueOf\n</code></pre><p>从结果可以看到，当toString不可用的时候，系统会再尝试valueOf方法，我们继续修改valueOf方法，把valueOf方法也改成返回对象 <code>{}</code></p>\n<pre><code>var a={\n    toString:function(){\n        console.log(&#39;调用了 a.toString&#39;);\n        return {};\n    },\n    valueOf:function(){\n        console.log(&#39;调用了 a.valueOf&#39;);\n        return {};\n    }\n}\nalert(a);\n\n// 调用了 a.toString\n// 调用了 a.valueOf\n//  Uncaught TypeError: Cannot convert object to primitive value\n</code></pre><p>可以发现，如果toString和valueOf方法均不可用的情况下，系统会直接返回一个错误。</p>\n<h2 id=\"number-\">Number转换</h2>\n<p>下面说说Number转换，同理，当需要使用Number时，（ 如Math.sin() ）等，解释器会尝试将对象转换成Number对象。</p>\n<p>通常有如下的情况会触发Number转换</p>\n<ol>\n<li>方法参数需要Number的时候，如Math.sin(obj)等</li>\n<li>对比的时候，如 obj == &#39;abc&#39;</li>\n<li>运算的时候，如 obj + 123</li>\n</ol>\n<p>转换规则如下：</p>\n<ol>\n<li>如果valueOf存在，且返回“原始类型”数据，返回valueOf的结果。</li>\n<li>如果toString存在，且返回“原始类型”数据，返回toString的结果。</li>\n<li>报错。</li>\n</ol>\n<p>可以参考String转换的方法进行验证，这里只列出一种典型的方法，其他的可以自己动手来修改</p>\n<pre><code>var a={\n    toString:function(){\n        console.log(&#39;调用了 a.toString&#39;);\n        return 12;\n    },\n    valueOf:function(){\n        console.log(&#39;调用了 a.valueOf&#39;);\n        return {};\n    }\n}\na+1\n//调用了 a.valueOf\n//调用了 a.toString\n//13\n</code></pre><p>可以看到，这里我们改写了valueOf和toString方法，系统在调用valueOf方法之后发现返回的不是“原始类型”数据，于是又尝试调用了toString方法，并返回了该方法返回的值12，最后+1变成了13。</p>\n<h2 id=\"boolean-\">Boolean转换</h2>\n<p>在进行布尔比较的时候，比如 if(obj) , while(obj)等等，会进行布尔转换，布尔转换遵循如下规则：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">值</th>\n<th style=\"text-align:center\">布尔值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">true/false</td>\n<td style=\"text-align:center\">true/false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">undefined,null</td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Number</td>\n<td style=\"text-align:center\">0,NaN 对应 false, 其他的对应 true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">&quot;&quot;对应false,其他对应true（&#39;0&#39;对应的是true）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Object</td>\n<td style=\"text-align:center\">true</td>\n</tr>\n</tbody>\n</table>\n<p>举个比较典型的例子</p>\n<pre><code>[] == ![]  //true\n\n// 首先第一步右边的是逻辑判断![]，说以先转成boolean\n// [] == !true\n// [] == false\n// 左边不是原始类型，尝试把左边转成原始类型，变成\n// &#39;&#39; == false\n// 转成Number\n// 0 == 0\n</code></pre><h2 id=\"-\">总结</h2>\n<p>通过上述的介绍，一开始提到的问题应该都很容易得到答案了。</p>\n<pre><code>parseInt(0.0000004)  // 4\n![]==[] //true\n[&#39;x&#39;,&#39;y&#39;] == &#39;x,y&#39; //true\nalert({name:&#39;mofei&#39;})  //&quot;[object Object]&quot;\n</code></pre><p>关于这些转换，有时确实很让人费解，不过在了解原理之后，就会变得很容易了。有什么问题，可以给我留言，我会第一时间回复。</p>\n"}
{"_id":{"$oid":"54687208a02135883f000002"},"title":"webGL 学习手记 | webGL 教程 （一）","classid":"325","content":"# 闲扯淡\r\n\r\n若干年前（那时候还不知道雾霾是什么），一个偶然的机会了解到了WebGL。当时出于好奇便找了些资料，想深入研究，但是由于各种原因放弃了。若干年后，来到了充满“黑暗雾霾故事“的帝都追随梦想，由于工作的原因，再次对webGL充满了浓厚额兴趣，为了不让自己的意志被时间消磨，我决定把webGL的过程写成文章，一是用来鞭励自己，二是坚持互联网的开源分享精神，给后面赶路的童鞋们提供些便利（其实最重要的是可以给博客吸引人气，有木有！！[贱萌的笑]）。\r\n\r\n## 一些介绍\r\n\r\n因为工作比较繁忙，绝大部分的东西是在业余时间进行研究的，而且OPEN GL方面确实需要些数学基础，所以进度，以及能研究的到多深入似乎取决于我的智商，所以还请各位多多理解。\r\n\r\n另外：我将学习过程中用到的一些资料放在了 `Github` 的 `Yes-webGL`  [https://github.com/zmofei/yes-webgl](https://github.com/zmofei/yes-webgl) 项目上，希望能遇到志同的人一起来完善这个事情。\r\n\r\n好了闲话少说，我们开始步入正题。\r\n\r\n## DEMO\r\n\r\n前几篇文章会先从如何用webGL实现2D图案开始来介绍，我会说从最基础的部分说起（可能会比较枯燥，请自备男/女朋友、瓜子、花生等解闷）。\r\n\r\n此次DEMO，我们在画布中通过WebGL绘制一个红色矩形：\r\n\r\n* [DEMO预览](http://zmofei.github.io/yes-webgl/demo/drawpoint.html) \r\n* [http://zmofei.github.io/yes-webgl/demo/drawpoint.html](http://zmofei.github.io/yes-webgl/demo/drawpoint.html)\r\n* [DEMO源码](https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoint.html)\r\n* [https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoint.html](https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoint.html)\r\n\r\n## YES！webGL！我们开始吧\r\n\r\n开始，还是大致介绍一下webGL实现的过程。\r\n\r\n实现webGL你需要理解下面的一些概念，`canvas`,`vertex shader`,`fragment shader`,`buffer`\r\n\r\n* canvas : 画布，如果用过canvas的同学应该很熟悉它了，webGL也是通过canvas画布展现出来的。\r\n* vartex shader : 顶点着色器，用来储存图像的位置相关信息，比如坐标、大小等。\r\n* fragment shader : 片远着色器，用来描述对象的颜色文理等信息。\r\n* buffer : 缓冲区，通常情况下如果绘制多个点，或者繁杂的纹理的时候会特别使用到`buffer object`，其他情况下，图形会在该区域进行缓冲，缓冲完成之后显示在屏幕上。\r\n\r\n那么，这些名词是如何协同工作的呢？先让我们看一张图：\r\n\r\n![webGL渲染实例图](http://static.zhuwenlong.com/upload/article/webgl01.png)\r\n\r\n上图描述了webGL处理图形的简单过程：\r\n\r\n1. 首先通过canvas获取webgl的上下文。\r\n2. 通过vartex shader（顶点着色器）和 fragment shader（片元着色器）指定图形的形状和样式。\r\n3. 将这些图形颜色等数据放入相应的缓冲区。\r\n4. 绘制在显示器上。\r\n\r\n单纯从字面意思来说可能不是在么好理解，下面结合DEMO的代码进行详细的说明。\r\n\r\n## 一、获取webGL执行环境\r\n\r\nHTML\r\n```html\r\n<canvas id=\"webgl\"></canvas>\r\n```\r\n\r\nJavaScript\r\n\r\n```javascript\r\nvar canvas = document.getElementById('webgl');\r\nvar webgl = canvas.getContext('webgl');\r\n```\r\n\r\n这一步很简单，和canvas一样，我们在进行webGL渲染之前，需要先获得webgl的执行环境（即上下文），首先我们通过`getElementById`获取到了我们用来渲染webGL的DOM元素，然后通过`getContext('webgl')`来获取webGL上下文。\r\n\r\n但是需要留意的是，在DEMO中我们并为对浏览器的兼容性进行处理，实际上`getContext`的参数可能为下面四个中的一个`[\"webgl\",\"experimental-webgl\",\"webkit-3d\",\"moz-webgl\"]`,第一个就不用多解释，第二个出现在webgl还是个实验性功能的时候，后面两个从前缀中不难判断出他们的用处。\r\n\r\n所以，通常情况下在正式的项目中，我们需要这样一个方法来获取webGL的上下文（为了DEMO的足够简单，在DEMO中并没有体现出来，后续会放一个google写的用来初始化webGL的一个“类库”）。\r\n\r\n```javascript\r\n/**\r\n * Creates a webgl context.\r\n * @param {!Canvas} canvas The canvas tag to get context\r\n *     from. If one is not passed in one will be created.\r\n * @return {!WebGLContext} The created context.\r\n */\r\nvar webglContext = function(canvas) {\r\n  var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\r\n  var context = null;\r\n  for (var ii = 0; ii < names.length; ++ii) {\r\n    try {\r\n      context = canvas.getContext(names[ii]);\r\n    } catch(e) {}\r\n    if (context) {\r\n      break;\r\n    }\r\n  }\r\n  return context;\r\n}\r\n```\r\n\r\n拿到webGL上下文之后我们可以打印出来其具体的值然后简单的看一下它的`__proto__`:\r\n\r\n```javascript\r\n\"__proto__\":{\r\n\tACTIVE_ATTRIBUTES: 35721,\r\n\tACTIVE_TEXTURE: 34016,\r\n\tACTIVE_UNIFORMS: 35718,\r\n\tALIASED_LINE_WIDTH_RANGE: 33902,\r\n\tALIASED_POINT_SIZE_RANGE: 33901,\r\n\tALPHA: 6406ALPHA_BITS: 3413,\r\n\t//...\r\n\tactiveTexture: function activeTexture() { [native code] },\r\n\tattachShader: function attachShader() { [native code] },\r\n\tbindAttribLocation: function bindAttribLocation() { [native code] },\r\n\tbindBuffer: function bindBuffer() { [native code] }\r\n\t//...\r\n}\r\n```\r\n\r\n在他的原型链上我们看到了一些类似`ACTIVE_ATTRIBUTES`之类的定值，这些值是这些属性的标识，后续的很多操作是通过这些标识来绑定到webGL对象上的，比如：\r\n\r\n```javascript\r\n//创建vertex shader\r\nwebgl.createShader(webgl.VERTEX_SHADER);\r\n//清除颜色缓冲区\r\nwebgl.clear(webgl.COLOR_BUFFER_BIT);\r\n```\r\n这些方法中的参数就是webGL原型链中的一些定值（比如`VERTEX_SHADER:35633`）,当然了你也可以用35633代替webgl.VERTEX_SHADER，其仍然能正正常工作，至于这些值是固定的么？我尝试换了几个浏览器，通过console.log打印出来发现，他们都是固定的数值，我的理解是，这些数字是固定的，可以标识webGL对象的某些属性。就像我们的身份证号码一样，一个号码标识了一个人。\r\n\r\n## 结语\r\nOK，获取到了webGL之后，我们就要去渲染图形了，下一次我会和大家说一些关于vertex shader 和 fragment shader的相关知识。\r\n","visited":2820,"comment":2,"pubtime":{"$date":1416131080469},"links":[["547f1ccfa02135883f000003",{"present":0.17647058823529412908,"title":"webGL 学习手记 | webGL 教程 （二）"}],["54817f6ea02135883f000004",{"present":0.11111111111111110494,"title":"使用缓冲区以及GLSL变量 - webGL 学习手记 | webGL 教程 （三）"}],["53a9475819a5a13617000001",{"present":0.052631578947368418131,"title":"Javascript获取服务器系统时间"}],["51d3dfda8ece70c438000012",{"present":0.025641025641025640136,"title":"jQuery新的事件绑定机制on()"}]],"html":"<h1 id=\"-\">闲扯淡</h1>\n<p>若干年前（那时候还不知道雾霾是什么），一个偶然的机会了解到了WebGL。当时出于好奇便找了些资料，想深入研究，但是由于各种原因放弃了。若干年后，来到了充满“黑暗雾霾故事“的帝都追随梦想，由于工作的原因，再次对webGL充满了浓厚额兴趣，为了不让自己的意志被时间消磨，我决定把webGL的过程写成文章，一是用来鞭励自己，二是坚持互联网的开源分享精神，给后面赶路的童鞋们提供些便利（其实最重要的是可以给博客吸引人气，有木有！！[贱萌的笑]）。</p>\n<h2 id=\"-\">一些介绍</h2>\n<p>因为工作比较繁忙，绝大部分的东西是在业余时间进行研究的，而且OPEN GL方面确实需要些数学基础，所以进度，以及能研究的到多深入似乎取决于我的智商，所以还请各位多多理解。</p>\n<p>另外：我将学习过程中用到的一些资料放在了 <code>Github</code> 的 <code>Yes-webGL</code>  <a href=\"https://github.com/zmofei/yes-webgl\">https://github.com/zmofei/yes-webgl</a> 项目上，希望能遇到志同的人一起来完善这个事情。</p>\n<p>好了闲话少说，我们开始步入正题。</p>\n<h2 id=\"demo\">DEMO</h2>\n<p>前几篇文章会先从如何用webGL实现2D图案开始来介绍，我会说从最基础的部分说起（可能会比较枯燥，请自备男/女朋友、瓜子、花生等解闷）。</p>\n<p>此次DEMO，我们在画布中通过WebGL绘制一个红色矩形：</p>\n<ul>\n<li><a href=\"http://zmofei.github.io/yes-webgl/demo/drawpoint.html\">DEMO预览</a> </li>\n<li><a href=\"http://zmofei.github.io/yes-webgl/demo/drawpoint.html\">http://zmofei.github.io/yes-webgl/demo/drawpoint.html</a></li>\n<li><a href=\"https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoint.html\">DEMO源码</a></li>\n<li><a href=\"https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoint.html\">https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoint.html</a></li>\n</ul>\n<h2 id=\"yes-webgl-\">YES！webGL！我们开始吧</h2>\n<p>开始，还是大致介绍一下webGL实现的过程。</p>\n<p>实现webGL你需要理解下面的一些概念，<code>canvas</code>,<code>vertex shader</code>,<code>fragment shader</code>,<code>buffer</code></p>\n<ul>\n<li>canvas : 画布，如果用过canvas的同学应该很熟悉它了，webGL也是通过canvas画布展现出来的。</li>\n<li>vartex shader : 顶点着色器，用来储存图像的位置相关信息，比如坐标、大小等。</li>\n<li>fragment shader : 片远着色器，用来描述对象的颜色文理等信息。</li>\n<li>buffer : 缓冲区，通常情况下如果绘制多个点，或者繁杂的纹理的时候会特别使用到<code>buffer object</code>，其他情况下，图形会在该区域进行缓冲，缓冲完成之后显示在屏幕上。</li>\n</ul>\n<p>那么，这些名词是如何协同工作的呢？先让我们看一张图：</p>\n<p><img src=\"http://static.zhuwenlong.com/upload/article/webgl01.png\" alt=\"webGL渲染实例图\"></p>\n<p>上图描述了webGL处理图形的简单过程：</p>\n<ol>\n<li>首先通过canvas获取webgl的上下文。</li>\n<li>通过vartex shader（顶点着色器）和 fragment shader（片元着色器）指定图形的形状和样式。</li>\n<li>将这些图形颜色等数据放入相应的缓冲区。</li>\n<li>绘制在显示器上。</li>\n</ol>\n<p>单纯从字面意思来说可能不是在么好理解，下面结合DEMO的代码进行详细的说明。</p>\n<h2 id=\"-webgl-\">一、获取webGL执行环境</h2>\n<p>HTML</p>\n<pre><code class=\"lang-html\">&lt;canvas id=&quot;webgl&quot;&gt;&lt;/canvas&gt;\n</code></pre>\n<p>JavaScript</p>\n<pre><code class=\"lang-javascript\">var canvas = document.getElementById(&#39;webgl&#39;);\nvar webgl = canvas.getContext(&#39;webgl&#39;);\n</code></pre>\n<p>这一步很简单，和canvas一样，我们在进行webGL渲染之前，需要先获得webgl的执行环境（即上下文），首先我们通过<code>getElementById</code>获取到了我们用来渲染webGL的DOM元素，然后通过<code>getContext(&#39;webgl&#39;)</code>来获取webGL上下文。</p>\n<p>但是需要留意的是，在DEMO中我们并为对浏览器的兼容性进行处理，实际上<code>getContext</code>的参数可能为下面四个中的一个<code>[&quot;webgl&quot;,&quot;experimental-webgl&quot;,&quot;webkit-3d&quot;,&quot;moz-webgl&quot;]</code>,第一个就不用多解释，第二个出现在webgl还是个实验性功能的时候，后面两个从前缀中不难判断出他们的用处。</p>\n<p>所以，通常情况下在正式的项目中，我们需要这样一个方法来获取webGL的上下文（为了DEMO的足够简单，在DEMO中并没有体现出来，后续会放一个google写的用来初始化webGL的一个“类库”）。</p>\n<pre><code class=\"lang-javascript\">/**\n * Creates a webgl context.\n * @param {!Canvas} canvas The canvas tag to get context\n *     from. If one is not passed in one will be created.\n * @return {!WebGLContext} The created context.\n */\nvar webglContext = function(canvas) {\n  var names = [&quot;webgl&quot;, &quot;experimental-webgl&quot;, &quot;webkit-3d&quot;, &quot;moz-webgl&quot;];\n  var context = null;\n  for (var ii = 0; ii &lt; names.length; ++ii) {\n    try {\n      context = canvas.getContext(names[ii]);\n    } catch(e) {}\n    if (context) {\n      break;\n    }\n  }\n  return context;\n}\n</code></pre>\n<p>拿到webGL上下文之后我们可以打印出来其具体的值然后简单的看一下它的<code>__proto__</code>:</p>\n<pre><code class=\"lang-javascript\">&quot;__proto__&quot;:{\n    ACTIVE_ATTRIBUTES: 35721,\n    ACTIVE_TEXTURE: 34016,\n    ACTIVE_UNIFORMS: 35718,\n    ALIASED_LINE_WIDTH_RANGE: 33902,\n    ALIASED_POINT_SIZE_RANGE: 33901,\n    ALPHA: 6406ALPHA_BITS: 3413,\n    //...\n    activeTexture: function activeTexture() { [native code] },\n    attachShader: function attachShader() { [native code] },\n    bindAttribLocation: function bindAttribLocation() { [native code] },\n    bindBuffer: function bindBuffer() { [native code] }\n    //...\n}\n</code></pre>\n<p>在他的原型链上我们看到了一些类似<code>ACTIVE_ATTRIBUTES</code>之类的定值，这些值是这些属性的标识，后续的很多操作是通过这些标识来绑定到webGL对象上的，比如：</p>\n<pre><code class=\"lang-javascript\">//创建vertex shader\nwebgl.createShader(webgl.VERTEX_SHADER);\n//清除颜色缓冲区\nwebgl.clear(webgl.COLOR_BUFFER_BIT);\n</code></pre>\n<p>这些方法中的参数就是webGL原型链中的一些定值（比如<code>VERTEX_SHADER:35633</code>）,当然了你也可以用35633代替webgl.VERTEX_SHADER，其仍然能正正常工作，至于这些值是固定的么？我尝试换了几个浏览器，通过console.log打印出来发现，他们都是固定的数值，我的理解是，这些数字是固定的，可以标识webGL对象的某些属性。就像我们的身份证号码一样，一个号码标识了一个人。</p>\n<h2 id=\"-\">结语</h2>\n<p>OK，获取到了webGL之后，我们就要去渲染图形了，下一次我会和大家说一些关于vertex shader 和 fragment shader的相关知识。</p>\n","like":1}
{"_id":{"$oid":"54817f6ea02135883f000004"},"title":"使用缓冲区以及GLSL变量 - webGL 学习手记 | webGL 教程 （三）","classid":"325","content":"前两篇的文章我们介绍了如何使用webGL进行简单的绘制，今天我们简单说一下如何使用缓冲区。\r\n\r\n* [DEMO预览](http://zmofei.github.io/yes-webgl/demo/drawpoints.html) \r\n* [http://zmofei.github.io/yes-webgl/demo/drawpoint.html](http://zmofei.github.io/yes-webgl/demo/drawpoints.html)\r\n* [DEMO源码](https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoints.html)\r\n* [https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoint.html](https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoints.html)\r\n* [DEMO在线调试](http://jsbin.com/vavude/1/edit)\r\n* [http://jsbin.com/vavude/1/edit](http://jsbin.com/vavude/1/edit)\r\n\r\n另外，我将学习过程中用到的一些资料放在了 Github 的 Yes-webGL [https://github.com/zmofei/yes-webgl](https://github.com/zmofei/yes-webgl) 项目上，如果大家有什么好的建议，或者愿意一同来写教程的欢迎来骚扰我。\r\n\r\n\r\n## 何为缓冲区？\r\n\r\n通过前面的例子，我们应该对webGl的渲染过程很熟悉了， `创建项目 -> 绑定shader -> 清除画布 -> 绘制画布` ， 每次绘制钱我们都会去青春画布上的内容，然后进行新的绘制。但是，如果我们需要一次性绘制多个点或者多个图形怎么办呢？如果一个一个的去绘制的话，在性能上很有可能不尽人意，尤其是我们有千千万万个绘制点的时候。\r\n\r\n这时候`缓冲区`就开始刷存在感了，我们可以先将我们的数据存入到缓冲去，然后再一次性的把缓冲区的数据绘制出来。\r\n\r\n## 一些封装\r\n\r\n这个DEMO中，我们将`获取WebGL上下文`，`绑定着色器`等复杂的步骤进行了封装，如果想了解这两个步骤是如何工作的，请参考前两篇的文章。\r\n\r\n## 缓冲区使用的步骤\r\n\r\n现在步入正题，来看看我们DEMO中是如何处理这些细节的。\r\n\r\n缓冲区使用非常简单，这里我们通过一下的步骤完成了缓冲区的创建、绑定、数据传入等工作\r\n\r\n1. 创建缓冲区\r\n2. 绑定缓冲区到WebGL对象\r\n3. 传入数据到缓冲区\r\n\r\n### 1. createBuffer()\r\n\r\n```\r\nvar vertexColorBuffer = gl.createBuffer();\r\n```\r\n\r\n创建缓冲区，这个很好理解，不用多说\r\n\r\n\r\n### 2. bindBuffer()\r\n\r\n```\r\ngl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);\r\n```\r\n\r\n将创建出来的缓冲区绑定到webGL对向上，这里我们使用了2个参数，第一个是类型，因为我们使用的是数组的点数据，所以使用系统提供的`gl.ARRAY_BUFFER`变量。\r\n\r\n第2个参数是我们需要绑定的Buffer对象，这里使用的就是我们第一步创建出来的Buffer对象。\r\n\r\n### 3. bufferData()\r\n\r\n```\r\nvar verticesColors = new Float32Array([\r\n\t 0.5,  0.5,  0, \r\n\t-0.5, -0.5,  0, \r\n\t-0.5,  0.5,  0,    \r\n\t 0.5, -0.5,  0]);\r\n//...\r\ngl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW);\r\n```\r\n\r\n这一步我们将我们的点位置数组传入到Buffer对象中\r\n该方法接受的3个参数分别为\r\n\r\n* 数据类型，可以是`gl.ARRAY_BUFFER`,`gl.ELEMENT_ARRAY_BUFFER`,本例中使用的是`gl.ARRAY_BUFFER`\r\n* 数据\r\n* 缓冲类型，有这么几种可以供我们选择`GL_STREAM_DRAW`,`GL_STATIC_DRAW`,`GL_DYNAMIC_DRAW`\r\n\r\n## GLSL 变量的使用\r\n\r\n在本例中，我们通过js向定点着色器中传入了一些顶点坐标，那么这些坐标是如何赋值的呢？\r\n\r\n```\r\nvar VSHADER_SOURCE =\r\n        'attribute vec4 a_Position;\\n' +\r\n        'void main() {\\n' +\r\n        '  gl_Position = a_Position;\\n' +\r\n        '  gl_PointSize = 10.0;\\n' +\r\n        '}\\n';\r\n```\r\n\r\n首先看顶点着色器，我们声明了a_Position变量，接下来我们通过下面的方法进行赋值。\r\n\r\n```\r\nvar a_Position = gl.getAttribLocation(gl.program, 'a_Position');\r\ngl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\r\ngl.enableVertexAttribArray(a_Position);\r\n```\r\n\r\n### getAttribLocation（program, name）\r\n\r\n在js中，我们首先通过getAttribLocation()获取到变量`a_Position`在渲染器中的地址。\r\n该方法接收两个变量\r\n\r\n* program project对象\r\n* name 变量名称\r\n\r\n接下来我们通过vertexAttribPointer()方法，指定了如何处理渲染器中的值。\r\n\r\n### vertexAttribPointer(index, size, type, normalized, stride, offset);\r\n\r\n比较复杂的一个方法\r\n\r\n* index 绑定在gl.ARRAY_BUFFER中的目标索引，比较难理解，但是通常情况下我们可以通过getAttribLocation来获取这个值。\r\n* size 每个属性的长度 [1，2，3，4(default)]\r\n* type 类型 指定数据类型 我们有两个选择，[gl.FLOAT (default)|gl.FIXED]\r\n* normalized 是否初始化传入的数据 [gl.FALSE|gl.TRUE]\r\n* stride 每组数据的个数，[0-255]\r\n* offset 这一组中的数据起始位置（从0开始）\r\n\r\n接下来启用 enableVertexAttribArray()\r\n\r\n### enableVertexAttribArray(index);\r\n\r\n* index 同 vertexAttribPointer中的index\r\n\r\n##总结\r\n\r\nOK，目前为止我们已经学会了WebGL的非常基本的知识，接下来，我们尝试真正的迈入3D的学习。\r\n\r\n---\r\n\r\n#### 快速链接\r\n\r\n* [《webGL 学习手记 | webGL 教程 （一）》](http://www.zhuwenlong.com/blog/54687208a02135883f000002)\r\n* [《webGL 学习手记 | webGL 教程 （二）》](http://www.zhuwenlong.com/blog/547f1ccfa02135883f000003)","visited":1433,"comment":3,"pubtime":{"$date":1417772910490},"links":[["547f1ccfa02135883f000003",{"present":0.14285714285714284921,"title":"webGL 学习手记 | webGL 教程 （二）"}],["54687208a02135883f000002",{"present":0.11111111111111110494,"title":"webGL 学习手记 | webGL 教程 （一）"}],["53a9475819a5a13617000001",{"present":0.052631578947368418131,"title":"Javascript获取服务器系统时间"}],["51d3dfda8ece70c438000012",{"present":0.025641025641025640136,"title":"jQuery新的事件绑定机制on()"}]],"html":"<p>前两篇的文章我们介绍了如何使用webGL进行简单的绘制，今天我们简单说一下如何使用缓冲区。</p>\n<ul>\n<li><a href=\"http://zmofei.github.io/yes-webgl/demo/drawpoints.html\">DEMO预览</a> </li>\n<li><a href=\"http://zmofei.github.io/yes-webgl/demo/drawpoints.html\">http://zmofei.github.io/yes-webgl/demo/drawpoint.html</a></li>\n<li><a href=\"https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoints.html\">DEMO源码</a></li>\n<li><a href=\"https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoints.html\">https://github.com/zmofei/yes-webgl/blob/master/demo/drawpoint.html</a></li>\n<li><a href=\"http://jsbin.com/vavude/1/edit\">DEMO在线调试</a></li>\n<li><a href=\"http://jsbin.com/vavude/1/edit\">http://jsbin.com/vavude/1/edit</a></li>\n</ul>\n<p>另外，我将学习过程中用到的一些资料放在了 Github 的 Yes-webGL <a href=\"https://github.com/zmofei/yes-webgl\">https://github.com/zmofei/yes-webgl</a> 项目上，如果大家有什么好的建议，或者愿意一同来写教程的欢迎来骚扰我。</p>\n<h2 id=\"-\">何为缓冲区？</h2>\n<p>通过前面的例子，我们应该对webGl的渲染过程很熟悉了， <code>创建项目 -&gt; 绑定shader -&gt; 清除画布 -&gt; 绘制画布</code> ， 每次绘制钱我们都会去青春画布上的内容，然后进行新的绘制。但是，如果我们需要一次性绘制多个点或者多个图形怎么办呢？如果一个一个的去绘制的话，在性能上很有可能不尽人意，尤其是我们有千千万万个绘制点的时候。</p>\n<p>这时候<code>缓冲区</code>就开始刷存在感了，我们可以先将我们的数据存入到缓冲去，然后再一次性的把缓冲区的数据绘制出来。</p>\n<h2 id=\"-\">一些封装</h2>\n<p>这个DEMO中，我们将<code>获取WebGL上下文</code>，<code>绑定着色器</code>等复杂的步骤进行了封装，如果想了解这两个步骤是如何工作的，请参考前两篇的文章。</p>\n<h2 id=\"-\">缓冲区使用的步骤</h2>\n<p>现在步入正题，来看看我们DEMO中是如何处理这些细节的。</p>\n<p>缓冲区使用非常简单，这里我们通过一下的步骤完成了缓冲区的创建、绑定、数据传入等工作</p>\n<ol>\n<li>创建缓冲区</li>\n<li>绑定缓冲区到WebGL对象</li>\n<li>传入数据到缓冲区</li>\n</ol>\n<h3 id=\"1-createbuffer-\">1. createBuffer()</h3>\n<pre><code>var vertexColorBuffer = gl.createBuffer();\n</code></pre><p>创建缓冲区，这个很好理解，不用多说</p>\n<h3 id=\"2-bindbuffer-\">2. bindBuffer()</h3>\n<pre><code>gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);\n</code></pre><p>将创建出来的缓冲区绑定到webGL对向上，这里我们使用了2个参数，第一个是类型，因为我们使用的是数组的点数据，所以使用系统提供的<code>gl.ARRAY_BUFFER</code>变量。</p>\n<p>第2个参数是我们需要绑定的Buffer对象，这里使用的就是我们第一步创建出来的Buffer对象。</p>\n<h3 id=\"3-bufferdata-\">3. bufferData()</h3>\n<pre><code>var verticesColors = new Float32Array([\n     0.5,  0.5,  0, \n    -0.5, -0.5,  0, \n    -0.5,  0.5,  0,    \n     0.5, -0.5,  0]);\n//...\ngl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW);\n</code></pre><p>这一步我们将我们的点位置数组传入到Buffer对象中\n该方法接受的3个参数分别为</p>\n<ul>\n<li>数据类型，可以是<code>gl.ARRAY_BUFFER</code>,<code>gl.ELEMENT_ARRAY_BUFFER</code>,本例中使用的是<code>gl.ARRAY_BUFFER</code></li>\n<li>数据</li>\n<li>缓冲类型，有这么几种可以供我们选择<code>GL_STREAM_DRAW</code>,<code>GL_STATIC_DRAW</code>,<code>GL_DYNAMIC_DRAW</code></li>\n</ul>\n<h2 id=\"glsl-\">GLSL 变量的使用</h2>\n<p>在本例中，我们通过js向定点着色器中传入了一些顶点坐标，那么这些坐标是如何赋值的呢？</p>\n<pre><code>var VSHADER_SOURCE =\n        &#39;attribute vec4 a_Position;\\n&#39; +\n        &#39;void main() {\\n&#39; +\n        &#39;  gl_Position = a_Position;\\n&#39; +\n        &#39;  gl_PointSize = 10.0;\\n&#39; +\n        &#39;}\\n&#39;;\n</code></pre><p>首先看顶点着色器，我们声明了a_Position变量，接下来我们通过下面的方法进行赋值。</p>\n<pre><code>var a_Position = gl.getAttribLocation(gl.program, &#39;a_Position&#39;);\ngl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\ngl.enableVertexAttribArray(a_Position);\n</code></pre><h3 id=\"getattriblocation-program-name-\">getAttribLocation（program, name）</h3>\n<p>在js中，我们首先通过getAttribLocation()获取到变量<code>a_Position</code>在渲染器中的地址。\n该方法接收两个变量</p>\n<ul>\n<li>program project对象</li>\n<li>name 变量名称</li>\n</ul>\n<p>接下来我们通过vertexAttribPointer()方法，指定了如何处理渲染器中的值。</p>\n<h3 id=\"vertexattribpointer-index-size-type-normalized-stride-offset-\">vertexAttribPointer(index, size, type, normalized, stride, offset);</h3>\n<p>比较复杂的一个方法</p>\n<ul>\n<li>index 绑定在gl.ARRAY_BUFFER中的目标索引，比较难理解，但是通常情况下我们可以通过getAttribLocation来获取这个值。</li>\n<li>size 每个属性的长度 [1，2，3，4(default)]</li>\n<li>type 类型 指定数据类型 我们有两个选择，[gl.FLOAT (default)|gl.FIXED]</li>\n<li>normalized 是否初始化传入的数据 [gl.FALSE|gl.TRUE]</li>\n<li>stride 每组数据的个数，[0-255]</li>\n<li>offset 这一组中的数据起始位置（从0开始）</li>\n</ul>\n<p>接下来启用 enableVertexAttribArray()</p>\n<h3 id=\"enablevertexattribarray-index-\">enableVertexAttribArray(index);</h3>\n<ul>\n<li>index 同 vertexAttribPointer中的index</li>\n</ul>\n<p>##总结</p>\n<p>OK，目前为止我们已经学会了WebGL的非常基本的知识，接下来，我们尝试真正的迈入3D的学习。</p>\n<hr>\n<h4 id=\"-\">快速链接</h4>\n<ul>\n<li><a href=\"http://www.zhuwenlong.com/blog/54687208a02135883f000002\">《webGL 学习手记 | webGL 教程 （一）》</a></li>\n<li><a href=\"http://www.zhuwenlong.com/blog/547f1ccfa02135883f000003\">《webGL 学习手记 | webGL 教程 （二）》</a></li>\n</ul>\n"}
{"_id":{"$oid":"528611f363c705fc73000001"},"classid":"100","comment":1,"content":"## 背景\r\n\r\n在进行类似微博墙之类的展示页面中，经常会遇到这样的需求：在固定大小的区域放入字数不定的文字，但是要求字体可以自动改变大小来自动填充这些区域。如下所示：\r\n\r\n![文字大小自适应](http://static.zhuwenlong.com/upload/article/20131115195001.jpg)\r\n\r\n遇到这种情况怎么办呢？\r\n\r\n## 思考\r\n\r\n--------\r\n\r\n### 思考一：面积法\r\n\r\n看到需求我的第一个反应是能不能通过计算，先获取整个区域的大小，然后再根据字数，计算出每个文字所占的区域（整体区域面积/总共字数），再根据每个文字所占的区域设置字体大小。\r\n\r\n理论上这种方案是可以行的，但是实际执行的过程中，突然发现，如果给出的字符中有标签比如说 a 链接、img标签等等，那么如何去计算总共的字数？如果算上这些标签肯定会导致计算出的结果偏小。当然这个问题可以通过过滤标签，然后计算出实际显示的字数来解决。\r\n\r\n但后续的问题又来了，当我计算出一个字体可以使用的面积是30px*30px，那此时字体应该是多大呢？ 30px？ 15px？ 没人知道。。。。\r\n\r\n这还不算，如果此时文字中包含数字英文神马的，每个字的宽度都不同怎么办？如何计算？\r\n\r\n### 思考二：微调法\r\n\r\n最终因为问题太多，我们放弃了第一种方案，提出了第二种微调法，该做法比较巧妙。\r\n\r\n首先将文字放到一个容器中（比如说div），从最小的值开始（如12px），然后读取此时的容器高度，比较有没有超出最大的高度。如果没有，把字体大小加一（13px），然后再次比较容器的高度和最大高度…… 依此类推，直到容器的大小大于最大的高度，此时，取前一个值就最佳文字大小。\r\n\r\n由于调整的是最终的显示大小，所以这种方法可以规避掉第一张方案的很多问题，比如说文字中含有标签，中英混排等。\r\n\r\n到此，一种可行的解决方案诞生了。但是有人会问，这种频繁的调整文字的大小，不停的获取容器的高度，在性能上或者显示上是不是会有问题？最初我也有这种怀疑，但是事实证明，包括IE6在内，表现都非常好，用户肉眼都看不到这个调整的过程。\r\n\r\n## 代码\r\n\r\n--------\r\n\r\n最后附上这个方案的代码如下\r\n\r\n```javascript\r\n//最大高度\r\nvar maxHeight = 200;  \r\n\r\n//初始化文字大小为最小\r\nwordbox.css('font-size', '12px');\r\n\r\n//循环修改大小直至大于最大高度\r\nfor (var i = 12; i < 200; i++) {\r\n    if (wordbox.height() > maxHeight) {\r\n        //当容器高度大于最大高度的时候，上一个尝试的值就是最佳大小。\r\n        wordbox.css('font-size', (i - 2) + 'px');\r\n        //结束循环\r\n        break;\r\n    } else {\r\n        //如果小于最大高度，文字大小加1继续尝试\r\n        wordbox.css('font-size', i + 'px');\r\n    }\r\n}\r\n\r\n```\r\n","pubtime":{"$date":1384518131784},"title":"javascript 文字大小自动适应文本框 （文字大小自动调整）","visited":11378,"links":[["51d3dc538ece70c438000005",{"present":0.11111111111111110494,"title":"小心 -webkit-text-size-adjust:none！[译]"}],["51d3dcfc8ece70c438000007",{"present":0.052631578947368418131,"title":"div模拟textarea文本域轻松实现高度自适应"}],["52d6769f93dcae3050000003",{"present":0.025641025641025640136,"title":"HTML5 file api 读取文件MD5码"}],["527100b5ce7d63c80c000001",{"present":0.025641025641025640136,"title":"跨域iframe高度自适应实现方案"}],["51d3de8e8ece70c43800000f",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（二） 用HTML5构建应用程序"}],["53995f446b13b74d15000001",{"present":0.025641025641025640136,"title":"Flexbox 布局完全解析"}]],"html":"<h2 id=\"-\">背景</h2>\n<p>在进行类似微博墙之类的展示页面中，经常会遇到这样的需求：在固定大小的区域放入字数不定的文字，但是要求字体可以自动改变大小来自动填充这些区域。如下所示：</p>\n<p><img src=\"http://static.zhuwenlong.com/upload/article/20131115195001.jpg\" alt=\"文字大小自适应\"></p>\n<p>遇到这种情况怎么办呢？</p>\n<h2 id=\"-\">思考</h2>\n<hr>\n<h3 id=\"-\">思考一：面积法</h3>\n<p>看到需求我的第一个反应是能不能通过计算，先获取整个区域的大小，然后再根据字数，计算出每个文字所占的区域（整体区域面积/总共字数），再根据每个文字所占的区域设置字体大小。</p>\n<p>理论上这种方案是可以行的，但是实际执行的过程中，突然发现，如果给出的字符中有标签比如说 a 链接、img标签等等，那么如何去计算总共的字数？如果算上这些标签肯定会导致计算出的结果偏小。当然这个问题可以通过过滤标签，然后计算出实际显示的字数来解决。</p>\n<p>但后续的问题又来了，当我计算出一个字体可以使用的面积是30px*30px，那此时字体应该是多大呢？ 30px？ 15px？ 没人知道。。。。</p>\n<p>这还不算，如果此时文字中包含数字英文神马的，每个字的宽度都不同怎么办？如何计算？</p>\n<h3 id=\"-\">思考二：微调法</h3>\n<p>最终因为问题太多，我们放弃了第一种方案，提出了第二种微调法，该做法比较巧妙。</p>\n<p>首先将文字放到一个容器中（比如说div），从最小的值开始（如12px），然后读取此时的容器高度，比较有没有超出最大的高度。如果没有，把字体大小加一（13px），然后再次比较容器的高度和最大高度…… 依此类推，直到容器的大小大于最大的高度，此时，取前一个值就最佳文字大小。</p>\n<p>由于调整的是最终的显示大小，所以这种方法可以规避掉第一张方案的很多问题，比如说文字中含有标签，中英混排等。</p>\n<p>到此，一种可行的解决方案诞生了。但是有人会问，这种频繁的调整文字的大小，不停的获取容器的高度，在性能上或者显示上是不是会有问题？最初我也有这种怀疑，但是事实证明，包括IE6在内，表现都非常好，用户肉眼都看不到这个调整的过程。</p>\n<h2 id=\"-\">代码</h2>\n<hr>\n<p>最后附上这个方案的代码如下</p>\n<pre><code class=\"lang-javascript\">//最大高度\nvar maxHeight = 200;  \n\n//初始化文字大小为最小\nwordbox.css(&#39;font-size&#39;, &#39;12px&#39;);\n\n//循环修改大小直至大于最大高度\nfor (var i = 12; i &lt; 200; i++) {\n    if (wordbox.height() &gt; maxHeight) {\n        //当容器高度大于最大高度的时候，上一个尝试的值就是最佳大小。\n        wordbox.css(&#39;font-size&#39;, (i - 2) + &#39;px&#39;);\n        //结束循环\n        break;\n    } else {\n        //如果小于最大高度，文字大小加1继续尝试\n        wordbox.css(&#39;font-size&#39;, i + &#39;px&#39;);\n    }\n}\n</code></pre>\n","like":1}
{"_id":{"$oid":"51f6519532ffd70b27000001"},"classid":"100","comment":3,"content":"\r\n目前市场上大多数的网站的断点上传都是需要安装浏览器插件的，本文就针对高级浏览器的环境下，通过HTML5 File api实现断点上传进行说明\r\n\r\n\r\n一、实现文件多选\r\n\r\nHTML5的`<input>`新增了\"multiple\"属性，该属性可接受多个值的文件上传字段\r\n\r\n``` html\r\n<input type=\"file\" multiple=\"multiple\" name=\"file\" id=\"file\">\r\n```\r\n\r\n添加了该属性用户就可以在弹出的对话框中一次性选择多个文件了\r\n\r\n\r\n二、实现文件从计算机拖拽到网页以及添加文件队列功能\r\n\r\n这里我们用 dragover 和 drop 两个事件来管理文件拖拽的功能\r\n\r\n其中 dragover 用来处理在指定的元素上移动时的事件，这里我们通过给body绑定dragover时间来处理页面中拖动文件的事件\r\n\r\n``` javascript\r\ndocument.body.addEventListener('dragover', dragFile, false);\r\n\r\nfunction dragFile(evt) {\r\n    evt.stopPropagation();\r\n    evt.preventDefault();\r\n    evt.dataTransfer.dropEffect = 'copy';\r\n}\r\n```\r\n\r\n用 drop 事件来处理鼠标松开时候的事件，此时应该将用户拖动过来的文件加入到上传队列中，以供后续的处理\r\n\r\n```javascript\r\ndocument.body.addEventListener('drop', dropFile, false);\r\n\r\nfunction dragFile(evt) {\r\n    evt.stopPropagation();\r\n    evt.preventDefault();\r\n     // dataTransfer.files属性可以获取到所有拖动选择的文件，通过遍历可以读取到所有文件的信息。\r\n     // 遍历每个文件可以获取到文件的 name、size、type、lastModifiedDate等关键信息\r\n    var files = evt.dataTransfer.files;\r\n     // addfile 方法 用来添加上传文件队列，在input的change事件中也需要调用\r\n     // 该方法首先检查有无文件正在上传中，如果有就将后续加入的文件放到上传队列中，如果没有文件正在上传就直接执行上传命令\r\n    addfile(files);\r\n}\r\n```\r\n\r\n\r\n三、文件续传原理\r\n\r\n目前比较常用的断点续传的方法有两种，一种是通过websocket接口进行文件上传，另一种是通过ajax，两种方法各有千秋，虽然websocket听起来比较高端些~ 但是除了用了不同的协议外其他的算法基本上都是很相似的，并且服务端要开启ws接口，这里用相对方便的ajax来说明断点上传的思路。\r\n\r\n说来说去，断点续传最核心的内容就是把文件“切片”然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。\r\n\r\n首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。\r\n\r\n因此在文件开始上传之前，我们和服务器要有一个“握手”的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。\r\n\r\n前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。\r\n\r\n当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。\r\n\r\n\r\n四、文件的前端切片\r\n\r\n有了HTML5 的 File api之后切割文件比想想的要简单的多的多。\r\n\r\n只要用slice 方法就可以了\r\n\r\n```javascript\r\nvar packet = file.slice(start, end);\r\n```\r\n\r\n参数start是开始切片的位置，end是切片结束的位置 单位都是字节。通过控制start和end 就可以是实现文件的分块\r\n\r\n如\r\n``` javascript\r\nfile.slice(0,1000);\r\nfile.slice(1000,2000);\r\nfile.slice(2000,3000);\r\n// ......\r\n```\r\n\r\n五、文件片段的上传\r\n\r\n上一部我们通过slice方法把文件分成了若干块，接下来要做的事情就是把这些碎片传到服务器上。\r\n\r\n这里我们用ajax的post请求来实现\r\n\r\n```javascript\r\nvar xhr = new XMLHttpRequest();\r\nvar url = xxx // 文件上传的地址 可以包括文件的参数 如文件名称 分块数等以便后台处理\r\nxhr.open('POST', url, true);\r\nxhr.onload = function (e){\r\n     // 判断文件是否上传成功，如果成功继续上传下一块，如果失败重试该快\r\n}\r\nxhr.upload.onprogress = function(e){\r\n     // 选用 如果文件分块大小较大 可以通过该方法判断单片文件具体的上传进度\r\n     // e.loaded  该片文件上传了多少\r\n     // e.totalSize 该片文件的总共大小\r\n}\r\nxhr.send(packet);\r\n```\r\n","pubtime":{"$date":1375097237060},"title":"HTML5 File api 实现断点续传","visited":33909,"links":[["52cfc44ad4cf86262b000001",{"present":0.081081081081081085582,"title":"HTML5 拖动（Drag）文件到文件夹下载"}],["52d6769f93dcae3050000003",{"present":0.052631578947368418131,"title":"HTML5 file api 读取文件MD5码"}],["53eb8e22b55b886a13000001",{"present":0.052631578947368418131,"title":"我是如何发布版本的"}],["5349905d7eeca8ec50000001",{"present":0.052631578947368418131,"title":"manifest 详解以及规范"}],["53b37b9e4b7a6de506000001",{"present":0.025641025641025640136,"title":"HTML input 选色板 ( HTML5 Color Input )"}],["527100b5ce7d63c80c000001",{"present":0.025641025641025640136,"title":"跨域iframe高度自适应实现方案"}],["51d3dfda8ece70c438000012",{"present":0.025641025641025640136,"title":"jQuery新的事件绑定机制on()"}]],"html":"<p>目前市场上大多数的网站的断点上传都是需要安装浏览器插件的，本文就针对高级浏览器的环境下，通过HTML5 File api实现断点上传进行说明</p>\n<p>一、实现文件多选</p>\n<p>HTML5的<code>&lt;input&gt;</code>新增了&quot;multiple&quot;属性，该属性可接受多个值的文件上传字段</p>\n<pre><code class=\"lang-html\">&lt;input type=&quot;file&quot; multiple=&quot;multiple&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;\n</code></pre>\n<p>添加了该属性用户就可以在弹出的对话框中一次性选择多个文件了</p>\n<p>二、实现文件从计算机拖拽到网页以及添加文件队列功能</p>\n<p>这里我们用 dragover 和 drop 两个事件来管理文件拖拽的功能</p>\n<p>其中 dragover 用来处理在指定的元素上移动时的事件，这里我们通过给body绑定dragover时间来处理页面中拖动文件的事件</p>\n<pre><code class=\"lang-javascript\">document.body.addEventListener(&#39;dragover&#39;, dragFile, false);\n\nfunction dragFile(evt) {\n    evt.stopPropagation();\n    evt.preventDefault();\n    evt.dataTransfer.dropEffect = &#39;copy&#39;;\n}\n</code></pre>\n<p>用 drop 事件来处理鼠标松开时候的事件，此时应该将用户拖动过来的文件加入到上传队列中，以供后续的处理</p>\n<pre><code class=\"lang-javascript\">document.body.addEventListener(&#39;drop&#39;, dropFile, false);\n\nfunction dragFile(evt) {\n    evt.stopPropagation();\n    evt.preventDefault();\n     // dataTransfer.files属性可以获取到所有拖动选择的文件，通过遍历可以读取到所有文件的信息。\n     // 遍历每个文件可以获取到文件的 name、size、type、lastModifiedDate等关键信息\n    var files = evt.dataTransfer.files;\n     // addfile 方法 用来添加上传文件队列，在input的change事件中也需要调用\n     // 该方法首先检查有无文件正在上传中，如果有就将后续加入的文件放到上传队列中，如果没有文件正在上传就直接执行上传命令\n    addfile(files);\n}\n</code></pre>\n<p>三、文件续传原理</p>\n<p>目前比较常用的断点续传的方法有两种，一种是通过websocket接口进行文件上传，另一种是通过ajax，两种方法各有千秋，虽然websocket听起来比较高端些~ 但是除了用了不同的协议外其他的算法基本上都是很相似的，并且服务端要开启ws接口，这里用相对方便的ajax来说明断点上传的思路。</p>\n<p>说来说去，断点续传最核心的内容就是把文件“切片”然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。</p>\n<p>首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。</p>\n<p>因此在文件开始上传之前，我们和服务器要有一个“握手”的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。</p>\n<p>前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。</p>\n<p>当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。</p>\n<p>四、文件的前端切片</p>\n<p>有了HTML5 的 File api之后切割文件比想想的要简单的多的多。</p>\n<p>只要用slice 方法就可以了</p>\n<pre><code class=\"lang-javascript\">var packet = file.slice(start, end);\n</code></pre>\n<p>参数start是开始切片的位置，end是切片结束的位置 单位都是字节。通过控制start和end 就可以是实现文件的分块</p>\n<p>如</p>\n<pre><code class=\"lang-javascript\">file.slice(0,1000);\nfile.slice(1000,2000);\nfile.slice(2000,3000);\n// ......\n</code></pre>\n<p>五、文件片段的上传</p>\n<p>上一部我们通过slice方法把文件分成了若干块，接下来要做的事情就是把这些碎片传到服务器上。</p>\n<p>这里我们用ajax的post请求来实现</p>\n<pre><code class=\"lang-javascript\">var xhr = new XMLHttpRequest();\nvar url = xxx // 文件上传的地址 可以包括文件的参数 如文件名称 分块数等以便后台处理\nxhr.open(&#39;POST&#39;, url, true);\nxhr.onload = function (e){\n     // 判断文件是否上传成功，如果成功继续上传下一块，如果失败重试该快\n}\nxhr.upload.onprogress = function(e){\n     // 选用 如果文件分块大小较大 可以通过该方法判断单片文件具体的上传进度\n     // e.loaded  该片文件上传了多少\n     // e.totalSize 该片文件的总共大小\n}\nxhr.send(packet);\n</code></pre>\n","like":4}
{"_id":{"$oid":"52836b510d1662a510000001"},"classid":"100","comment":0,"content":"翻阅之前自己在网易博客上曾经写过的文字，发现有不少值得回味的东西，选择一些有感触的拿过来，算是对生命的一种回忆吧。\r\n\r\n这是我在高二的时候写下的一些文字，在此之前这篇文章未曾公开过。当时那个年级还搞不懂什么是爱情，什么是友情，但是这种懵懂的感觉确实让人回味。\r\n\r\n>    等待=放弃？\r\n\r\n>    高一时，认识了一位女孩，小小的个子，可爱的脸蛋……只因为当时座得很近，也很谈的来，后来便成为了朋友，再后来和她开始了电话联系、陪她逛了几次街…… 与她在一起真的很快乐，也留下了一段美好的记忆。当时并不敢相信小小的自己会喜欢上谁，也只是一直把她当成自己的一个好朋友。后来我发现自己确实喜欢上了她，但迫于身处的环境背景，我毅然决定将这份喜欢沉入自己的心底，或许等自己再大些，才把它拿出来，于是自己坏着这颗心，默默的等待……\r\n   \r\n>    后来，她离开了我们班，但还是在同一所学校同一年级，再后来听说她有了男朋友，当时我并不相信，直到大年三十的前一天我才亲眼接受了这个现实！\r\n\r\n>    现在的我并不觉得悲伤，因为当初选择等待时我就已明白这是一场赌局，现在我输了，但我在悲伤中站了起来，理性的我明白，在另一方面我仍然是个赢家！现实已成定局，我唯一能做的只是默默的祝她快乐！\r\n      \r\n>    后记：生活就是如此，我们不仅要学会如何去赌，更应学会乐观！祝和我有着同样遭遇的朋友们鼓起勇气面对生活。如果故事的主人能看见此文，千万不要悲伤，或许我有些自作多情，但我真心的祝你快乐，幸福！！\r\n   \r\n当时写到这里就结束了。不过后续发生的事情却让我感到人生像戏剧一样。\r\n\r\n大一结束之后就没有再见到故事的女主人翁，故事本应如此结束了，但是接下来的事情真的像小说说的一样。那时候已经是2009年了，我也离开了家乡来到了上海，去实现我自己的梦想。一个宁静周末的午后，QQ意外的闪动起来。另一半是另外一个高一时候的同学，和她简单的聊了一会儿之后，万万没想到的是，她把她的QQ号给了我。\r\n\r\n接下来，我把3年签的这种感觉告诉了她，她也说了些什么。后来，暑假里我们一聚在了一起，一起出去玩了一天。没有我们期待的那种感觉，于是这便成了最后一次见面。\r\n\r\n其实，真正的长大了才明白，那时候所谓的懵懂并不是什么爱情。\r\n\r\n这段小小的人生故事，我从未公开过，仅仅是口述的告诉了几个人，6年过去了，自己也慢慢的长大了，也懂得了什么是爱情、什么是友情。想想那错将友情当成爱情的年纪，确实很像那首歌唱的“十七岁那年的雨季/回忆起童年的点点滴滴/却发现成长已慢慢接近”。\r\n","pubtime":{"$date":1384344401770},"title":"懵懂的季节（原标题 “等待=放弃？ ” ）","visited":6415,"links":[["5284bfd167e841743e000001",{"present":0.025641025641025640136,"title":"曾经写给自己的信"}],["51d3db638ece70c438000002",{"present":0.025641025641025640136,"title":"IE6 select BUG:无法设置selected属性 未指明的错误"}],["51d3db3b8ece70c438000001",{"present":0.025641025641025640136,"title":"开张啦！"}]],"html":"<p>翻阅之前自己在网易博客上曾经写过的文字，发现有不少值得回味的东西，选择一些有感触的拿过来，算是对生命的一种回忆吧。</p>\n<p>这是我在高二的时候写下的一些文字，在此之前这篇文章未曾公开过。当时那个年级还搞不懂什么是爱情，什么是友情，但是这种懵懂的感觉确实让人回味。</p>\n<blockquote>\n<p>   等待=放弃？</p>\n<p>   高一时，认识了一位女孩，小小的个子，可爱的脸蛋……只因为当时座得很近，也很谈的来，后来便成为了朋友，再后来和她开始了电话联系、陪她逛了几次街…… 与她在一起真的很快乐，也留下了一段美好的记忆。当时并不敢相信小小的自己会喜欢上谁，也只是一直把她当成自己的一个好朋友。后来我发现自己确实喜欢上了她，但迫于身处的环境背景，我毅然决定将这份喜欢沉入自己的心底，或许等自己再大些，才把它拿出来，于是自己坏着这颗心，默默的等待……</p>\n<p>   后来，她离开了我们班，但还是在同一所学校同一年级，再后来听说她有了男朋友，当时我并不相信，直到大年三十的前一天我才亲眼接受了这个现实！</p>\n<p>   现在的我并不觉得悲伤，因为当初选择等待时我就已明白这是一场赌局，现在我输了，但我在悲伤中站了起来，理性的我明白，在另一方面我仍然是个赢家！现实已成定局，我唯一能做的只是默默的祝她快乐！</p>\n<p>   后记：生活就是如此，我们不仅要学会如何去赌，更应学会乐观！祝和我有着同样遭遇的朋友们鼓起勇气面对生活。如果故事的主人能看见此文，千万不要悲伤，或许我有些自作多情，但我真心的祝你快乐，幸福！！</p>\n</blockquote>\n<p>当时写到这里就结束了。不过后续发生的事情却让我感到人生像戏剧一样。</p>\n<p>大一结束之后就没有再见到故事的女主人翁，故事本应如此结束了，但是接下来的事情真的像小说说的一样。那时候已经是2009年了，我也离开了家乡来到了上海，去实现我自己的梦想。一个宁静周末的午后，QQ意外的闪动起来。另一半是另外一个高一时候的同学，和她简单的聊了一会儿之后，万万没想到的是，她把她的QQ号给了我。</p>\n<p>接下来，我把3年签的这种感觉告诉了她，她也说了些什么。后来，暑假里我们一聚在了一起，一起出去玩了一天。没有我们期待的那种感觉，于是这便成了最后一次见面。</p>\n<p>其实，真正的长大了才明白，那时候所谓的懵懂并不是什么爱情。</p>\n<p>这段小小的人生故事，我从未公开过，仅仅是口述的告诉了几个人，6年过去了，自己也慢慢的长大了，也懂得了什么是爱情、什么是友情。想想那错将友情当成爱情的年纪，确实很像那首歌唱的“十七岁那年的雨季/回忆起童年的点点滴滴/却发现成长已慢慢接近”。</p>\n"}
{"_id":{"$oid":"52bd036287e7903949000001"},"title":"怎样成长为一个优秀的 Web 前端开发工程师？","classid":"350","content":"在知乎上看到了这个问题，答得非常好，分享一下。\r\n\r\nWhat makes a good front end engineer?\r\n=====\r\n\r\n原博文地址：[http://www.nczonline.net/blog/2007/08/15/what-makes-a-good-front-end-engineer/](http://www.nczonline.net/blog/2007/08/15/what-makes-a-good-front-end-engineer/)\r\n\r\nNicholas C. Zakas谈怎样才能成为优秀的前端工程师：\r\n\r\n昨天，我负责了Yahoo!公司组织的一次面试活动，感触颇深的是其中的应聘者提问环节。我得说自己对应聘者们提出的大多数问题都相当失望。我希望听到一些对在Yahoo！工作充满激情的问题。在昨天的应聘者中，只有一个人的问题是我认为最好的，那个人问我：“你觉得怎么才能成为优秀的前端工程师？”我觉得很有必要把这个问题从面试房间里拿出来讨论一下。\r\n\r\n首先，前端工程师必须得掌握HTML、CSS和JavaScript。只懂其中一个或两个还不行，你必须对这三门语言都很熟悉。也不是说必须对这三门语言都非常精通，但你至少要能够运用它们完成大多数任务，而无需频繁地寻求别人的帮助。\r\n\r\n优秀的前端工程师应该具备快速学习能力。推动Web发展的技术并不是静止不动的，没错吧？我甚至可以说这些技术几乎每天都在变化，如果没有快速学习能力，你就跟不上Web发展的步伐。你必须不断提升自己，不断学习新技术、新模式；仅仅依靠今天的知识无法适应未来。Web的明天与今天必将有天壤之别，而你的工作就是要搞清楚如何通过自己的Web应用程序来体现这种翻天覆地的变化。\r\n\r\n计算机科学这个大门类下面的许多分支在人们眼中实际上都不外乎科学。但是，我们所说的前端不是什么科学，而是艺术。艺术家不仅要掌握谋生的技术，还要懂得如何运用。对同一个问题的解决方案在这种情况适用，在另一种情况下可能就不适用。对Web应用程序的前端而言，解决同一问题的方案经常会有很多。没有哪个方案是错的，但其中确实有一些是更合适的。优秀的前端工程师应该知道在什么情况下使用哪种方案更合适，而在什么情况下应该重新选择。\r\n\r\n优秀的前端工程师需要具备良好的沟通能力，因为你的工作与很多人的工作息息相关。在任何情况下，前端工程师至少都要满足下列四类客户的需求。\r\n\r\n> 产品经理——这些是负责策划应用程序的一群人。他们能够想象出怎样通过应用程序来满足用户需求，以及怎样通过他们设计的模式赚到钱（但愿如此）。一般来说，这些人追求的是丰富的功能。\r\n\r\n> UI设计师——这些人负责应用程序的视觉设计和交互模拟。他们关心的是用户对什么敏感、交互的一贯性以及整体的好用性。他们热衷于流畅靓丽但并不容易实现的用户界面。\r\n\r\n> 项目经理——这些人负责实际地运行和维护应用程序。项目管理的主要关注点，无外乎正常运行时间（uptime）——应用程序始终正常可用的时间、性能和截止日期。项目经理追求的目标往往是尽量保持事情的简单化，以及不在升级更新时引入新问题。\r\n\r\n> 最终用户——当然是应用程序的主要消费者。尽管我们不会经常与最终用户打交道，但他们的反馈意见至关重要；没人想用的应用程序毫无价值。最终用户要求最多的就是对个人有用的功能，以及竞争性产品所具备的功能。\r\n\r\n那么，前端工程师应该最关注哪些人的意见呢？答案是所有这四类人。优秀的前端工程师必须知道如何平衡这四类人的需求和预期，然后在此基础上拿出最佳解决方案。由于前端工程师处于与这四类人沟通的交汇点上，因此其沟通能力的重要性不言而喻。如果一个非常酷的新功能因为会影响前端性能，必须删繁就简，你怎么跟产品经理解释？再比如，假设某个设计如果不改回原方案可能会给应用程序造成负面影响，你怎么才能说服UI设计师？作为前端工程师，你必须了解每一类人的想法从何而来，必须能拿出所有各方都能接受的解决方案。从某种意义上说，优秀的前端工程师就像是一位大使，需要时刻抱着外交官的心态来应对每一天的工作。\r\n\r\n我告诫新来的前端工程师最多的一句话，就是不要在没有作出评估之前就随便接受某项任务。你必须始终记住，一定先搞清楚别人到底想让你干什么，不能简单地接受“这个功能有问题”之类的大概其的说法。而且，你还要确切地知道这个功能或设计的真正意图何在。“加一个按钮”之类的任务并不总意味着你最后会加一个按钮。还可能意味着你会找产品经理，问一问这个按钮有什么用处，然后再找UI设计师一块探讨按钮是不是最佳的交互手段。要成为优秀的前端工程师，这种沟通至关重要。\r\n\r\n无论从哪个方面讲，我都觉得前端工程师是计算机科学职业领域中最复杂的一个工种。绝大多数传统的编程思想已经不适用了，为了在多种平台中使用，多种技术都借鉴了大量软科学的知识和理念。成为优秀前端工程师所要具备的专业技术，涉及到广阔而复杂的领域，这些领域又会因为你最终必须服务的各方的介入而变得更加复杂。专业技术可能会引领你进入成为前端工程师的大门，但只有运用该技术创造的应用程序以及你跟他人并肩协同的能力，才会真正让你变得优秀。","visited":5538,"comment":0,"pubtime":{"$date":1388118882239},"links":[["51d3de558ece70c43800000b",{"present":0.081081081081081085582,"title":"前端工程师的价值体现在哪里?  "}],["51d3de828ece70c43800000e",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（一） "}],["53eb8e22b55b886a13000001",{"present":0.025641025641025640136,"title":"我是如何发布版本的"}],["51d3db3b8ece70c438000001",{"present":0.025641025641025640136,"title":"开张啦！"}]],"html":"<p>在知乎上看到了这个问题，答得非常好，分享一下。</p>\n<h1 id=\"what-makes-a-good-front-end-engineer-\">What makes a good front end engineer?</h1>\n<p>原博文地址：<a href=\"http://www.nczonline.net/blog/2007/08/15/what-makes-a-good-front-end-engineer/\">http://www.nczonline.net/blog/2007/08/15/what-makes-a-good-front-end-engineer/</a></p>\n<p>Nicholas C. Zakas谈怎样才能成为优秀的前端工程师：</p>\n<p>昨天，我负责了Yahoo!公司组织的一次面试活动，感触颇深的是其中的应聘者提问环节。我得说自己对应聘者们提出的大多数问题都相当失望。我希望听到一些对在Yahoo！工作充满激情的问题。在昨天的应聘者中，只有一个人的问题是我认为最好的，那个人问我：“你觉得怎么才能成为优秀的前端工程师？”我觉得很有必要把这个问题从面试房间里拿出来讨论一下。</p>\n<p>首先，前端工程师必须得掌握HTML、CSS和JavaScript。只懂其中一个或两个还不行，你必须对这三门语言都很熟悉。也不是说必须对这三门语言都非常精通，但你至少要能够运用它们完成大多数任务，而无需频繁地寻求别人的帮助。</p>\n<p>优秀的前端工程师应该具备快速学习能力。推动Web发展的技术并不是静止不动的，没错吧？我甚至可以说这些技术几乎每天都在变化，如果没有快速学习能力，你就跟不上Web发展的步伐。你必须不断提升自己，不断学习新技术、新模式；仅仅依靠今天的知识无法适应未来。Web的明天与今天必将有天壤之别，而你的工作就是要搞清楚如何通过自己的Web应用程序来体现这种翻天覆地的变化。</p>\n<p>计算机科学这个大门类下面的许多分支在人们眼中实际上都不外乎科学。但是，我们所说的前端不是什么科学，而是艺术。艺术家不仅要掌握谋生的技术，还要懂得如何运用。对同一个问题的解决方案在这种情况适用，在另一种情况下可能就不适用。对Web应用程序的前端而言，解决同一问题的方案经常会有很多。没有哪个方案是错的，但其中确实有一些是更合适的。优秀的前端工程师应该知道在什么情况下使用哪种方案更合适，而在什么情况下应该重新选择。</p>\n<p>优秀的前端工程师需要具备良好的沟通能力，因为你的工作与很多人的工作息息相关。在任何情况下，前端工程师至少都要满足下列四类客户的需求。</p>\n<blockquote>\n<p>产品经理——这些是负责策划应用程序的一群人。他们能够想象出怎样通过应用程序来满足用户需求，以及怎样通过他们设计的模式赚到钱（但愿如此）。一般来说，这些人追求的是丰富的功能。</p>\n<p>UI设计师——这些人负责应用程序的视觉设计和交互模拟。他们关心的是用户对什么敏感、交互的一贯性以及整体的好用性。他们热衷于流畅靓丽但并不容易实现的用户界面。</p>\n<p>项目经理——这些人负责实际地运行和维护应用程序。项目管理的主要关注点，无外乎正常运行时间（uptime）——应用程序始终正常可用的时间、性能和截止日期。项目经理追求的目标往往是尽量保持事情的简单化，以及不在升级更新时引入新问题。</p>\n<p>最终用户——当然是应用程序的主要消费者。尽管我们不会经常与最终用户打交道，但他们的反馈意见至关重要；没人想用的应用程序毫无价值。最终用户要求最多的就是对个人有用的功能，以及竞争性产品所具备的功能。</p>\n</blockquote>\n<p>那么，前端工程师应该最关注哪些人的意见呢？答案是所有这四类人。优秀的前端工程师必须知道如何平衡这四类人的需求和预期，然后在此基础上拿出最佳解决方案。由于前端工程师处于与这四类人沟通的交汇点上，因此其沟通能力的重要性不言而喻。如果一个非常酷的新功能因为会影响前端性能，必须删繁就简，你怎么跟产品经理解释？再比如，假设某个设计如果不改回原方案可能会给应用程序造成负面影响，你怎么才能说服UI设计师？作为前端工程师，你必须了解每一类人的想法从何而来，必须能拿出所有各方都能接受的解决方案。从某种意义上说，优秀的前端工程师就像是一位大使，需要时刻抱着外交官的心态来应对每一天的工作。</p>\n<p>我告诫新来的前端工程师最多的一句话，就是不要在没有作出评估之前就随便接受某项任务。你必须始终记住，一定先搞清楚别人到底想让你干什么，不能简单地接受“这个功能有问题”之类的大概其的说法。而且，你还要确切地知道这个功能或设计的真正意图何在。“加一个按钮”之类的任务并不总意味着你最后会加一个按钮。还可能意味着你会找产品经理，问一问这个按钮有什么用处，然后再找UI设计师一块探讨按钮是不是最佳的交互手段。要成为优秀的前端工程师，这种沟通至关重要。</p>\n<p>无论从哪个方面讲，我都觉得前端工程师是计算机科学职业领域中最复杂的一个工种。绝大多数传统的编程思想已经不适用了，为了在多种平台中使用，多种技术都借鉴了大量软科学的知识和理念。成为优秀前端工程师所要具备的专业技术，涉及到广阔而复杂的领域，这些领域又会因为你最终必须服务的各方的介入而变得更加复杂。专业技术可能会引领你进入成为前端工程师的大门，但只有运用该技术创造的应用程序以及你跟他人并肩协同的能力，才会真正让你变得优秀。</p>\n","like":1}
{"_id":{"$oid":"51dc0a01710a1c7c51000002"},"classid":"400","comment":4,"content":"匆匆忙忙把php的博客改成了nodejs的了，第一次做如此规模的改动。\r\n\r\n\r\n主要还是因为对PHP很陌生，node和平时吃饭的Javascript几乎一样，所以还是果断的放弃php改成屌丝利器node，前前后后拖了将近半年的时间，然后实在看不下去了，利用D2论坛前半个月的空闲时间突击了一把，不管好坏至少现在是能将就这用起来了。\r\n\r\n\r\n那么在这些用node和mongo的日子里，确实学到了不少，知道了页面路由怎么去做，深入了解了HTTP协议什么200、301、304、403、404等等，确实也成长了不少，哈哈，至少是筹码加了不少，嘿嘿，喜欢这种成长的感觉。\r\n\r\n\r\n当然了，到目前为止，bug无数，体验烂到极致，不过呢我有再继续加油哦，Mofei会不断的去完善她，不断的去装饰好自己的家，我需要的是些许时间~ 挺我哦~","pubtime":{"$date":1373374977320},"title":"新版博客的说明，我在加油~记得挺我:)","visited":29950,"links":[["533904da1ba845cb37000002",{"present":0.025641025641025640136,"title":"node.js socket 高并发导致的消息合并成一条的解决方案"}]],"html":"<p>匆匆忙忙把php的博客改成了nodejs的了，第一次做如此规模的改动。</p>\n<p>主要还是因为对PHP很陌生，node和平时吃饭的Javascript几乎一样，所以还是果断的放弃php改成屌丝利器node，前前后后拖了将近半年的时间，然后实在看不下去了，利用D2论坛前半个月的空闲时间突击了一把，不管好坏至少现在是能将就这用起来了。</p>\n<p>那么在这些用node和mongo的日子里，确实学到了不少，知道了页面路由怎么去做，深入了解了HTTP协议什么200、301、304、403、404等等，确实也成长了不少，哈哈，至少是筹码加了不少，嘿嘿，喜欢这种成长的感觉。</p>\n<p>当然了，到目前为止，bug无数，体验烂到极致，不过呢我有再继续加油哦，Mofei会不断的去完善她，不断的去装饰好自己的家，我需要的是些许时间~ 挺我哦~</p>\n","like":1}
{"_id":{"$oid":"533904da1ba845cb37000002"},"title":"node.js socket 高频率发消息导致的消息合并成一条的解决方案","classid":"50","content":"最近在完成node的一个socket实现过程中，发现了很神奇的一件事情。\r\n\r\n过程是这样的，我们用node创建了一个server，然后监听该server的“data”事件，如下：\r\n\r\n``` javascript\r\nnet.createServer(function(socket) {\r\n    sock.on('data', function(data) {\r\n        //得到data之后进行JSON格式化处理\r\n        JSON.parse(data)\r\n    }\r\n}).listen(port, ip)\r\n```\r\n\r\n经过测试之后，我们发现一切正常，窃喜之后突然得到了这样的一个噩耗，在高并发的情况下该方法会直接报错，然后中断。\r\n\r\n经过检查发现原来是data事件的处理上的一个问题，正常的情况下data接到的数据应该如下\r\n\r\n    {\"data\":\"123\"}\r\n    \r\n但是当我们连续向该socket发送请求的时候，会发现，只要间隔时间足够短，两条消息就会合并在一起\r\n\r\n    {\"data\":\"123\"}{\"data\":\"123\"}\r\n    \r\n这时候进行JSON.parse直然会报错。\r\n\r\n问题的原因找到了，但是如何去解决呢？\r\n\r\n我们想到了几个方案：\r\n\r\n1. 限制单个data之间的间隔时间。\r\n2. 对返回的值进行处理。\r\n\r\n第一种方法简单粗暴，通过发送的时候吧所有的发送请求设置一定的时间间隔，但是！这种方法绝对是彻彻底底的反人类。\r\n\r\n于是通过仔细观察发现了这样的规律，由于socket遵循tcp协议，所以收到的最小单位一定是一条完整的json，这样的情况下我们完全不需要担心收到半条的情况。接下来就可以全力处理多条消息合在一起的情况了。\r\n\r\n实验了各种方法之后，我们采取了下面的正则来处理。\r\n\r\n    .match(/(\\{.+?\\})(?={|$)/g)\r\n\r\n关键点是这个正则 “ /(\\{.+?\\})(?={|$)/g ”，他能匹配单个的JSON字符串， 专业术语叫 “零宽断言” ， 关于 “零宽断言” 后面会发文章单独说明。\r\n\r\n这样匹配出来之后，接下来的事情就好办了，你可以用任何方法单独处理取到的每一个JSON了。","visited":6888,"comment":13,"pubtime":{"$date":1396245722598},"links":[["5524f05cfd9753d106000001",{"present":0.081081081081081085582,"title":"Window.postMessage() HTML5 跨域解决方案"}],["53a9475819a5a13617000001",{"present":0.025641025641025640136,"title":"Javascript获取服务器系统时间"}],["51dc0a01710a1c7c51000002",{"present":0.025641025641025640136,"title":"新版博客的说明，我在加油~记得挺我:)"}]],"html":"<p>最近在完成node的一个socket实现过程中，发现了很神奇的一件事情。</p>\n<p>过程是这样的，我们用node创建了一个server，然后监听该server的“data”事件，如下：</p>\n<pre><code class=\"lang-javascript\">net.createServer(function(socket) {\n    sock.on(&#39;data&#39;, function(data) {\n        //得到data之后进行JSON格式化处理\n        JSON.parse(data)\n    }\n}).listen(port, ip)\n</code></pre>\n<p>经过测试之后，我们发现一切正常，窃喜之后突然得到了这样的一个噩耗，在高并发的情况下该方法会直接报错，然后中断。</p>\n<p>经过检查发现原来是data事件的处理上的一个问题，正常的情况下data接到的数据应该如下</p>\n<pre><code>{&quot;data&quot;:&quot;123&quot;}\n</code></pre><p>但是当我们连续向该socket发送请求的时候，会发现，只要间隔时间足够短，两条消息就会合并在一起</p>\n<pre><code>{&quot;data&quot;:&quot;123&quot;}{&quot;data&quot;:&quot;123&quot;}\n</code></pre><p>这时候进行JSON.parse直然会报错。</p>\n<p>问题的原因找到了，但是如何去解决呢？</p>\n<p>我们想到了几个方案：</p>\n<ol>\n<li>限制单个data之间的间隔时间。</li>\n<li>对返回的值进行处理。</li>\n</ol>\n<p>第一种方法简单粗暴，通过发送的时候吧所有的发送请求设置一定的时间间隔，但是！这种方法绝对是彻彻底底的反人类。</p>\n<p>于是通过仔细观察发现了这样的规律，由于socket遵循tcp协议，所以收到的最小单位一定是一条完整的json，这样的情况下我们完全不需要担心收到半条的情况。接下来就可以全力处理多条消息合在一起的情况了。</p>\n<p>实验了各种方法之后，我们采取了下面的正则来处理。</p>\n<pre><code>.match(/(\\{.+?\\})(?={|$)/g)\n</code></pre><p>关键点是这个正则 “ /({.+?})(?={|$)/g ”，他能匹配单个的JSON字符串， 专业术语叫 “零宽断言” ， 关于 “零宽断言” 后面会发文章单独说明。</p>\n<p>这样匹配出来之后，接下来的事情就好办了，你可以用任何方法单独处理取到的每一个JSON了。</p>\n"}
{"_id":{"$oid":"52288399917d2e280e000001"},"classid":"100","comment":0,"content":"无意中翻到两年半前的一篇文章，有点感触，分享给大家。\r\n\r\n### 给正在实习和将要实习的大学生——实习经验分享 \r\n#### 2011-03-30 20:23:28\r\n\r\n\r\n一零年十月离开学校到现在将近大半年的时间过去了，我的工作也从最初的一个六七人的私企变成了现在的准国企。一路走来，虽然没有遇到所谓的\"暴风骤雨\"但也不是那么的风平浪静。\r\n\r\n#### 第一份实习工作——人生的第二所大学\r\n\r\n第一份工作做什么绝对不会影响你的发展，但是第一份工作中的工作态度绝对会影响你以后的职业生涯。对于刚刚走出学校踏入社会的大学生来说，不论你在学校表现多出色，不论你是不是学生干部，大家都是站在同一起跑线上的，因为第一份工作很多东西是你在大学里不熟悉的，甚至是听都没听过的，这里你所要做的是，了解自己以后发展的方向，以及该方向所需的知识，然后去利用这第一份工作中的业余时间去学习你所需的一切，这个过程是痛苦的，但是见效是非常快的，也正事如此我称之为人生的第二所大学。\r\n\r\n我的专业是计算机多媒体技术，第一份工作却是在一家陶瓷贸易公司负责网站的设计制作，关于网站在大学里也只是粗描淡些的学过一点，最多能做做网站的效果图，至于什么是后台，如何搭建动态网页，完全相当于一个小学生，于是我利用了所有的工作之外的时间疯狂的去看asp+access网站的设计……两个月后的一天，当我做的这个网站正式上线以后，心里的滋味酸甜苦辣都有，当然最多的是欣慰，在惊叹于自己能在这么短的时间内学会在学校要花上半年甚至是一年才能学会的课程的同时，也深深的体味到了\"压力是最大的动力\"。\r\n\r\n#### 追求——当别人开始说你是疯子的时候，你离成功就不远了\r\n\r\n 实习期间，追求这两个字也深深的影响着我，作为实习生，在工作一两个月之后，应该要明白自己为什么工作，自己想要的是什么，然后为之去奋斗。\r\n\r\n在我疯狂的学会了asp动态网页技术之后，我发现现在主流的动态网页技术是PHP，去了不少招聘会，看了不少网站，得出一个结论单单的asp是不够用的，于是我开始考虑着手去学习PHP，跟朋友说了我想换一个工作，去接触一下PHP，朋友说\"你疯了，现在有个不错的工作，工资和工作环境都很不错，而且还分有临时的住房，居然还想着换工作\"，再三考虑我向一个要求比较高的公司投出了我的简历，本来是抱着试试看的心里，没想到很快就收到offer，虽然职位是美工，但是这里的学习氛围很好，公司会定期的买一些书籍来供员工学习。这样我依然可以利用业余时间去学习PHP，以及和公司的PHP程序员交流PHP经验。所以只要你敢于追求，并为之\"疯狂\"的奋斗的话，你离成功就不远了。\r\n\r\n#### 工作态度——把一切平凡的事做好即不平凡，把一切简单的事做好即不简单。\r\n\r\n很对在学校表现突出的人，往往对公司的要求很高，甚至有人会想直接找个管理级的工作，认为这样才能体现出自己的价值。但是现实是你是一个毫无工作经验的，而且还是未毕业的一个学生，又有哪家企业会让你直接做产品经理、项目经理呢？\r\n\r\n抱怨，无休止的抱怨是我见过的最多的一种负面心情，其实，不论你现在做的是什么工作，把一切平凡的事做好即不平凡，把一切简单的事做好即不简单。对于企业来说能做好每一件小事的人，才是最有价值的人。\r\n\r\n#### 最后是给仍然在找工作，和将要实习的朋友们的一些建议：\r\n\r\n> + 第一份是什么不重要，重要的是你能学到什么。\r\n> + 要疯狂，带着狂热去工作、学习新的知识。\r\n> + 别轻易进入一家你不了解的企业，但也别轻易放弃一家看好你的企业。\r\n> + 做好自己的工作，哪怕它是微乎其微的，因为你实在没有可以炫耀的资本。\r\n> + 给自己一个目标，实习期满自己要到达一个什么样的高度。\r\n","pubtime":{"$date":1378386841606},"title":"给正在实习和将要实习的大学生——实习经验分享","visited":40634,"links":[["51d3de828ece70c43800000e",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（一） "}],["5284bfd167e841743e000001",{"present":0.025641025641025640136,"title":"曾经写给自己的信"}],["51d3db7f8ece70c438000003",{"present":0.025641025641025640136,"title":"“登陆网站”还是“登录网站”"}],["51d3dfbb8ece70c438000010",{"present":0.025641025641025640136,"title":"99%的人不知道或者不用的7大成功秘诀"}]],"html":"<p>无意中翻到两年半前的一篇文章，有点感触，分享给大家。</p>\n<h3 id=\"-\">给正在实习和将要实习的大学生——实习经验分享</h3>\n<h4 id=\"2011-03-30-20-23-28\">2011-03-30 20:23:28</h4>\n<p>一零年十月离开学校到现在将近大半年的时间过去了，我的工作也从最初的一个六七人的私企变成了现在的准国企。一路走来，虽然没有遇到所谓的&quot;暴风骤雨&quot;但也不是那么的风平浪静。</p>\n<h4 id=\"-\">第一份实习工作——人生的第二所大学</h4>\n<p>第一份工作做什么绝对不会影响你的发展，但是第一份工作中的工作态度绝对会影响你以后的职业生涯。对于刚刚走出学校踏入社会的大学生来说，不论你在学校表现多出色，不论你是不是学生干部，大家都是站在同一起跑线上的，因为第一份工作很多东西是你在大学里不熟悉的，甚至是听都没听过的，这里你所要做的是，了解自己以后发展的方向，以及该方向所需的知识，然后去利用这第一份工作中的业余时间去学习你所需的一切，这个过程是痛苦的，但是见效是非常快的，也正事如此我称之为人生的第二所大学。</p>\n<p>我的专业是计算机多媒体技术，第一份工作却是在一家陶瓷贸易公司负责网站的设计制作，关于网站在大学里也只是粗描淡些的学过一点，最多能做做网站的效果图，至于什么是后台，如何搭建动态网页，完全相当于一个小学生，于是我利用了所有的工作之外的时间疯狂的去看asp+access网站的设计……两个月后的一天，当我做的这个网站正式上线以后，心里的滋味酸甜苦辣都有，当然最多的是欣慰，在惊叹于自己能在这么短的时间内学会在学校要花上半年甚至是一年才能学会的课程的同时，也深深的体味到了&quot;压力是最大的动力&quot;。</p>\n<h4 id=\"-\">追求——当别人开始说你是疯子的时候，你离成功就不远了</h4>\n<p> 实习期间，追求这两个字也深深的影响着我，作为实习生，在工作一两个月之后，应该要明白自己为什么工作，自己想要的是什么，然后为之去奋斗。</p>\n<p>在我疯狂的学会了asp动态网页技术之后，我发现现在主流的动态网页技术是PHP，去了不少招聘会，看了不少网站，得出一个结论单单的asp是不够用的，于是我开始考虑着手去学习PHP，跟朋友说了我想换一个工作，去接触一下PHP，朋友说&quot;你疯了，现在有个不错的工作，工资和工作环境都很不错，而且还分有临时的住房，居然还想着换工作&quot;，再三考虑我向一个要求比较高的公司投出了我的简历，本来是抱着试试看的心里，没想到很快就收到offer，虽然职位是美工，但是这里的学习氛围很好，公司会定期的买一些书籍来供员工学习。这样我依然可以利用业余时间去学习PHP，以及和公司的PHP程序员交流PHP经验。所以只要你敢于追求，并为之&quot;疯狂&quot;的奋斗的话，你离成功就不远了。</p>\n<h4 id=\"-\">工作态度——把一切平凡的事做好即不平凡，把一切简单的事做好即不简单。</h4>\n<p>很对在学校表现突出的人，往往对公司的要求很高，甚至有人会想直接找个管理级的工作，认为这样才能体现出自己的价值。但是现实是你是一个毫无工作经验的，而且还是未毕业的一个学生，又有哪家企业会让你直接做产品经理、项目经理呢？</p>\n<p>抱怨，无休止的抱怨是我见过的最多的一种负面心情，其实，不论你现在做的是什么工作，把一切平凡的事做好即不平凡，把一切简单的事做好即不简单。对于企业来说能做好每一件小事的人，才是最有价值的人。</p>\n<h4 id=\"-\">最后是给仍然在找工作，和将要实习的朋友们的一些建议：</h4>\n<blockquote>\n<ul>\n<li>第一份是什么不重要，重要的是你能学到什么。</li>\n<li>要疯狂，带着狂热去工作、学习新的知识。</li>\n<li>别轻易进入一家你不了解的企业，但也别轻易放弃一家看好你的企业。</li>\n<li>做好自己的工作，哪怕它是微乎其微的，因为你实在没有可以炫耀的资本。</li>\n<li>给自己一个目标，实习期满自己要到达一个什么样的高度。</li>\n</ul>\n</blockquote>\n"}
{"_id":{"$oid":"52fefd3ebd0c693905000007"},"title":"未来的6大高薪职业","classid":"500","content":"《财富》杂志采访了《与未来沟通》一书的作者 Thomas Frey，后者给出了他认为未来发展迅速的 6 大职业。\r\n\r\n---\r\n\r\n### 1、物流师\r\n\r\n物流师利用复杂的软件来跟踪货物和产品的流动，然后集思广益想方设法让整个流通过程更加顺畅高效。有些物流师甚至还要跟政府机构合作来帮助清理自然灾害。\r\n\r\n入选理由：放眼全球经济，所有的公司都在致力于生产流水化和削减成本，这些公司会雇物流师来做这个。美国劳工部预计到 2020 前该职位的年增长率将达到 26%，平均薪资达 71910 美元。\r\n\r\nFrey 认为现在物流师正处在换挡提速期。他预计这个职业很快就会从货物拓展到技术更先进的国防工业，如无人机，以及公共事业工程项目，如无人驾驶汽车。\r\n\r\n---\r\n\r\n### 2、道德黑客\r\n\r\n黑客怎样才能变得有道德？事实上现在很多公司都雇这些专家来有目的地黑自己的系统，以便抢在那些不那么讲道德的同行之前找出安全隐患。道德黑客甚至现在还有认证（Certified Ethical Hacker，CEH），CEH 的任务是建立网络策略，入侵检测和病毒开发。\r\n\r\n入选理由：平均年薪 92200 美元。有人担心道德黑客会变“流氓”，把自己的技能用到不好的地方，也正因为这一点使得这个职业还不能成为主流。Frey 说，要想让道德黑客广为接受，需要正式区分什么东西是道德的，什么是不道德的。比方说道德黑客有无权利分发自己通过该职位获得的信息？这场隐私与透明之争不会很快平息，基本法则有待确立。\r\n\r\n---\r\n\r\n### 3、保险精算师\r\n\r\n你能够把风险预测转化为数字吗？保险精算师就可以。保险精算师利用数学和统计数字来为保险公司、银行、咨询机构及政府分析风险的金融影响。\r\n\r\n入选理由：平均年薪 87650 美元，未来只会更高。预计未来 7 年的增长率达 27%。Frey 说保险精算师的技能可以适合很多地方。尽管保险公司往往是他们的去处，但 Frey 预计医药公司也需要这些人。他说医疗保健业已经为许多大变化做好准备，只是还看不到而已。\r\n\r\n---\r\n\r\n### 4、流行病学家\r\n\r\n现在你已经知道禽流感源自鸟类，但是谁是第一个知道的？流行病学家。这些疾病巫师的工作是发现各种疾病爆发的原因，评估灭菌技术和过程，想出治疗改进方法，为将疾病和感染封锁在医院、制药公司及研究实验室内制定协议。\r\n\r\n入选理由：美国劳工部预计该职位到 2020 年前的年增长率高达 35.8%，平均年薪为 64220 美元。Frey 预计该领域未来将更多地从“物联网”中受益。如智能微尘。Frey 预计，未来含有微型传感器的智能微尘能用到人类身上，帮助流行病学家查明各种疾病的前兆。\r\n\r\n---\r\n\r\n### 5、前端工程师\r\n\r\n按一下按钮就能把你带到另一个页面。简单吧？但得有人对这个按钮编程才能如你所愿，这件事情却不简单。前端工程师，或者叫前端 web 开发者创建了你每天在网上看到的一切。除了编程以外，前端开发者还必须知道怎样做才能对用户最好。\r\n\r\n入选理由：未来 7 年的需求年增长率为 22%，高于软件开发者 14% 的增长率。平均年薪 81670 美元。Frey 说该职位超级关键，因为在未来与网上客户的交互决定了公司的成功。谁能够让网站更加直观高效？当然是前端工程师了。\r\n\r\n---\r\n\r\n### 6、食品化学家\r\n\r\n如何做出完美的蛋糕？问食品化学家。这些专家的任务是开放并改进食品的味道和口感。\r\n\r\n入选理由：Frey 说未来该职业会非常热门。他把这一切都归因于3D打印，预计我们会自己烹饪食品：只需将配料“墨盒”置入打印机，晚餐即可“打印”出炉。而这些要归功于制作这些“墨盒”的食品化学家。Frey 说 NASA 已经实施了一项研究去了解 3D 食品打印机对太空任务的影响。食品化学家博士的平均年薪介于 50000-100000 美元之间。但是民以食为天，未来这个职业的前途将一片美好。Frey 说未来我们的古怪饮食会像本周时尚一样，引领新的市场和需求。","visited":5729,"comment":0,"pubtime":{"$date":1392442686731},"links":[["5284bfd167e841743e000001",{"present":0.025641025641025640136,"title":"曾经写给自己的信"}]],"html":"<p>《财富》杂志采访了《与未来沟通》一书的作者 Thomas Frey，后者给出了他认为未来发展迅速的 6 大职业。</p>\n<hr>\n<h3 id=\"1-\">1、物流师</h3>\n<p>物流师利用复杂的软件来跟踪货物和产品的流动，然后集思广益想方设法让整个流通过程更加顺畅高效。有些物流师甚至还要跟政府机构合作来帮助清理自然灾害。</p>\n<p>入选理由：放眼全球经济，所有的公司都在致力于生产流水化和削减成本，这些公司会雇物流师来做这个。美国劳工部预计到 2020 前该职位的年增长率将达到 26%，平均薪资达 71910 美元。</p>\n<p>Frey 认为现在物流师正处在换挡提速期。他预计这个职业很快就会从货物拓展到技术更先进的国防工业，如无人机，以及公共事业工程项目，如无人驾驶汽车。</p>\n<hr>\n<h3 id=\"2-\">2、道德黑客</h3>\n<p>黑客怎样才能变得有道德？事实上现在很多公司都雇这些专家来有目的地黑自己的系统，以便抢在那些不那么讲道德的同行之前找出安全隐患。道德黑客甚至现在还有认证（Certified Ethical Hacker，CEH），CEH 的任务是建立网络策略，入侵检测和病毒开发。</p>\n<p>入选理由：平均年薪 92200 美元。有人担心道德黑客会变“流氓”，把自己的技能用到不好的地方，也正因为这一点使得这个职业还不能成为主流。Frey 说，要想让道德黑客广为接受，需要正式区分什么东西是道德的，什么是不道德的。比方说道德黑客有无权利分发自己通过该职位获得的信息？这场隐私与透明之争不会很快平息，基本法则有待确立。</p>\n<hr>\n<h3 id=\"3-\">3、保险精算师</h3>\n<p>你能够把风险预测转化为数字吗？保险精算师就可以。保险精算师利用数学和统计数字来为保险公司、银行、咨询机构及政府分析风险的金融影响。</p>\n<p>入选理由：平均年薪 87650 美元，未来只会更高。预计未来 7 年的增长率达 27%。Frey 说保险精算师的技能可以适合很多地方。尽管保险公司往往是他们的去处，但 Frey 预计医药公司也需要这些人。他说医疗保健业已经为许多大变化做好准备，只是还看不到而已。</p>\n<hr>\n<h3 id=\"4-\">4、流行病学家</h3>\n<p>现在你已经知道禽流感源自鸟类，但是谁是第一个知道的？流行病学家。这些疾病巫师的工作是发现各种疾病爆发的原因，评估灭菌技术和过程，想出治疗改进方法，为将疾病和感染封锁在医院、制药公司及研究实验室内制定协议。</p>\n<p>入选理由：美国劳工部预计该职位到 2020 年前的年增长率高达 35.8%，平均年薪为 64220 美元。Frey 预计该领域未来将更多地从“物联网”中受益。如智能微尘。Frey 预计，未来含有微型传感器的智能微尘能用到人类身上，帮助流行病学家查明各种疾病的前兆。</p>\n<hr>\n<h3 id=\"5-\">5、前端工程师</h3>\n<p>按一下按钮就能把你带到另一个页面。简单吧？但得有人对这个按钮编程才能如你所愿，这件事情却不简单。前端工程师，或者叫前端 web 开发者创建了你每天在网上看到的一切。除了编程以外，前端开发者还必须知道怎样做才能对用户最好。</p>\n<p>入选理由：未来 7 年的需求年增长率为 22%，高于软件开发者 14% 的增长率。平均年薪 81670 美元。Frey 说该职位超级关键，因为在未来与网上客户的交互决定了公司的成功。谁能够让网站更加直观高效？当然是前端工程师了。</p>\n<hr>\n<h3 id=\"6-\">6、食品化学家</h3>\n<p>如何做出完美的蛋糕？问食品化学家。这些专家的任务是开放并改进食品的味道和口感。</p>\n<p>入选理由：Frey 说未来该职业会非常热门。他把这一切都归因于3D打印，预计我们会自己烹饪食品：只需将配料“墨盒”置入打印机，晚餐即可“打印”出炉。而这些要归功于制作这些“墨盒”的食品化学家。Frey 说 NASA 已经实施了一项研究去了解 3D 食品打印机对太空任务的影响。食品化学家博士的平均年薪介于 50000-100000 美元之间。但是民以食为天，未来这个职业的前途将一片美好。Frey 说未来我们的古怪饮食会像本周时尚一样，引领新的市场和需求。</p>\n"}
{"_id":{"$oid":"52300d0063c944475b000001"},"title":"Atwood定律：“任何可以使用JavaScript来编写的应用，最终会由JavaScript编写。”","classid":"100","content":"Atwood’s Law是Jeff Atwood在2007年提出的：“any application that can be written in JavaScript, will eventually be written in JavaScript.”\r\n\r\n声明：本文不是Atwood’s Law的软文也不是javascript的鼓吹，而是想告诉大家，浏览器可以做更多的事情。\r\n\r\n如果你不知道Jeff Atwood是谁，这并不重要，重要的是这个定律。\r\n\r\nKK认为将来，我们关注的是Screen（屏幕），各种屏幕，PC，手机，平板，车载TV，电视等等等，刚提出Screen时，估计没多少人能完全理解，但是现在，我们回顾周围，你获取的各种信息，有多少不是来自屏幕？\r\n\r\n回正题，看看Atwood定律，通俗来说，任何可以使用javascript来实现的应用都最终都会使用javascript实现，貌似有些废话。javascript主要运行环境是浏览器（node.js，mongodb 函数之类的除外），那么今天我们来聊聊是不是所有（几乎）事情都可以通过浏览器完成。\r\n\r\n我们来看看现在浏览器都能做什么：\r\n\r\nWeb App:随着移动互联网爆发，各种App铺天盖地；与此同时，另外一个焦点也一直吸引着无数眼球：HTML5。由此引发一个话题“移动App将死，Web App称王”。随着HTML5标准推进，有更多的javascript API可以应用到app中，引发这个话题也是情理之中，至于谁让谁死还有待验证。\r\n\r\n使用javascript重写的应用：做为Emacs党程序员，也许还会配置各种插件调教其为称手的IDE。当我看到一个2004年就出现并托管在github上的在线Emacs时，已经不镇定了。包括后来出现的更逼真的YMacs。\r\n\r\n这样的例子还有很多，在线mind管理，在线流程图，制作原型图，甘特图，项目管理等，你还需要本地app么，反正我已经转到线上了。\r\n\r\n越来越多在线IDE工具：Cloud9 IDE, Koding,codeanywhere等等等等。他们可以结合github托管代码，通过heroku（也许GAE）实现部署，越来越多的事情可以不在本地完成，因此很多老外程序员可以NB哄哄的说：“我的工作环境只需要一台ipad。”\r\n\r\n在线办公：google drive， skydrive，CRM，财务管理，票据管理已经很多很多了，我现在的机器上就没有office工具，完全使用google docs来处理文字和表格。\r\n\r\n成百上千的javascript开发框架/工具：JQuery，Sentan，Dojo，Prototype，Yahoo的YUI，还有Batman（hoho，眼熟？），google的Closure等等，在OSChina收录的JQuery插件就超过1000条记录。加上PhoneGap之流对Web App登陆移动端的推波助澜，OMG，你应该再理解理解Atwood’s Law.\r\n\r\n一则新闻： [JavaScript Git的Kickstarter项目仅28小时达到集资目标，git也未能幸免](http://www.infoq.com/cn/news/2013/03/git-in-javascript)，那么下一个是谁呢？操作系统？不要开玩笑，操作系统是第一个沦陷的，忘记webOS了么？除了被plam买个hp的改名的webOS，还有运行在浏览器的yuanOS，webQQ其实已经是一个webOS了。\r\n\r\n图片处理也不是问题了，腾讯前端团队推出的 AlloyImage ，你认为在线PS还远么？\r\n\r\n废话这么多，到底这个定律是否适用，还请大家一起验证吧。\r\n\r\n原文：[Atwood定律：“任何可以使用JavaScript来编写的应用，最终会由JavaScript编写。”](http://www.iterduo.com/0401-atwood.html)","visited":32258,"comment":2,"pubtime":{"$date":1378880768564},"links":[["51d3de828ece70c43800000e",{"present":0.025641025641025640136,"title":"Internet Explorer 10 兼容性白皮书（一） "}],["51d3dfe68ece70c438000013",{"present":0.025641025641025640136,"title":"javascript获取元素的宽度、高度"}]],"html":"<p>Atwood’s Law是Jeff Atwood在2007年提出的：“any application that can be written in JavaScript, will eventually be written in JavaScript.”</p>\n<p>声明：本文不是Atwood’s Law的软文也不是javascript的鼓吹，而是想告诉大家，浏览器可以做更多的事情。</p>\n<p>如果你不知道Jeff Atwood是谁，这并不重要，重要的是这个定律。</p>\n<p>KK认为将来，我们关注的是Screen（屏幕），各种屏幕，PC，手机，平板，车载TV，电视等等等，刚提出Screen时，估计没多少人能完全理解，但是现在，我们回顾周围，你获取的各种信息，有多少不是来自屏幕？</p>\n<p>回正题，看看Atwood定律，通俗来说，任何可以使用javascript来实现的应用都最终都会使用javascript实现，貌似有些废话。javascript主要运行环境是浏览器（node.js，mongodb 函数之类的除外），那么今天我们来聊聊是不是所有（几乎）事情都可以通过浏览器完成。</p>\n<p>我们来看看现在浏览器都能做什么：</p>\n<p>Web App:随着移动互联网爆发，各种App铺天盖地；与此同时，另外一个焦点也一直吸引着无数眼球：HTML5。由此引发一个话题“移动App将死，Web App称王”。随着HTML5标准推进，有更多的javascript API可以应用到app中，引发这个话题也是情理之中，至于谁让谁死还有待验证。</p>\n<p>使用javascript重写的应用：做为Emacs党程序员，也许还会配置各种插件调教其为称手的IDE。当我看到一个2004年就出现并托管在github上的在线Emacs时，已经不镇定了。包括后来出现的更逼真的YMacs。</p>\n<p>这样的例子还有很多，在线mind管理，在线流程图，制作原型图，甘特图，项目管理等，你还需要本地app么，反正我已经转到线上了。</p>\n<p>越来越多在线IDE工具：Cloud9 IDE, Koding,codeanywhere等等等等。他们可以结合github托管代码，通过heroku（也许GAE）实现部署，越来越多的事情可以不在本地完成，因此很多老外程序员可以NB哄哄的说：“我的工作环境只需要一台ipad。”</p>\n<p>在线办公：google drive， skydrive，CRM，财务管理，票据管理已经很多很多了，我现在的机器上就没有office工具，完全使用google docs来处理文字和表格。</p>\n<p>成百上千的javascript开发框架/工具：JQuery，Sentan，Dojo，Prototype，Yahoo的YUI，还有Batman（hoho，眼熟？），google的Closure等等，在OSChina收录的JQuery插件就超过1000条记录。加上PhoneGap之流对Web App登陆移动端的推波助澜，OMG，你应该再理解理解Atwood’s Law.</p>\n<p>一则新闻： <a href=\"http://www.infoq.com/cn/news/2013/03/git-in-javascript\">JavaScript Git的Kickstarter项目仅28小时达到集资目标，git也未能幸免</a>，那么下一个是谁呢？操作系统？不要开玩笑，操作系统是第一个沦陷的，忘记webOS了么？除了被plam买个hp的改名的webOS，还有运行在浏览器的yuanOS，webQQ其实已经是一个webOS了。</p>\n<p>图片处理也不是问题了，腾讯前端团队推出的 AlloyImage ，你认为在线PS还远么？</p>\n<p>废话这么多，到底这个定律是否适用，还请大家一起验证吧。</p>\n<p>原文：<a href=\"http://www.iterduo.com/0401-atwood.html\">Atwood定律：“任何可以使用JavaScript来编写的应用，最终会由JavaScript编写。”</a></p>\n"}
{"_id":{"$oid":"51d3dfc98ece70c438000011"},"classid":"400","comment":0,"content":"江苏卫视近来登陆了全球最大的视频网站YouTube，并将许多节目内容都上传到了YouTube上。\r\n\r\n江苏卫视近来登陆了全球最大的视频网站YouTube（因众所周知的原因，国内网友无法访问），并将许多节目内容都上传到了YouTube上。此外，江苏卫视还在旗下的《非诚勿扰》节目中为新开的YouTube频道做广告，并植入了全球最大的搜索引擎谷歌的广告。\r\n\r\n![江苏卫视登陆YouTube](http://i2.hexunimg.cn/2012-11-26/148367410.jpg)\r\n江苏卫视登陆YouTube\r\n\r\n据悉，江苏卫视在YouTube频道上的节目更新非常快。以《非诚勿扰》为例，该节目已经到11月24日的那期节目。显然，江苏卫视开通YouTube频道，可提高江苏卫视在华人领域的收视率与影响力。\r\n\r\n![《非诚勿扰》更新速度很快](http://i8.hexunimg.cn/2012-11-26/148367411.jpg)\r\n《非诚勿扰》更新速度很快\r\n\r\n不过，眼尖的网友发现在《非诚勿扰》的广告中，还植入了谷歌的广告。江苏卫视在《非诚勿扰》中为其YouTube频道做广告，并让用户用谷歌搜索YouTube，然后再搜索《非诚勿扰》即可观看最新节目。\r\n\r\n![《非诚勿扰》广告宣传谷歌](http://i9.hexunimg.cn/2012-11-26/148367412.jpg)\r\n《非诚勿扰》广告宣传谷歌\r\n\r\n对于这则广告中植入广告的做法，不少网友持有不同的看法。有的网友表示对江苏卫士在广告中宣传谷歌的做法感到奇怪，并认为二者的结合方式僵硬、契合度不高，令人难以接受。而有的网友则认为没啥好奇怪的，并表示YouTube本身就是谷歌旗下的，江苏卫视在广告中突出谷歌、YouTube也是无可厚非的。不过，更多的网友则表示，江苏卫视的YouTube频道广告的投放范围不太恰当，毕竟国内大多地区都无法访问YouTube，这则广告更适合投放到海外。\r\n\r\n目前，在微软、苹果都极力为旗下产品大力宣传、大打广告营销战的大背景下，江苏卫视的这则广告对于谷歌的宣传而言，绝对是大大有益的。","pubtime":{"$date":1354454658122},"title":"Youtube Google要回来了？谷歌逆袭？非诚勿扰YouTube广告宣传谷歌","visited":30529,"links":[["51d3db7f8ece70c438000003",{"present":0.025641025641025640136,"title":"“登陆网站”还是“登录网站”"}]],"html":"<p>江苏卫视近来登陆了全球最大的视频网站YouTube，并将许多节目内容都上传到了YouTube上。</p>\n<p>江苏卫视近来登陆了全球最大的视频网站YouTube（因众所周知的原因，国内网友无法访问），并将许多节目内容都上传到了YouTube上。此外，江苏卫视还在旗下的《非诚勿扰》节目中为新开的YouTube频道做广告，并植入了全球最大的搜索引擎谷歌的广告。</p>\n<p><img src=\"http://i2.hexunimg.cn/2012-11-26/148367410.jpg\" alt=\"江苏卫视登陆YouTube\">\n江苏卫视登陆YouTube</p>\n<p>据悉，江苏卫视在YouTube频道上的节目更新非常快。以《非诚勿扰》为例，该节目已经到11月24日的那期节目。显然，江苏卫视开通YouTube频道，可提高江苏卫视在华人领域的收视率与影响力。</p>\n<p><img src=\"http://i8.hexunimg.cn/2012-11-26/148367411.jpg\" alt=\"《非诚勿扰》更新速度很快\">\n《非诚勿扰》更新速度很快</p>\n<p>不过，眼尖的网友发现在《非诚勿扰》的广告中，还植入了谷歌的广告。江苏卫视在《非诚勿扰》中为其YouTube频道做广告，并让用户用谷歌搜索YouTube，然后再搜索《非诚勿扰》即可观看最新节目。</p>\n<p><img src=\"http://i9.hexunimg.cn/2012-11-26/148367412.jpg\" alt=\"《非诚勿扰》广告宣传谷歌\">\n《非诚勿扰》广告宣传谷歌</p>\n<p>对于这则广告中植入广告的做法，不少网友持有不同的看法。有的网友表示对江苏卫士在广告中宣传谷歌的做法感到奇怪，并认为二者的结合方式僵硬、契合度不高，令人难以接受。而有的网友则认为没啥好奇怪的，并表示YouTube本身就是谷歌旗下的，江苏卫视在广告中突出谷歌、YouTube也是无可厚非的。不过，更多的网友则表示，江苏卫视的YouTube频道广告的投放范围不太恰当，毕竟国内大多地区都无法访问YouTube，这则广告更适合投放到海外。</p>\n<p>目前，在微软、苹果都极力为旗下产品大力宣传、大打广告营销战的大背景下，江苏卫视的这则广告对于谷歌的宣传而言，绝对是大大有益的。</p>\n"}
{"_id":{"$oid":"51d3db638ece70c438000002"},"classid":"100","comment":0,"content":".最近在做js选择select的时候，莫名其妙的在IE6中报了一个“无法设置selected属性 未指明的错误”，谷歌和度娘搜了一圈，发现也有不少人遇到同样的bug，给出的解决方案，几乎都是增加一个setTimeout：\r\n``` javascript\r\nsetTimeout(function(){\r\n  selectObj.val(defaultSelect);//选中指定项\r\n},0);\r\n```\r\n细测下来发现一个很奇特的现象，在js抛出错误之前，其实已经完成了选择。抛出错误之后，js代码随即停止运行。\r\n用上述方案之后，虽然后续的js可以执行，但用setTimeout“延迟执行”，虽然解决了问题，但是看起来却感觉有点“不靠谱”。\r\n既然是选择完成之后抛出错误，并不影响当前的选择，那么可不可以用try catch语句来捕捉错误呢？于是尝试用下面的方法：\r\n``` javascript\r\ntry {\r\n  selectMonth.val(oldMonth);//选择指定项目\r\n} catch (e) {\r\n}\r\n```\r\n发现真的可以执行了，但是继续测试下去，发现这种try...catch只能针对3个以下（我测出来的是3可能会有不同）连续选择有效。大于这个数目还是需要用到setTimeout的如下：\r\n``` javascript\r\n//连续3次选择年、月、日的实验\r\ntry {\r\n  selectYear.val(oldYear);//第一次选择年，可以用try catch来捕捉错误。\r\n} catch (e) {\r\n}\r\n\r\ntry {\r\n    selectMonth.val(oldMonth);//连续第二次选择，仍然可以用该方法。\r\n} catch (e) {\r\n}\r\n//连续第三次选择，如果直接用tyr catch可能会报错，所以我加上了个setTimeout\r\nsetTimeout( function () {\r\n    try {\r\n        selectDate.val(oldDate);\r\n     } catch (e) {\r\n    }\r\n }, 0 );\r\n```\r\n\r\n总结：个人觉得处理这个问题的时候用try catch会比单纯的setTimeout要好一点，但是究竟这个错误是什么原因引起的，还有待考虑，个人猜测好像是select里面的option加载会有一点点延迟，有点像异步的感觉，最终导致了上述的bug产生。当然，如果有哪位高人知道其中的“真谛”也请不吝赐教。","pubtime":{"$date":1341267091885},"title":"IE6 select BUG:无法设置selected属性 未指明的错误","visited":23884,"links":[["527100b5ce7d63c80c000001",{"present":0.025641025641025640136,"title":"跨域iframe高度自适应实现方案"}],["52836b510d1662a510000001",{"present":0.025641025641025640136,"title":"懵懂的季节（原标题 “等待=放弃？ ” ）"}]],"html":"<p>.最近在做js选择select的时候，莫名其妙的在IE6中报了一个“无法设置selected属性 未指明的错误”，谷歌和度娘搜了一圈，发现也有不少人遇到同样的bug，给出的解决方案，几乎都是增加一个setTimeout：</p>\n<pre><code class=\"lang-javascript\">setTimeout(function(){\n  selectObj.val(defaultSelect);//选中指定项\n},0);\n</code></pre>\n<p>细测下来发现一个很奇特的现象，在js抛出错误之前，其实已经完成了选择。抛出错误之后，js代码随即停止运行。\n用上述方案之后，虽然后续的js可以执行，但用setTimeout“延迟执行”，虽然解决了问题，但是看起来却感觉有点“不靠谱”。\n既然是选择完成之后抛出错误，并不影响当前的选择，那么可不可以用try catch语句来捕捉错误呢？于是尝试用下面的方法：</p>\n<pre><code class=\"lang-javascript\">try {\n  selectMonth.val(oldMonth);//选择指定项目\n} catch (e) {\n}\n</code></pre>\n<p>发现真的可以执行了，但是继续测试下去，发现这种try...catch只能针对3个以下（我测出来的是3可能会有不同）连续选择有效。大于这个数目还是需要用到setTimeout的如下：</p>\n<pre><code class=\"lang-javascript\">//连续3次选择年、月、日的实验\ntry {\n  selectYear.val(oldYear);//第一次选择年，可以用try catch来捕捉错误。\n} catch (e) {\n}\n\ntry {\n    selectMonth.val(oldMonth);//连续第二次选择，仍然可以用该方法。\n} catch (e) {\n}\n//连续第三次选择，如果直接用tyr catch可能会报错，所以我加上了个setTimeout\nsetTimeout( function () {\n    try {\n        selectDate.val(oldDate);\n     } catch (e) {\n    }\n }, 0 );\n</code></pre>\n<p>总结：个人觉得处理这个问题的时候用try catch会比单纯的setTimeout要好一点，但是究竟这个错误是什么原因引起的，还有待考虑，个人猜测好像是select里面的option加载会有一点点延迟，有点像异步的感觉，最终导致了上述的bug产生。当然，如果有哪位高人知道其中的“真谛”也请不吝赐教。</p>\n"}
{"_id":{"$oid":"527100b5ce7d63c80c000001"},"classid":"100","comment":1,"content":"#### 背景\r\n\r\n大多数应用平台中会通过iframe的方式插入跨站的应用。大多数时候基本上能满足需求，但是如果遇到一些比较特殊的应用，他们的高度并不是固定的，会随着应用内容而变化。虽然会有滚动条的出现，但是这样从某种程度上会影响到页面的美观。于是乎，有没有一种方案可以让iframe的高度随着iframe内容而变化呢？\r\n\r\n#### 尝试\r\n\r\n* 通过javascript获取iframe的内容高度。设置iframe的告诉和内容高度相同。\r\n    \r\n  这种方案在同域的情况下百试不爽，但是缺点是在跨域的情况下，却无能为力。\r\n\r\n* 在iframe里面引入一段js，通过js实时检测iframe内容的高度，发送到服务器。嵌入iframe的页面不停的从服务器获取传过来的iframe的高度，并设置。\r\n\r\n  这种方案，确实可以解决问题，但是却有些令人不爽的地方。\r\n\r\n   * 不停的向服务器发送数据，增加量服务器的负担。\r\n\r\n   * Javasript 不停的请求服务器，获取新的高度。这种不停的轮询，也确实让人蛋疼。\r\n\r\n*  在上面的基础上如果能避开服务器，不失为是一种好方法，但是如何才能避开服务器呢？\r\n\r\n  我们尝试了cookie、local storage等等，希望能有一种方案可以跨过域的限制，但都以失败告终。\r\n  \r\n  最后，突然灵光一现，如果能通过一层代理作为桥梁解决跨域的问题，那么所有的问题不就会迎刃而解了么？\r\n\r\n#### 方案\r\n\r\n域！我们通过上面的实验已经在iframe插入了一段js，这就意味着我们可以随意的控制iframe里面的内容了。这时候如果我们在iframe中通过js插入一个iframe地址和最外面的页面是同域的话，是不是就可以通讯了呢？于是就有了下面的模型\r\n\r\n#####  a.com/index.html\r\n```html\r\n<body>\r\n    <iframe src=\"b.com\">\r\n        content\r\n        <script src=\"a.com/iframe.js\" type=\"text/javascirpt\"> </script>\r\n        <!--通过javascript加入的iframe-->\r\n        <iframe src=\"a.com/height.html\"></iframe>\r\n    </iframe>\r\n</body>\r\n```\r\n\r\n##### a.com/iframe.js\r\n```javascirpt\r\n    var height = document.height;\r\n    var iframe2 = document.createElement('iframe');\r\n    iframe2.height = 0;\r\n    iframe2.src = \"http://a.com/height.html\";\r\n    document.body.appendChild(iframe2);\r\n```\r\n#####  a.com/height.html\r\n```html\r\n<body>\r\n    <script type=\"text/javascript\">\r\n         alert(top.document.getElementsByTagName('iframe')[0])\r\n    </script>\r\n</body>\r\n```\r\n\r\n通过上面的代码我们惊奇的发现，height.html确实可以取到a.com/index.html里面的东西。\r\n\r\n#### 实现\r\n\r\n于是乎，问题就简单了，只要把iframe的高度传给index.html就ok了，改写代码如下\r\n\r\n#### a.com/iframe.js\r\n```javascript\r\n    var height = document.height;\r\n    var iframe2 = document.createElement('iframe');\r\n    iframe2.height = 0;\r\n    iframe2.style.display = 'none';\r\n    iframe2.src = \"http://127.0.0.1/test3.html?height=\" + document.height + '&v' + Math.random();\r\n    document.body.appendChild(iframe2);\r\n    setInterval(function() {\r\n        if(document.height!=height){\r\n            iframe2.src = \"http://a.com/height.html?height=\" + document.height + '&v' + Math.random();\r\n            height=document.height;\r\n        }\r\n    }, 10);\r\n```\r\n\r\n##### a.com/height.html\r\n```html\r\n<body> \r\n    <script type=\"text/javascript\">\r\n        var height=/height=(\\d+)&/.exec(location.href)[1];\r\n        top.document.getElementsByTagName('iframe')[0].height = parseInt(height);\r\n    </script>\r\n</body>\r\n```\r\n\r\n### 总结\r\n\r\n问题解决了，满身的轻松，该方案的主要方法就是在iframe创建一个同源的iframe，通过地址传递iframe的高度，这样的话就可以打通iframe和外界的联系，实现了高度的自适应。","pubtime":{"$date":1383137461988},"title":"跨域iframe高度自适应实现方案","visited":29764,"links":[["51d3dcfc8ece70c438000007",{"present":0.081081081081081085582,"title":"div模拟textarea文本域轻松实现高度自适应"}],["528611f363c705fc73000001",{"present":0.025641025641025640136,"title":"javascript 文字大小自动适应文本框 （文字大小自动调整）"}],["5242d5fc9ab354383d000001",{"present":0.025641025641025640136,"title":"CSS3 实现iOS7毛玻璃模糊效果 (iOS7 live blur)"}],["53eb8e22b55b886a13000001",{"present":0.025641025641025640136,"title":"我是如何发布版本的"}],["51f6519532ffd70b27000001",{"present":0.025641025641025640136,"title":"HTML5 File api 实现断点续传"}],["51d3dd2e8ece70c43800000a",{"present":0.025641025641025640136,"title":"CSS的优先级特性 "}],["51d3db638ece70c438000002",{"present":0.025641025641025640136,"title":"IE6 select BUG:无法设置selected属性 未指明的错误"}]],"html":"<h4 id=\"-\">背景</h4>\n<p>大多数应用平台中会通过iframe的方式插入跨站的应用。大多数时候基本上能满足需求，但是如果遇到一些比较特殊的应用，他们的高度并不是固定的，会随着应用内容而变化。虽然会有滚动条的出现，但是这样从某种程度上会影响到页面的美观。于是乎，有没有一种方案可以让iframe的高度随着iframe内容而变化呢？</p>\n<h4 id=\"-\">尝试</h4>\n<ul>\n<li><p>通过javascript获取iframe的内容高度。设置iframe的告诉和内容高度相同。</p>\n<p>这种方案在同域的情况下百试不爽，但是缺点是在跨域的情况下，却无能为力。</p>\n</li>\n<li><p>在iframe里面引入一段js，通过js实时检测iframe内容的高度，发送到服务器。嵌入iframe的页面不停的从服务器获取传过来的iframe的高度，并设置。</p>\n<p>这种方案，确实可以解决问题，但是却有些令人不爽的地方。</p>\n<ul>\n<li><p>不停的向服务器发送数据，增加量服务器的负担。</p>\n</li>\n<li><p>Javasript 不停的请求服务器，获取新的高度。这种不停的轮询，也确实让人蛋疼。</p>\n</li>\n</ul>\n</li>\n<li><p>在上面的基础上如果能避开服务器，不失为是一种好方法，但是如何才能避开服务器呢？</p>\n<p>我们尝试了cookie、local storage等等，希望能有一种方案可以跨过域的限制，但都以失败告终。</p>\n<p>最后，突然灵光一现，如果能通过一层代理作为桥梁解决跨域的问题，那么所有的问题不就会迎刃而解了么？</p>\n</li>\n</ul>\n<h4 id=\"-\">方案</h4>\n<p>域！我们通过上面的实验已经在iframe插入了一段js，这就意味着我们可以随意的控制iframe里面的内容了。这时候如果我们在iframe中通过js插入一个iframe地址和最外面的页面是同域的话，是不是就可以通讯了呢？于是就有了下面的模型</p>\n<h5 id=\"a-com-index-html\">a.com/index.html</h5>\n<pre><code class=\"lang-html\">&lt;body&gt;\n    &lt;iframe src=&quot;b.com&quot;&gt;\n        content\n        &lt;script src=&quot;a.com/iframe.js&quot; type=&quot;text/javascirpt&quot;&gt; &lt;/script&gt;\n        &lt;!--通过javascript加入的iframe--&gt;\n        &lt;iframe src=&quot;a.com/height.html&quot;&gt;&lt;/iframe&gt;\n    &lt;/iframe&gt;\n&lt;/body&gt;\n</code></pre>\n<h5 id=\"a-com-iframe-js\">a.com/iframe.js</h5>\n<pre><code class=\"lang-javascirpt\">    var height = document.height;\n    var iframe2 = document.createElement(&#39;iframe&#39;);\n    iframe2.height = 0;\n    iframe2.src = &quot;http://a.com/height.html&quot;;\n    document.body.appendChild(iframe2);\n</code></pre>\n<h5 id=\"a-com-height-html\">a.com/height.html</h5>\n<pre><code class=\"lang-html\">&lt;body&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;\n         alert(top.document.getElementsByTagName(&#39;iframe&#39;)[0])\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p>通过上面的代码我们惊奇的发现，height.html确实可以取到a.com/index.html里面的东西。</p>\n<h4 id=\"-\">实现</h4>\n<p>于是乎，问题就简单了，只要把iframe的高度传给index.html就ok了，改写代码如下</p>\n<h4 id=\"a-com-iframe-js\">a.com/iframe.js</h4>\n<pre><code class=\"lang-javascript\">    var height = document.height;\n    var iframe2 = document.createElement(&#39;iframe&#39;);\n    iframe2.height = 0;\n    iframe2.style.display = &#39;none&#39;;\n    iframe2.src = &quot;http://127.0.0.1/test3.html?height=&quot; + document.height + &#39;&amp;v&#39; + Math.random();\n    document.body.appendChild(iframe2);\n    setInterval(function() {\n        if(document.height!=height){\n            iframe2.src = &quot;http://a.com/height.html?height=&quot; + document.height + &#39;&amp;v&#39; + Math.random();\n            height=document.height;\n        }\n    }, 10);\n</code></pre>\n<h5 id=\"a-com-height-html\">a.com/height.html</h5>\n<pre><code class=\"lang-html\">&lt;body&gt; \n    &lt;script type=&quot;text/javascript&quot;&gt;\n        var height=/height=(\\d+)&amp;/.exec(location.href)[1];\n        top.document.getElementsByTagName(&#39;iframe&#39;)[0].height = parseInt(height);\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h3 id=\"-\">总结</h3>\n<p>问题解决了，满身的轻松，该方案的主要方法就是在iframe创建一个同源的iframe，通过地址传递iframe的高度，这样的话就可以打通iframe和外界的联系，实现了高度的自适应。</p>\n"}
{"_id":{"$oid":"5242d5fc9ab354383d000001"},"classid":"100","comment":12,"content":"### iOS live blur 实时毛玻璃模糊\r\n\r\n随着iOS 7的正式放出，很多人感慨道，苹果终于去尝试修那几百年不变的UI了，暂且不说这种改变是好还是坏，毕竟这是仁者见仁的事情。今天我们关注的焦点是iOS 7 中的一个特殊的设计效果——毛玻璃效果。 \r\n\r\n关于IOS7 live blur的其他方面的讨论，已经有很多了。比如：\r\n\r\n[iOS 7 的实时毛玻璃模糊 (live blur) 效果渲染需要多大的系统开销？](http://www.zhihu.com/question/21260575)\r\n\r\n今天我想说的是如何使用 css3 来实现，iOS7的毛玻璃效果。 \r\n\r\n----\r\n\r\n### -webkit-filter\r\n该属性是我们这次实现该功能的主要属性\r\n\r\n目前该属性还属于草案阶段，只有chrome 18+、Safari 浏览器支持，不过相信随着时间的推移，很快会被大规模应用的。\r\n\r\n具体的filter用法我会另外写一篇文章和大家分享的，这里主要介绍它的 blur()、brightness()、contrast() 3个属性。\r\n\r\n#### blur()\r\n\r\n>用来设置相应的dom的模糊程度，用法很简单\r\n\r\n    filter: blur(5px)\r\n\r\n#### brightness()\r\n\r\n>用来设置相应dom的明度，对应的值越大越亮\r\n    \r\n    filter: brightness(0.5)\r\n\r\n#### contrast()\r\n\r\n>对比度值越大越强烈\r\n\r\n    filter: contrast(200%)\r\n\r\n----\r\n\r\n### clip: rect(205px 572px 516px 351px); \r\n\r\n> 用来裁减DOM，相当于遮罩的概念，由于css模糊会造成边缘变得很淡，影响我们的效果，所以我们用裁减将其边缘部分减去，这样看起来效果就很好了。\r\n\r\n     clip: rect(205px 572px 516px 351px); \r\n\r\n----\r\n\r\n###实例\r\n\r\n#### HTML 代码\r\n\r\n```html\r\n    <div class=\"ios7\">\r\n        <div class=\"ios7_f\">\r\n\t    <img src=\"ios7_icon_redesign_by_ida_swarczewskaja.jpg\" width=\"700px\" height=\"525px\" />\r\n\t</div>\r\n\t<div class=\"ios7_b\">\r\n\t\t<img src=\"ios7_icon_redesign_by_ida_swarczewskaja.jpg\" width=\"700px\" height=\"525px\" />\r\n\t</div>\r\n\t<div class=\"ios7_i\">\r\n\t\t<img src=\"Control-Center-btns.png\" width=\"222px\" height=\"331px\"/>\r\n\t</div>\r\n   </div>\r\n```\r\n\r\n#### CSS 代码\r\n\r\n``` css\r\n.ios7 {  \r\n    width: 700px;  \r\n    height: 525px; \r\n    overflow: hidden;  \r\n    position: relative;  \r\n    margin: 0 auto; \r\n}\r\n.ios7_f, .ios7_b { \r\n    position: absolute;  \r\n    top: 0;  \r\n    left: 0;\r\n}\r\n.ios7_f img, .ios7_b img{  \r\n    width:700px; \r\n    height:525px; \r\n}\r\n.ios7_b { \r\n    -webkit-filter: blur(8px) contrast(0.4) brightness(1.4); \r\n    clip: rect(205px 572px 516px 351px);\r\n     z-index: 50;\ttransition: all 0.5s ease-in-out;\t\r\n}\r\n.ios7_b_on { \r\n    clip: rect(516px 572px 516px 351px); \r\n}\r\n.ios7_i { \r\n    position: absolute; \r\n    clip: rect(205px 572px 516px 351px); \r\n}\r\n.ios7_i img { \r\n    z-index: 100; \r\n    width: 222px;\t\r\n    height:301px;  \r\n    top: 215px; \r\n    left: 350px; \r\n    position: absolute; \r\n    transition: all 0.5s ease-in-out; \r\n}\r\n.ios7_i_on img { \r\n    top: 516px \r\n}\r\n```\r\n\r\n#### javascript 代码\r\n\r\n``` javascript\r\nvar img = document.querySelector('.ios7_i');\r\nvar back = document.querySelector('.ios7_b');\r\ndocument.onkeydown = function(e) {\r\n    if (e.keyCode == '38') {\r\n        img.className = 'ios7_i';\r\n        back.className = 'ios7_b';\r\n        return false;\r\n    } else if (e.keyCode == '40') {\r\n        img.className += ' ios7_i_on';\r\n        back.className += ' ios7_b_on';\r\n        return false;\r\n   }\r\n};\r\n```\r\n\r\n#### DEMO [DEMO传送门](/demo/ios7/ios7.html)\r\n\r\n在demo中我们可以通过键盘的上下按钮来看效果(该DMEO仅在webkit内核浏览器中有效)。\r\n\r\n\r\n----","pubtime":{"$date":1380111868698},"title":"CSS3 实现iOS7毛玻璃模糊效果 (iOS7 live blur)","visited":46045,"links":[["51d3dcfc8ece70c438000007",{"present":0.052631578947368418131,"title":"div模拟textarea文本域轻松实现高度自适应"}],["527100b5ce7d63c80c000001",{"present":0.025641025641025640136,"title":"跨域iframe高度自适应实现方案"}],["51d3dc538ece70c438000005",{"present":0.025641025641025640136,"title":"小心 -webkit-text-size-adjust:none！[译]"}],["51d3dfda8ece70c438000012",{"present":0.025641025641025640136,"title":"jQuery新的事件绑定机制on()"}],["51d3dd2e8ece70c43800000a",{"present":0.025641025641025640136,"title":"CSS的优先级特性 "}]],"html":"<h3 id=\"ios-live-blur-\">iOS live blur 实时毛玻璃模糊</h3>\n<p>随着iOS 7的正式放出，很多人感慨道，苹果终于去尝试修那几百年不变的UI了，暂且不说这种改变是好还是坏，毕竟这是仁者见仁的事情。今天我们关注的焦点是iOS 7 中的一个特殊的设计效果——毛玻璃效果。 </p>\n<p>关于IOS7 live blur的其他方面的讨论，已经有很多了。比如：</p>\n<p><a href=\"http://www.zhihu.com/question/21260575\">iOS 7 的实时毛玻璃模糊 (live blur) 效果渲染需要多大的系统开销？</a></p>\n<p>今天我想说的是如何使用 css3 来实现，iOS7的毛玻璃效果。 </p>\n<hr>\n<h3 id=\"-webkit-filter\">-webkit-filter</h3>\n<p>该属性是我们这次实现该功能的主要属性</p>\n<p>目前该属性还属于草案阶段，只有chrome 18+、Safari 浏览器支持，不过相信随着时间的推移，很快会被大规模应用的。</p>\n<p>具体的filter用法我会另外写一篇文章和大家分享的，这里主要介绍它的 blur()、brightness()、contrast() 3个属性。</p>\n<h4 id=\"blur-\">blur()</h4>\n<blockquote>\n<p>用来设置相应的dom的模糊程度，用法很简单</p>\n</blockquote>\n<pre><code>filter: blur(5px)\n</code></pre><h4 id=\"brightness-\">brightness()</h4>\n<blockquote>\n<p>用来设置相应dom的明度，对应的值越大越亮</p>\n</blockquote>\n<pre><code>filter: brightness(0.5)\n</code></pre><h4 id=\"contrast-\">contrast()</h4>\n<blockquote>\n<p>对比度值越大越强烈</p>\n</blockquote>\n<pre><code>filter: contrast(200%)\n</code></pre><hr>\n<h3 id=\"clip-rect-205px-572px-516px-351px-\">clip: rect(205px 572px 516px 351px);</h3>\n<blockquote>\n<p>用来裁减DOM，相当于遮罩的概念，由于css模糊会造成边缘变得很淡，影响我们的效果，所以我们用裁减将其边缘部分减去，这样看起来效果就很好了。</p>\n</blockquote>\n<pre><code> clip: rect(205px 572px 516px 351px); \n</code></pre><hr>\n<p>###实例</p>\n<h4 id=\"html-\">HTML 代码</h4>\n<pre><code class=\"lang-html\">    &lt;div class=&quot;ios7&quot;&gt;\n        &lt;div class=&quot;ios7_f&quot;&gt;\n        &lt;img src=&quot;ios7_icon_redesign_by_ida_swarczewskaja.jpg&quot; width=&quot;700px&quot; height=&quot;525px&quot; /&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;ios7_b&quot;&gt;\n        &lt;img src=&quot;ios7_icon_redesign_by_ida_swarczewskaja.jpg&quot; width=&quot;700px&quot; height=&quot;525px&quot; /&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;ios7_i&quot;&gt;\n        &lt;img src=&quot;Control-Center-btns.png&quot; width=&quot;222px&quot; height=&quot;331px&quot;/&gt;\n    &lt;/div&gt;\n   &lt;/div&gt;\n</code></pre>\n<h4 id=\"css-\">CSS 代码</h4>\n<pre><code class=\"lang-css\">.ios7 {  \n    width: 700px;  \n    height: 525px; \n    overflow: hidden;  \n    position: relative;  \n    margin: 0 auto; \n}\n.ios7_f, .ios7_b { \n    position: absolute;  \n    top: 0;  \n    left: 0;\n}\n.ios7_f img, .ios7_b img{  \n    width:700px; \n    height:525px; \n}\n.ios7_b { \n    -webkit-filter: blur(8px) contrast(0.4) brightness(1.4); \n    clip: rect(205px 572px 516px 351px);\n     z-index: 50;    transition: all 0.5s ease-in-out;    \n}\n.ios7_b_on { \n    clip: rect(516px 572px 516px 351px); \n}\n.ios7_i { \n    position: absolute; \n    clip: rect(205px 572px 516px 351px); \n}\n.ios7_i img { \n    z-index: 100; \n    width: 222px;    \n    height:301px;  \n    top: 215px; \n    left: 350px; \n    position: absolute; \n    transition: all 0.5s ease-in-out; \n}\n.ios7_i_on img { \n    top: 516px \n}\n</code></pre>\n<h4 id=\"javascript-\">javascript 代码</h4>\n<pre><code class=\"lang-javascript\">var img = document.querySelector(&#39;.ios7_i&#39;);\nvar back = document.querySelector(&#39;.ios7_b&#39;);\ndocument.onkeydown = function(e) {\n    if (e.keyCode == &#39;38&#39;) {\n        img.className = &#39;ios7_i&#39;;\n        back.className = &#39;ios7_b&#39;;\n        return false;\n    } else if (e.keyCode == &#39;40&#39;) {\n        img.className += &#39; ios7_i_on&#39;;\n        back.className += &#39; ios7_b_on&#39;;\n        return false;\n   }\n};\n</code></pre>\n<h4 id=\"demo-demo-demo-ios7-ios7-html-\">DEMO <a href=\"/demo/ios7/ios7.html\">DEMO传送门</a></h4>\n<p>在demo中我们可以通过键盘的上下按钮来看效果(该DMEO仅在webkit内核浏览器中有效)。</p>\n<hr>\n","like":1}
{"_id":{"$oid":"52d6769f93dcae3050000003"},"title":"HTML5 file api 读取文件MD5码","classid":"100","content":"### 背景\r\n\r\n自从html5 file api出现以来，我们可以做的事情越来越多，越来越有趣了，之前介绍过 《HTML5实现断点续传》、《HTML5实现拖拽下载》等关于File API的一些实例，今天和大家分享一下，如何用HTML5 file api读取文件的MD5码。\r\n\r\nMD5码在文件的唯一性识别上有很重要的应用，业内常用MD5进行文件识别、文件秒传、文件安全性检查等。\r\n\r\n废话不多说，直接说重点。\r\n\r\n### 实现\r\n\r\n首先监听文本框的变化，告诉浏览器，你就看着这个input 如果有变化你就立刻执行之后的东西。\r\n\r\n```javascript\r\ndocument.getElementById(\"file\").addEventListener(\"change\", function() {\r\n    //...\r\n}\r\n```\r\n\r\n读取文件很容易通过input的files对象就可以读取到用户所选择的文件\r\n\r\n```javascript\r\nfile = document.getElementById(\"file\").files[0]\r\n```\r\n\r\n之后就是分割文件了，由于文件可能会很大，比如说10G，20G所以一次性把它交个内存来处理会显得很残忍。于是我们把文件以2M作为一个片段进行分割，算出总共需要分成多少片\r\n\r\n```javascript\r\nvar chunkSize = 2097152;\r\nchunks = Math.ceil(file.size / chunkSize);\r\n```\r\n\r\n接着分割文件\r\n\r\n```javascript\r\n//file的slice方法，注意它的兼容性，在不同浏览器的写法不同\r\nblobSlice = File.prototype.mozSlice || File.prototype.webkitSlice || File.prototype.slice\r\n//然后指定file和开始结束的片段，就可以得到切割的文件了。\r\nblobSlice.call(file, start, end)\r\n```\r\n\r\n一切做好之后，就要去读取文件的具体信息了。\r\n\r\n这里我们用了Javascript的 FileReader() 方法，这个方法可以去读取用户本地文件的详细内容。\r\n\r\n他的用法如下\r\n\r\n```javascript\r\nvar fileReader = new FileReader();\r\n//blobSlice.call(file, start, end)就是之前分割文件的方法。\r\n//这里只要维护好start和end，就能一片一片的把文件传给fileRader对象了\r\nfileReader.readAsBinaryString(blobSlice.call(file, start, end));\r\n//最终每一段文件处理完毕都会触发fileReader的onload事件\r\nfileReader.onload = function(e){\r\n    //e.target.result 就是我们要的片段信息\r\n    //这里缓存获取到的片段，当所有片段完毕之后就可以进行MD5的计算了。\r\n}\r\n```\r\n\r\n好了，到这里万事俱备只欠东风了。\r\n由于原生的Javascript没有直接计算MD5的方法，这里我们引用了一个比较好的spark-md5库来辅助我们进行MD5的计算。\r\n比较好的一点是，spark-md5处理文件的话也可以按片来计算。\r\n\r\n```javascript\r\nspark = new SparkMD5();\r\nspark.appendBinary(filepice1);\r\nspark.appendBinary(filepice2);\r\nspark.appendBinary(filepice3);\r\n....\r\n//所有的分片处理好之后调用下面的方法就能获取到文件的MD5了\r\nspark.end()\r\n```\r\n\r\n至此整个过程都已经结束了。\r\n简单的描述就是：利用input选择文件 -> 对文件进行分片 -> 用FileReader方法读取文件 -> 交由Spark-md5进行处理。\r\n\r\n### 代码\r\n\r\n#### [DEMO传送门](http://www.zhuwenlong.com/demo/html5Hash/html5Hash.html)\r\n\r\n附上完成的代码：\r\n\r\n```javascript\r\n//注意此方法引用了SparkMD5库 library:https://github.com/satazor/SparkMD5\r\n//监听文本框变化\r\ndocument.getElementById(\"file\").addEventListener(\"change\", function() {\r\n    //声明必要的变量\r\n    var fileReader = new FileReader(), box = document.getElementById('box');\r\n    //文件分割方法（注意兼容性）\r\n    blobSlice = File.prototype.mozSlice || File.prototype.webkitSlice || File.prototype.slice, \r\n    file = document.getElementById(\"file\").files[0], \r\n\r\n    //文件每块分割2M，计算分割详情\r\n    chunkSize = 2097152,                \r\n    chunks = Math.ceil(file.size / chunkSize), \r\n    currentChunk = 0, \r\n\r\n    //创建md5对象（基于SparkMD5）\r\n    spark = new SparkMD5();\r\n    \r\n    //每块文件读取完毕之后的处理\r\n    fileReader.onload = function(e) {\r\n        console.log(\"读取文件\", currentChunk + 1, \"/\", chunks);\r\n        //每块交由sparkMD5进行计算\r\n        spark.appendBinary(e.target.result);\r\n        currentChunk++;\r\n        \r\n        //如果文件处理完成计算MD5，如果还有分片继续处理\r\n        if (currentChunk < chunks) {\r\n            loadNext();\r\n        } else {\r\n            console.log(\"finished loading\");\r\n            box.innerText = 'MD5 hash:' + spark.end();\r\n            console.info(\"计算的Hash\", spark.end());\r\n        }\r\n    };\r\n\r\n     //处理单片文件的上传\r\n     function loadNext() {\r\n         var start = currentChunk * chunkSize, end = start + chunkSize >= file.size ? file.size : start + chunkSize;\r\n\r\n         fileReader.readAsBinaryString(blobSlice.call(file, start, end));\r\n     }\r\n\r\n      loadNext();\r\n});\r\n```\r\n\r\n#### [DEMO传送门](http://www.zhuwenlong.com/demo/html5Hash/html5Hash.html)\r\n","visited":19214,"comment":13,"pubtime":{"$date":1389786783629},"links":[["51f6519532ffd70b27000001",{"present":0.052631578947368418131,"title":"HTML5 File api 实现断点续传"}],["52cfc44ad4cf86262b000001",{"present":0.052631578947368418131,"title":"HTML5 拖动（Drag）文件到文件夹下载"}],["53eb8e22b55b886a13000001",{"present":0.025641025641025640136,"title":"我是如何发布版本的"}],["528611f363c705fc73000001",{"present":0.025641025641025640136,"title":"javascript 文字大小自动适应文本框 （文字大小自动调整）"}],["5349905d7eeca8ec50000001",{"present":0.025641025641025640136,"title":"manifest 详解以及规范"}]],"html":"<h3 id=\"-\">背景</h3>\n<p>自从html5 file api出现以来，我们可以做的事情越来越多，越来越有趣了，之前介绍过 《HTML5实现断点续传》、《HTML5实现拖拽下载》等关于File API的一些实例，今天和大家分享一下，如何用HTML5 file api读取文件的MD5码。</p>\n<p>MD5码在文件的唯一性识别上有很重要的应用，业内常用MD5进行文件识别、文件秒传、文件安全性检查等。</p>\n<p>废话不多说，直接说重点。</p>\n<h3 id=\"-\">实现</h3>\n<p>首先监听文本框的变化，告诉浏览器，你就看着这个input 如果有变化你就立刻执行之后的东西。</p>\n<pre><code class=\"lang-javascript\">document.getElementById(&quot;file&quot;).addEventListener(&quot;change&quot;, function() {\n    //...\n}\n</code></pre>\n<p>读取文件很容易通过input的files对象就可以读取到用户所选择的文件</p>\n<pre><code class=\"lang-javascript\">file = document.getElementById(&quot;file&quot;).files[0]\n</code></pre>\n<p>之后就是分割文件了，由于文件可能会很大，比如说10G，20G所以一次性把它交个内存来处理会显得很残忍。于是我们把文件以2M作为一个片段进行分割，算出总共需要分成多少片</p>\n<pre><code class=\"lang-javascript\">var chunkSize = 2097152;\nchunks = Math.ceil(file.size / chunkSize);\n</code></pre>\n<p>接着分割文件</p>\n<pre><code class=\"lang-javascript\">//file的slice方法，注意它的兼容性，在不同浏览器的写法不同\nblobSlice = File.prototype.mozSlice || File.prototype.webkitSlice || File.prototype.slice\n//然后指定file和开始结束的片段，就可以得到切割的文件了。\nblobSlice.call(file, start, end)\n</code></pre>\n<p>一切做好之后，就要去读取文件的具体信息了。</p>\n<p>这里我们用了Javascript的 FileReader() 方法，这个方法可以去读取用户本地文件的详细内容。</p>\n<p>他的用法如下</p>\n<pre><code class=\"lang-javascript\">var fileReader = new FileReader();\n//blobSlice.call(file, start, end)就是之前分割文件的方法。\n//这里只要维护好start和end，就能一片一片的把文件传给fileRader对象了\nfileReader.readAsBinaryString(blobSlice.call(file, start, end));\n//最终每一段文件处理完毕都会触发fileReader的onload事件\nfileReader.onload = function(e){\n    //e.target.result 就是我们要的片段信息\n    //这里缓存获取到的片段，当所有片段完毕之后就可以进行MD5的计算了。\n}\n</code></pre>\n<p>好了，到这里万事俱备只欠东风了。\n由于原生的Javascript没有直接计算MD5的方法，这里我们引用了一个比较好的spark-md5库来辅助我们进行MD5的计算。\n比较好的一点是，spark-md5处理文件的话也可以按片来计算。</p>\n<pre><code class=\"lang-javascript\">spark = new SparkMD5();\nspark.appendBinary(filepice1);\nspark.appendBinary(filepice2);\nspark.appendBinary(filepice3);\n....\n//所有的分片处理好之后调用下面的方法就能获取到文件的MD5了\nspark.end()\n</code></pre>\n<p>至此整个过程都已经结束了。\n简单的描述就是：利用input选择文件 -&gt; 对文件进行分片 -&gt; 用FileReader方法读取文件 -&gt; 交由Spark-md5进行处理。</p>\n<h3 id=\"-\">代码</h3>\n<h4 id=\"-demo-http-www-zhuwenlong-com-demo-html5hash-html5hash-html-\"><a href=\"http://www.zhuwenlong.com/demo/html5Hash/html5Hash.html\">DEMO传送门</a></h4>\n<p>附上完成的代码：</p>\n<pre><code class=\"lang-javascript\">//注意此方法引用了SparkMD5库 library:https://github.com/satazor/SparkMD5\n//监听文本框变化\ndocument.getElementById(&quot;file&quot;).addEventListener(&quot;change&quot;, function() {\n    //声明必要的变量\n    var fileReader = new FileReader(), box = document.getElementById(&#39;box&#39;);\n    //文件分割方法（注意兼容性）\n    blobSlice = File.prototype.mozSlice || File.prototype.webkitSlice || File.prototype.slice, \n    file = document.getElementById(&quot;file&quot;).files[0], \n\n    //文件每块分割2M，计算分割详情\n    chunkSize = 2097152,                \n    chunks = Math.ceil(file.size / chunkSize), \n    currentChunk = 0, \n\n    //创建md5对象（基于SparkMD5）\n    spark = new SparkMD5();\n\n    //每块文件读取完毕之后的处理\n    fileReader.onload = function(e) {\n        console.log(&quot;读取文件&quot;, currentChunk + 1, &quot;/&quot;, chunks);\n        //每块交由sparkMD5进行计算\n        spark.appendBinary(e.target.result);\n        currentChunk++;\n\n        //如果文件处理完成计算MD5，如果还有分片继续处理\n        if (currentChunk &lt; chunks) {\n            loadNext();\n        } else {\n            console.log(&quot;finished loading&quot;);\n            box.innerText = &#39;MD5 hash:&#39; + spark.end();\n            console.info(&quot;计算的Hash&quot;, spark.end());\n        }\n    };\n\n     //处理单片文件的上传\n     function loadNext() {\n         var start = currentChunk * chunkSize, end = start + chunkSize &gt;= file.size ? file.size : start + chunkSize;\n\n         fileReader.readAsBinaryString(blobSlice.call(file, start, end));\n     }\n\n      loadNext();\n});\n</code></pre>\n<h4 id=\"-demo-http-www-zhuwenlong-com-demo-html5hash-html5hash-html-\"><a href=\"http://www.zhuwenlong.com/demo/html5Hash/html5Hash.html\">DEMO传送门</a></h4>\n","like":4}
{"_id":{"$oid":"51ff1a66f5803cb472000003"},"classid":"100","comment":5,"content":"看到一篇文章，还是有点感想的，分享一下\r\n\r\n眼看自己大学毕业后都快12年了，也快2个孩子的爸爸了，但是有时候还是会有不少不安全的感觉产生。都快奔35了，技术也过得去，收入其实也很稳定，但是偶尔还是会有迷茫的时候，最近有几个朋友，也发QQ聊天信息，同样有类似的感觉。也稍微揣摩了一下，为啥会有这样的感觉产生？\r\n\r\n其实软件开发也是一个行业，当厨师的也是一个行业，一个厨师干了10多年后，会不会变成国家主席？很可能还是厨师，甚至有有可能一辈子都是厨师，软件开发人员也是一个行业而已，也是为人民服务而已，估计厨师也会有迷茫的时候，我们也照样会有迷茫的时候，05年左右在上海做日本外包时，还真有同事是厨师出身的。\r\n\r\n### 年轻时：\r\n\r\n- 年轻时，目标很简单，就是学技术，当时学PHP前后耗费了1-2年，接着学C#，SQLServer，Oracle耗费了前后10年接近了，有目标的人就不迷茫，就是一个字想学习知识。\r\n- 年轻时，欲望比较少，一个月能赚5000元的工资就很开心，生活没任何压力身体也很壮实，就也不会有啥负担，一心还是想着学好技术，找好单位，拿高薪。\r\n- 年轻时，可以有很多空想，就是狗屁不是，也可以抱有很多美好的理想，也可以做白日梦。\r\n\r\n### 年纪大了后：\r\n\r\n- 打工总会有一个瓶颈，好单位也不是天天招聘，他们的业务也是有瓶颈，等你水平提高了，年龄也太大了，没啥竞争优势了，当初想进入的单位都不会招聘40岁的老头了。\r\n- 年纪大了，身体也开始不行了，要成家立业，养孩子，养老婆，父母年纪也大了，可能身体也更不行了，很可能也需要赡养了，生活的各种开支，不是小几千能搞定的。\r\n- 学了一大堆知识后未必都能转换成RMB，不转换成RMB，你的很多需求是得不到满足，你看很多人开着好车，住着豪宅，身边女人多多，一看自己也快奔40了，2手空空。\r\n- 很多年轻时的梦想实现了也未必能变成RMB，以前想架构一个完美的开发框架，结果努力了10年，想出售也很难遇到各种困难，就这么耗费掉了10年了。\r\n- 10年里会发现很多曾经的朋友成功了，但是你可能还是一个默默无闻的打工者，甚至能看到一直到到老的时候会怎么样？很可能打工一辈子。\r\n- 做技术的失业了就真失业了，啥也没了，没人给按时发工资了，连社保都都没了，不干活了就很可能没任何稳定收入了，没任何安全感了。\r\n- 有些行业越老越值钱，客户也越来越多，技术人员的客户都是老板的，越老越容易走下坡路，精力，能力都会下降，干劲更容易下降。\r\n- 老板也不是印钞机，老板也需要成本控制，所以尽量不会雇佣预算很高的员工，宁可雇佣在预算范围内的员工，谁都想拿10万一个与，但是老板赚不来那么多客户的钱。\r\n\r\n### 调整心态：\r\n\r\n- 人绝大部分是庸俗的普通人，不是每个人都能出人头地，1%不到的人相对能得到成功，99%甚至更多的人，是普通人一辈子。\r\n- 一般牛人的才华35岁前就体现出来了，35过了也是俗人的，再过几年就爆发不来，也很少，性格已经成型了，基本上可以过的安稳的日子就可以了。\r\n- 不要总是跟成功人士比，偶尔也向下看看，看看扫地的，看看服务员，看看人民公仆，多少心里会有一些安慰。\r\n- 人活着不只是为了赚钱，身体好，家庭幸福，感情顺利，孩子健康，父母健康，同事关系和睦，都是宝贵的财富。\r\n- 人生其实很短暂的，一晃10年就过去了，学会好好过生活，调节好每一天，想想要解放生活在水深火热中韩国的朝鲜人民军队，吃不饱饭，我们也幸福很多了。\r\n\r\n### 事实：\r\n\r\n- 年轻的时候没付出，年纪大了也有好的收成是很难的，除非你购买彩票中奖了，但是你最起码为了买彩票也得付出一些劳动，所以没有白来的成功白来的收获。\r\n- 世界很大社会在发展，到处需要技术服务，我们做技术的就是为社会技术需要做辛苦劳动而已，所以只要社会安定团结，我们就不用太愁没饭吃。\r\n- 每个人都想成功，做医生的难道不想巨大成功？做老师的难道不想巨大成功？谁都想有巨大的成功，但是，只有一个院长，一个校长，其他都是普通人。\r\n- 水平没有，让你当个部门经理，没几天也得被大家罢免，水平没有，给你1000个人公司，第2个月，你就发不出工资，1年不到就倒闭。\r\n- 人都很迷茫，迷茫的时候千万别吸毒、别赌博，别沉溺与网络游戏，迷茫的时候适当的调节一下心里，看看健康的电影，听听音乐，找几个朋友聊聊天。\r\n\r\n扫地最厉害的人是谁？很可能顶多是扫地组的组长，例如杭州西湖区环境保护临时工中的小组长，种地种最厉害的？炒菜炒最厉害的？那一样，写程序最厉害的，很可能就是项目组组长，人嘛都想老板，但是都不想付出老板的艰辛。\r\n真想巨大成功，就走出来自己干，就知道有多难打工还是很舒服每个月按时发工资，压力也是大家一起承担，周末还可以休息，晚上可能也不用加班。\r\n\r\n迷茫的时候，看看我的博客，就会好很多了。\r\n\r\n### 幸福有很多种类：\r\n\r\n- 你有年轻漂亮的老婆。\r\n- 你有健康聪明的小宝宝。\r\n- 你有一个强壮的身体。\r\n- 你会唱歌跳舞多多才多艺。\r\n- 你喜欢钓鱼，绣花。\r\n- 吉日嘎拉喜欢写几篇软文，看看别人的回复就其乐无穷，偶尔看看网络上美女图片，看看美国大片，都是其乐无穷的事情，偶尔鼓励一下小朋友，跟老朋友聚聚，吃吃喝喝都是很快乐很幸福的。\r\n\r\n人人都想当比尔盖茨，可惜你没那样的妈妈（IBM的高级主管？），也没那样的爸爸（纽约著名律师？），今天也考不上那样的大学（哈佛很好考吗？），更不可能支付那么高的费用购买别人的软件产品（按当年的美元计算，当年一个月工资多少，现在多少，按当年的汇率折算，30-40年后现在让你支付这些费用，也很可能买不起当年的DOS什么的版权）。\r\n成功很多时候不是偶然的，很多是必然的，有几个国家领导人是普通老百姓？都是高干子女居多。\r\n从农村的大山沟里能爬出来到中国的人间天堂定居生活也知足了，知足常乐，不能跟自己过不去。","pubtime":{"$date":1375672934325},"title":"[转]为什么开发人员工作10多年了还会迷茫？没有安全感？","visited":35097,"links":[],"html":"<p>看到一篇文章，还是有点感想的，分享一下</p>\n<p>眼看自己大学毕业后都快12年了，也快2个孩子的爸爸了，但是有时候还是会有不少不安全的感觉产生。都快奔35了，技术也过得去，收入其实也很稳定，但是偶尔还是会有迷茫的时候，最近有几个朋友，也发QQ聊天信息，同样有类似的感觉。也稍微揣摩了一下，为啥会有这样的感觉产生？</p>\n<p>其实软件开发也是一个行业，当厨师的也是一个行业，一个厨师干了10多年后，会不会变成国家主席？很可能还是厨师，甚至有有可能一辈子都是厨师，软件开发人员也是一个行业而已，也是为人民服务而已，估计厨师也会有迷茫的时候，我们也照样会有迷茫的时候，05年左右在上海做日本外包时，还真有同事是厨师出身的。</p>\n<h3 id=\"-\">年轻时：</h3>\n<ul>\n<li>年轻时，目标很简单，就是学技术，当时学PHP前后耗费了1-2年，接着学C#，SQLServer，Oracle耗费了前后10年接近了，有目标的人就不迷茫，就是一个字想学习知识。</li>\n<li>年轻时，欲望比较少，一个月能赚5000元的工资就很开心，生活没任何压力身体也很壮实，就也不会有啥负担，一心还是想着学好技术，找好单位，拿高薪。</li>\n<li>年轻时，可以有很多空想，就是狗屁不是，也可以抱有很多美好的理想，也可以做白日梦。</li>\n</ul>\n<h3 id=\"-\">年纪大了后：</h3>\n<ul>\n<li>打工总会有一个瓶颈，好单位也不是天天招聘，他们的业务也是有瓶颈，等你水平提高了，年龄也太大了，没啥竞争优势了，当初想进入的单位都不会招聘40岁的老头了。</li>\n<li>年纪大了，身体也开始不行了，要成家立业，养孩子，养老婆，父母年纪也大了，可能身体也更不行了，很可能也需要赡养了，生活的各种开支，不是小几千能搞定的。</li>\n<li>学了一大堆知识后未必都能转换成RMB，不转换成RMB，你的很多需求是得不到满足，你看很多人开着好车，住着豪宅，身边女人多多，一看自己也快奔40了，2手空空。</li>\n<li>很多年轻时的梦想实现了也未必能变成RMB，以前想架构一个完美的开发框架，结果努力了10年，想出售也很难遇到各种困难，就这么耗费掉了10年了。</li>\n<li>10年里会发现很多曾经的朋友成功了，但是你可能还是一个默默无闻的打工者，甚至能看到一直到到老的时候会怎么样？很可能打工一辈子。</li>\n<li>做技术的失业了就真失业了，啥也没了，没人给按时发工资了，连社保都都没了，不干活了就很可能没任何稳定收入了，没任何安全感了。</li>\n<li>有些行业越老越值钱，客户也越来越多，技术人员的客户都是老板的，越老越容易走下坡路，精力，能力都会下降，干劲更容易下降。</li>\n<li>老板也不是印钞机，老板也需要成本控制，所以尽量不会雇佣预算很高的员工，宁可雇佣在预算范围内的员工，谁都想拿10万一个与，但是老板赚不来那么多客户的钱。</li>\n</ul>\n<h3 id=\"-\">调整心态：</h3>\n<ul>\n<li>人绝大部分是庸俗的普通人，不是每个人都能出人头地，1%不到的人相对能得到成功，99%甚至更多的人，是普通人一辈子。</li>\n<li>一般牛人的才华35岁前就体现出来了，35过了也是俗人的，再过几年就爆发不来，也很少，性格已经成型了，基本上可以过的安稳的日子就可以了。</li>\n<li>不要总是跟成功人士比，偶尔也向下看看，看看扫地的，看看服务员，看看人民公仆，多少心里会有一些安慰。</li>\n<li>人活着不只是为了赚钱，身体好，家庭幸福，感情顺利，孩子健康，父母健康，同事关系和睦，都是宝贵的财富。</li>\n<li>人生其实很短暂的，一晃10年就过去了，学会好好过生活，调节好每一天，想想要解放生活在水深火热中韩国的朝鲜人民军队，吃不饱饭，我们也幸福很多了。</li>\n</ul>\n<h3 id=\"-\">事实：</h3>\n<ul>\n<li>年轻的时候没付出，年纪大了也有好的收成是很难的，除非你购买彩票中奖了，但是你最起码为了买彩票也得付出一些劳动，所以没有白来的成功白来的收获。</li>\n<li>世界很大社会在发展，到处需要技术服务，我们做技术的就是为社会技术需要做辛苦劳动而已，所以只要社会安定团结，我们就不用太愁没饭吃。</li>\n<li>每个人都想成功，做医生的难道不想巨大成功？做老师的难道不想巨大成功？谁都想有巨大的成功，但是，只有一个院长，一个校长，其他都是普通人。</li>\n<li>水平没有，让你当个部门经理，没几天也得被大家罢免，水平没有，给你1000个人公司，第2个月，你就发不出工资，1年不到就倒闭。</li>\n<li>人都很迷茫，迷茫的时候千万别吸毒、别赌博，别沉溺与网络游戏，迷茫的时候适当的调节一下心里，看看健康的电影，听听音乐，找几个朋友聊聊天。</li>\n</ul>\n<p>扫地最厉害的人是谁？很可能顶多是扫地组的组长，例如杭州西湖区环境保护临时工中的小组长，种地种最厉害的？炒菜炒最厉害的？那一样，写程序最厉害的，很可能就是项目组组长，人嘛都想老板，但是都不想付出老板的艰辛。\n真想巨大成功，就走出来自己干，就知道有多难打工还是很舒服每个月按时发工资，压力也是大家一起承担，周末还可以休息，晚上可能也不用加班。</p>\n<p>迷茫的时候，看看我的博客，就会好很多了。</p>\n<h3 id=\"-\">幸福有很多种类：</h3>\n<ul>\n<li>你有年轻漂亮的老婆。</li>\n<li>你有健康聪明的小宝宝。</li>\n<li>你有一个强壮的身体。</li>\n<li>你会唱歌跳舞多多才多艺。</li>\n<li>你喜欢钓鱼，绣花。</li>\n<li>吉日嘎拉喜欢写几篇软文，看看别人的回复就其乐无穷，偶尔看看网络上美女图片，看看美国大片，都是其乐无穷的事情，偶尔鼓励一下小朋友，跟老朋友聚聚，吃吃喝喝都是很快乐很幸福的。</li>\n</ul>\n<p>人人都想当比尔盖茨，可惜你没那样的妈妈（IBM的高级主管？），也没那样的爸爸（纽约著名律师？），今天也考不上那样的大学（哈佛很好考吗？），更不可能支付那么高的费用购买别人的软件产品（按当年的美元计算，当年一个月工资多少，现在多少，按当年的汇率折算，30-40年后现在让你支付这些费用，也很可能买不起当年的DOS什么的版权）。\n成功很多时候不是偶然的，很多是必然的，有几个国家领导人是普通老百姓？都是高干子女居多。\n从农村的大山沟里能爬出来到中国的人间天堂定居生活也知足了，知足常乐，不能跟自己过不去。</p>\n","like":1}
{"_id":{"$oid":"570b9928fb9b3da5431e5311"},"title":"Viewport 单位: vw, vh, vmin, vmax","classid":"300","content":"随着CSS3的普及，大家对 Viewport 一定不会陌生，尤其是在移动设备上，今天向大家介绍一种Viewport单位，这个单位看起来不是很起眼，但是用起来绝对要爽到爆。他们就是 `vm`, `vh`, `vmin`, `vmax`。\r\n\r\n## 要它做什么？？\r\n\r\n前端界这么多新的熊孩子，这家伙又是干嘛的呢？我为什么要去学习它呢？\r\n\r\n卖个关子，先让我们看一下Demo\r\n\r\n![Demo](http://static.zhuwenlong.com/upload/article/20160411193401-abc.gif)\r\n\r\n仔细看，这里有这么几点值得我们探讨的：\r\n\r\n 1. 首先是文字的大小：\r\n\r\n  细心的小伙伴应该发现了，文字的大小随着窗口宽度变化而变化，窗口宽度小文字的大小也小，反之亦然，正常情况下想要用CSS实现这种效果可不是那么的容易。\r\n\r\n 2. 其次是高度：\r\n\r\n  灰色框的高度始终和屏幕高度一致，如果是传统的CSS中，我们得这样写：\r\n    ```CSS\r\n\thtml,body {\r\n\t\theight: 100%;\r\n\t}\r\n\t.box {\r\n\t\theight: 100%\r\n\t}\r\n\t```\r\n\t\r\n\t 其中前3行是要指定`html`和`body`的高度，为什么这样做呢？因为dom高度是参照父节点所计算而来的，如果不指定父节点的height，子节点也无法实现100%的高度。\r\n\t\t\r\n 注意看，文字的行高也始终和窗口的高度保持一致。\r\n\r\n## 怎么做？！\r\n\r\n看了上面的Demo，一定很想知道是如何实现的，先来猜猜其中主要代码需要几行？\r\n\r\n20行？ 10行？ 5行？ \r\n\r\nNo! 核心代码其实只要3行！！怎么样惊呆了吧，哈哈，让我们来瞧瞧到底写了什么：\r\n\r\n```CSS\r\nhtml, body{\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\n.title {\r\n  /*重要的3行代码*/\r\n  font-size: 5vw;\r\n  height: 100vh;\r\n  line-height: 100vh;\r\n  /********/\r\n  text-align: center;\r\n  background: grey;\r\n}\r\n```\r\n\r\n其中除了.title的前3行外，其他的都是为了美观而写的，其实可以略去，所以3行代码足以实现上面的效果，是不是很神奇？\r\n\r\n## 为什么！！\r\n\r\n之所以3行代码就解决了这些主要还是靠这几个熊孩子的帮忙: `vw`, `vh`, `vmax`, `vmin`。那他们究竟是做什么的呢？看了下面的公式应该就清楚了：\r\n\r\n* 1vw = 百分之一的viewport宽度（如果视窗宽度为1200px，那么1vw就是12px）\r\n* 1vh = 百分之一的viewport高度\r\n* 1vmin = 百分之一viewport的width和height中小的（如果视窗宽度1200px，高度800px，1vmin就等于8px，因为1200px和800px中800px小）\r\n* 1vmax = 百分之一viewport的width和height中大的\r\n\r\n其实还是很简单的4个公式，说到这里英语不好的小伙伴一定在嘀咕“我去，又是4个奇怪的单词，如何记忆？”，其实仔细看你会发现这些单位其实就是2个单词拼接起来的，其中 v = viewport , w = width , h = height, 宽度就是 viewport + width = vw, 最大宽度就是 viewport + max = vmax，然后在记忆一下他们的单位是1%然后就大功告成了。\r\n\r\n## 可以用么？\r\n\r\n目前他的兼容性如下：\r\n\r\n* Firefox主流版本（45）支持\r\n* Chrome主流版本（49）支持\r\n* Chrome for Android（49）支持\r\n* Safari主流版本（9.1）支持\r\n* Opera主流版本（36）支持\r\n* iOS Safari 主流版本（9.2）支持\r\n* Opera主流版本（36）支持\r\n* Android Browser主流版本（47）\r\n* IE9+部分支持，其中vm取代vmin\r\n* Edge 部分支持\r\n\r\n具体可以前往 [Can I Use](http://caniuse.com/) 查看\r\n\r\n可见除了微软家族外，其他的浏览器都是挺友好的，使用的时候考虑到平缓退化，应该问题不大。\r\n\r\n如：\r\n\r\n```CSS\r\nfont-size: 18px;\r\nfont-size: 4vw;\r\n```\r\n\r\nok，就写到这里了，有什么问题可以随时给我留言。\r\n","visited":721,"comment":5,"pubtime":{"$date":1460377616301},"html":"<p>随着CSS3的普及，大家对 Viewport 一定不会陌生，尤其是在移动设备上，今天向大家介绍一种Viewport单位，这个单位看起来不是很起眼，但是用起来绝对要爽到爆。他们就是 <code>vm</code>, <code>vh</code>, <code>vmin</code>, <code>vmax</code>。</p>\n<h2 id=\"-\">要它做什么？？</h2>\n<p>前端界这么多新的熊孩子，这家伙又是干嘛的呢？我为什么要去学习它呢？</p>\n<p>卖个关子，先让我们看一下Demo</p>\n<p><img src=\"http://static.zhuwenlong.com/upload/article/20160411193401-abc.gif\" alt=\"Demo\"></p>\n<p>仔细看，这里有这么几点值得我们探讨的：</p>\n<ol>\n<li><p>首先是文字的大小：</p>\n<p>细心的小伙伴应该发现了，文字的大小随着窗口宽度变化而变化，窗口宽度小文字的大小也小，反之亦然，正常情况下想要用CSS实现这种效果可不是那么的容易。</p>\n</li>\n<li><p>其次是高度：</p>\n<p>灰色框的高度始终和屏幕高度一致，如果是传统的CSS中，我们得这样写：</p>\n<pre><code class=\"lang-CSS\">html,body {\n    height: 100%;\n}\n.box {\n    height: 100%\n}\n</code></pre>\n<p> 其中前3行是要指定<code>html</code>和<code>body</code>的高度，为什么这样做呢？因为dom高度是参照父节点所计算而来的，如果不指定父节点的height，子节点也无法实现100%的高度。</p>\n<p>注意看，文字的行高也始终和窗口的高度保持一致。</p>\n</li>\n</ol>\n<h2 id=\"-\">怎么做？！</h2>\n<p>看了上面的Demo，一定很想知道是如何实现的，先来猜猜其中主要代码需要几行？</p>\n<p>20行？ 10行？ 5行？ </p>\n<p>No! 核心代码其实只要3行！！怎么样惊呆了吧，哈哈，让我们来瞧瞧到底写了什么：</p>\n<pre><code class=\"lang-CSS\">html, body{\n  margin: 0;\n  padding: 0;\n}\n\n.title {\n  /*重要的3行代码*/\n  font-size: 5vw;\n  height: 100vh;\n  line-height: 100vh;\n  /********/\n  text-align: center;\n  background: grey;\n}\n</code></pre>\n<p>其中除了.title的前3行外，其他的都是为了美观而写的，其实可以略去，所以3行代码足以实现上面的效果，是不是很神奇？</p>\n<h2 id=\"-\">为什么！！</h2>\n<p>之所以3行代码就解决了这些主要还是靠这几个熊孩子的帮忙: <code>vw</code>, <code>vh</code>, <code>vmax</code>, <code>vmin</code>。那他们究竟是做什么的呢？看了下面的公式应该就清楚了：</p>\n<ul>\n<li>1vw = 百分之一的viewport宽度（如果视窗宽度为1200px，那么1vw就是12px）</li>\n<li>1vh = 百分之一的viewport高度</li>\n<li>1vmin = 百分之一viewport的width和height中小的（如果视窗宽度1200px，高度800px，1vmin就等于8px，因为1200px和800px中800px小）</li>\n<li>1vmax = 百分之一viewport的width和height中大的</li>\n</ul>\n<p>其实还是很简单的4个公式，说到这里英语不好的小伙伴一定在嘀咕“我去，又是4个奇怪的单词，如何记忆？”，其实仔细看你会发现这些单位其实就是2个单词拼接起来的，其中 v = viewport , w = width , h = height, 宽度就是 viewport + width = vw, 最大宽度就是 viewport + max = vmax，然后在记忆一下他们的单位是1%然后就大功告成了。</p>\n<h2 id=\"-\">可以用么？</h2>\n<p>目前他的兼容性如下：</p>\n<ul>\n<li>Firefox主流版本（45）支持</li>\n<li>Chrome主流版本（49）支持</li>\n<li>Chrome for Android（49）支持</li>\n<li>Safari主流版本（9.1）支持</li>\n<li>Opera主流版本（36）支持</li>\n<li>iOS Safari 主流版本（9.2）支持</li>\n<li>Opera主流版本（36）支持</li>\n<li>Android Browser主流版本（47）</li>\n<li>IE9+部分支持，其中vm取代vmin</li>\n<li>Edge 部分支持</li>\n</ul>\n<p>具体可以前往 <a href=\"http://caniuse.com/\">Can I Use</a> 查看</p>\n<p>可见除了微软家族外，其他的浏览器都是挺友好的，使用的时候考虑到平缓退化，应该问题不大。</p>\n<p>如：</p>\n<pre><code class=\"lang-CSS\">font-size: 18px;\nfont-size: 4vw;\n</code></pre>\n<p>ok，就写到这里了，有什么问题可以随时给我留言。</p>\n","like":12}
{"_id":{"$oid":"53995f446b13b74d15000001"},"title":"Flexbox 布局完全解析","classid":"100","content":"# Flexbox 布局完全解析\r\n\r\n最近看到不少，关于布局的讨论，有用百分比自适应的，有用Table layout的，还有用媒体查询的，方法各式各样，每个都可以乐此不疲的讨论个大半天。不过话又说回来，程序员，尤其是搞前端的大多都是喜新厌旧的，这里准备非常非常非常详细的说一下Flexbox布局模式。\r\n\r\nFlexbox Layout 模式，旨在实现更方便，更有效的进行布局，很久以前，在我第一次接触到这家伙的时候确实被深深的吸引了。\r\n\r\n## Flexbox相关名词\r\n\r\n![Flexbox](http://static.zhuwenlong.com/upload/article/flex_terms.png)\r\n\r\n（ 图片来源：https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes ）\r\n\r\n感谢MDN，Flexbox的相关名词这里已经标注的足够清楚了，就不一一的去介绍他们了。\r\n\r\n\r\n## Flexbox细节\r\n\r\n在进行Flexbox布局之前，我们要明确一点，Flexbox不应该理解成一个简单的属性，他有一个很完整的结构：容器（container）和部件（items）。所有的部件是基于容器来布局的。容器相当于一个大的房子，然后items相当于房子里面的家具，所有的家具都是相对于房子来布局的，并且一般情况下这些家具都是在房子内部的。\r\n\r\n![Container and items](http://static.zhuwenlong.com/upload/article/contantAndItems.jpg)\r\n\r\n### Container 容器\r\n\r\n\r\n#### display\r\n\r\n现在我们一起来建一栋房子（Flexbox布局的容器），这一步很简单，只要简单的通过display来进行定义就可以了。\r\n\r\n```css\r\n.container{\r\n\tdisplay: flex; /*或者 inline-flex */\r\n}\r\n```\r\n\r\n#### flex-direction\r\n\r\n有了房子之后我们就可以在房子里面放置家具了。假设我们的家具必须按顺序排序（先放1号家具，再放2号家具……），那么作为房子的主人，我可以更具自己的喜好，来选择家具放置的方向（横向排、纵向排、正序排、逆序排），这时候就要用到 `flex-direction` 了\r\n\r\n![flex-direction](http://static.zhuwenlong.com/upload/article/decoration.jpg)\r\n\r\n```css\r\n.container{\r\n\tflex-direction: row | row-reverse | column | column-reverse;\r\n}\r\n```\r\n\r\nflex-direction 有下面几个可用的值: \r\n\r\nflex-direction:\r\n\r\n- row : 默认方向，横排，从左到右\r\n- row-reverse  横排，从又到粽\r\n- column  纵排，从上到下\r\n- column-reverse  纵排，从下到上\r\n\r\n#### flex-wrap\r\n\r\n当我们把所有的家具完整的摆成一排之后，突然发现了这样一个问题，还有2件家具没有地方放怎么办？\r\n这时候 `flex-wrap` 就派上用场了，它用来指定一排的情况下多余的元素如何处理，他有下面的几个属性：\r\n\r\n```css\r\n.container{\r\n\tflex-wrap: nowrap | wrap | wrap-reverse;\r\n}\r\n```\r\n\r\nflex-wrap:\r\n\r\n- nowrap : 不换行\r\n- wrap : 正常换行\r\n- wrap-reverse : 反转换行\r\n\r\n先说 `flex-wrap:wrap` ，这个很好理解，一排放不下的情况下我可以再换一行来放置我的“家具”。\r\n\r\n再说`flex-wrap:wrap-reverse` ，字面上是反转换行，但是这个反转是什么意思呢？经过实验可以很容易的发现，它反转的仅仅是 `cross axis` 而 `main axis` 木有被反转(如果不明白什么是`cross axis`和`main axis`的话，请仔细再看一下前面的术语介绍的图片)，这一点比较出乎我们的意料，需要特别留意。\r\n\r\n最后说 `flex-wrap:nowrap` 如果“家具”刚好一排能放得下，那么会很好理解，但是！如果一排放不下怎么办？如果你沿着墙把所有的部件都放好之后，发现还有3个家具不够放，但是我一定要你放成一排，你会怎么做？杀了我？也许！ 但是机器并不会杀了我们，他们会采取妥协的方案，等比缩小所有元素的宽度，以放下全部的部件，是不是听起来很反人类？\r\n\r\n![flex-wrap](http://static.zhuwenlong.com/upload/article/flex-wrap.jpg)\r\n\r\n\r\n#### flex-flow\r\n\r\n程序员们都是很懒的，因此他们发明了简写，上面介绍了 `flex-direction` 和 `flex-wrap` ， 如果我同时想指定方向和换行岂不是要写两行？\r\n\r\n```css\r\n.container{\r\n\tflex-direction: row ;\r\n\tflex-wrap: nowrap ;\r\n}\r\n```\r\n\r\nNo! No! No! 我们有更加简单的写法\r\n\r\n```css\r\n.container{\r\n\tflex-flow: row nowrap ;\r\n}\r\n```\r\n\r\n没错！flex-flow就是为了这个场景而诞生的！\r\n\r\n```css\r\n.container{\r\n\tflex-flow: <‘flex-direction’> || <‘flex-wrap’>\r\n}\r\n```\r\n\r\n#### justify-content\r\n\r\n极端情况我们都解决了，现在考虑一下比较宽松的情况吧，如果我的家具不够排一排，这时候，我又想让他们看起来比较美观的话，我可以通过修改他们的对齐方式来实现：\r\n\r\n```css\r\n.container {\r\n  justify-content: flex-start | flex-end | center | space-between | space-around;\r\n}\r\n```\r\n\r\njustify-content:\r\n\r\n-flex-start: 常规模式，以 `main start` 为对齐点\r\n-flex-end: 以 `main end` 为对齐点\r\n-center: 居中对齐\r\n-space-between: 两边紧贴 `main start` 和 `main end` 中间平均分部\r\n-space-around: 平均分部\r\n\r\n![justify-content](http://static.zhuwenlong.com/upload/article/justify-content.jpg)\r\n\r\n#### align-items\r\n\r\n在垂直方向我们有 `align-items` 来处理\r\n\r\n```css\r\n.container {\r\n  align-items: flex-start | flex-end | center | baseline | stretch;\r\n}\r\n```\r\n\r\nalign-items:\r\n\r\n-flex-start: 以 ` cross-start ` 为对齐点\r\n-flex-end:  以 ` cross-end ` 为对齐点\r\n-center: 居中\r\n-baseline: 文字的基础线\r\n-stretch: 自动伸缩\r\n\r\n![align-items](http://static.zhuwenlong.com/upload/article/align-items.jpg)\r\n\r\n\r\n### Items (部件)\r\n\r\n#### order\r\n默认情况下，flex部件是按照代码的顺序排序的，我们可以使用`order`在不改变代码的情况下，修改他们的顺序。\r\n\r\n```css\r\n.item {\r\n  order: <integer>;\r\n}\r\n```\r\n\r\n![order](http://static.zhuwenlong.com/upload/article/order.jpg)\r\n\r\n#### flex-grow\r\n\r\n这个属性比较特殊，grow的意思是生长，也就是说，当我的所有元素排成一排之后，剩下的空间如何去分配。\r\n\r\n```css\r\n.item {\r\n  flex-grow: <number>; /* default 0 */\r\n}\r\n```\r\n\r\n这里的grow值可以理解成，占用剩余部分的份数，比如说空余部分是230px，然后我们指定的grow一个是7，一个是3，这样的话会吧空余的部分分成10份（7+3）每份的宽度是23px(230/10)，然后第一个grow占用7份也就是161px（7\\*23），另一个占用69px(3\\*23)\r\n\r\n![flex-grow](http://static.zhuwenlong.com/upload/article/flex-grew.jpg)\r\n\r\n#### flex-shrink\r\n\r\n损耗比例，和`flex-grow`相反,如果容器无法放下指定的部件，那么就会平均缩小每个部件的宽度，已到达发下这么多部件的目的。\r\n例如：Contenter的宽度是100px，然后里面有2个宽度为100px的部件，那么如果你指定了不换行的话，浏览器会自动的将这2个部件的宽度同比缩小，即每个的宽度都为50px，这样这2个部件就能放的下了。\r\n但是，有这么一种情况，对于A、B两个部件，A说：我比B牛逼，我不要和B缩小一样的空间，我缩小的空间永远是B的一半！\r\n这时候我们就用到了`flex-shrink`\r\n\r\n```css\r\n.A { flex:1 1 100px;  }\r\n.B { flex:1 2 100px; }\r\n/*flex: 1 1 100px 是 flex-grow: 1, flex-shrink: 1, flex-basis: 20em 的简写*/\r\n```\r\n\r\n这样A，B容器的宽度就分别为67px，33px\r\n\r\n#### flex-basis\r\n\r\n指定初始化时候的item的宽度，即`main size`，后面的`flex-grow`,`flex-shrink`都是在这个基础上进行计算的。\r\n\r\n```css\r\n.item {\r\n  flex-basis: <length> | auto; /* 默认 auto */\r\n}\r\n```\r\n\r\n#### flex\r\n\r\n前面也说到了，flex是 `flex-grow` , `flex-shrink` 和 `flex-basis`的简写\r\n\r\n```css\r\n.item {\r\n  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\r\n}\r\n```\r\n\r\n#### align-self\r\n\r\n效果类似`align-items`(上面有介绍)，只不过他是针对一个部件来说的，而不是所有的部件。\r\n\r\n```css\r\n.item {\r\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\r\n}\r\n```\r\n\r\n### 综合应用\r\n\r\n好了，让我们看一个简单的Demo，通过flex实现的一个宽度自适应的布局模型。\r\n\r\n[点击这里查看Demo（如果Demo无法预览，请在评论中告诉我，我会把demo发到你的邮箱中）](http://codepen.io/mofei/pen/pnklz)\r\n\r\n![order](http://static.zhuwenlong.com/upload/article/demo.jpg)\r\n\r\n[点击这里查看Demo（如果Demo无法预览，请在评论中告诉我，我会把demo发到你的邮箱中）](http://codepen.io/mofei/pen/pnklz)\r\n\r\n### 参考\r\n\r\n- [A Complete Guide to Flexbox](http://css-tricks.com/snippets/css/a-guide-to-flexbox/?utm_source=html5weekly&utm_medium=email)\r\n- [MDN-flex](https://developer.mozilla.org/en-US/docs/Web/CSS/flex)\r\n- [Using CSS flexible boxes](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes )\r\n\r\n\r\n","visited":6941,"comment":2,"pubtime":{"$date":1402560324734},"links":[["51d3dd0a8ece70c438000008",{"present":0.025641025641025640136,"title":"IE下“怪异模式”的触发  "}],["528611f363c705fc73000001",{"present":0.025641025641025640136,"title":"javascript 文字大小自动适应文本框 （文字大小自动调整）"}]],"html":"<h1 id=\"flexbox-\">Flexbox 布局完全解析</h1>\n<p>最近看到不少，关于布局的讨论，有用百分比自适应的，有用Table layout的，还有用媒体查询的，方法各式各样，每个都可以乐此不疲的讨论个大半天。不过话又说回来，程序员，尤其是搞前端的大多都是喜新厌旧的，这里准备非常非常非常详细的说一下Flexbox布局模式。</p>\n<p>Flexbox Layout 模式，旨在实现更方便，更有效的进行布局，很久以前，在我第一次接触到这家伙的时候确实被深深的吸引了。</p>\n<h2 id=\"flexbox-\">Flexbox相关名词</h2>\n<p><img src=\"http://static.zhuwenlong.com/upload/article/flex_terms.png\" alt=\"Flexbox\"></p>\n<p>（ 图片来源：<a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes\">https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes</a> ）</p>\n<p>感谢MDN，Flexbox的相关名词这里已经标注的足够清楚了，就不一一的去介绍他们了。</p>\n<h2 id=\"flexbox-\">Flexbox细节</h2>\n<p>在进行Flexbox布局之前，我们要明确一点，Flexbox不应该理解成一个简单的属性，他有一个很完整的结构：容器（container）和部件（items）。所有的部件是基于容器来布局的。容器相当于一个大的房子，然后items相当于房子里面的家具，所有的家具都是相对于房子来布局的，并且一般情况下这些家具都是在房子内部的。</p>\n<p><img src=\"http://static.zhuwenlong.com/upload/article/contantAndItems.jpg\" alt=\"Container and items\"></p>\n<h3 id=\"container-\">Container 容器</h3>\n<h4 id=\"display\">display</h4>\n<p>现在我们一起来建一栋房子（Flexbox布局的容器），这一步很简单，只要简单的通过display来进行定义就可以了。</p>\n<pre><code class=\"lang-css\">.container{\n    display: flex; /*或者 inline-flex */\n}\n</code></pre>\n<h4 id=\"flex-direction\">flex-direction</h4>\n<p>有了房子之后我们就可以在房子里面放置家具了。假设我们的家具必须按顺序排序（先放1号家具，再放2号家具……），那么作为房子的主人，我可以更具自己的喜好，来选择家具放置的方向（横向排、纵向排、正序排、逆序排），这时候就要用到 <code>flex-direction</code> 了</p>\n<p><img src=\"http://static.zhuwenlong.com/upload/article/decoration.jpg\" alt=\"flex-direction\"></p>\n<pre><code class=\"lang-css\">.container{\n    flex-direction: row | row-reverse | column | column-reverse;\n}\n</code></pre>\n<p>flex-direction 有下面几个可用的值: </p>\n<p>flex-direction:</p>\n<ul>\n<li>row : 默认方向，横排，从左到右</li>\n<li>row-reverse  横排，从又到粽</li>\n<li>column  纵排，从上到下</li>\n<li>column-reverse  纵排，从下到上</li>\n</ul>\n<h4 id=\"flex-wrap\">flex-wrap</h4>\n<p>当我们把所有的家具完整的摆成一排之后，突然发现了这样一个问题，还有2件家具没有地方放怎么办？\n这时候 <code>flex-wrap</code> 就派上用场了，它用来指定一排的情况下多余的元素如何处理，他有下面的几个属性：</p>\n<pre><code class=\"lang-css\">.container{\n    flex-wrap: nowrap | wrap | wrap-reverse;\n}\n</code></pre>\n<p>flex-wrap:</p>\n<ul>\n<li>nowrap : 不换行</li>\n<li>wrap : 正常换行</li>\n<li>wrap-reverse : 反转换行</li>\n</ul>\n<p>先说 <code>flex-wrap:wrap</code> ，这个很好理解，一排放不下的情况下我可以再换一行来放置我的“家具”。</p>\n<p>再说<code>flex-wrap:wrap-reverse</code> ，字面上是反转换行，但是这个反转是什么意思呢？经过实验可以很容易的发现，它反转的仅仅是 <code>cross axis</code> 而 <code>main axis</code> 木有被反转(如果不明白什么是<code>cross axis</code>和<code>main axis</code>的话，请仔细再看一下前面的术语介绍的图片)，这一点比较出乎我们的意料，需要特别留意。</p>\n<p>最后说 <code>flex-wrap:nowrap</code> 如果“家具”刚好一排能放得下，那么会很好理解，但是！如果一排放不下怎么办？如果你沿着墙把所有的部件都放好之后，发现还有3个家具不够放，但是我一定要你放成一排，你会怎么做？杀了我？也许！ 但是机器并不会杀了我们，他们会采取妥协的方案，等比缩小所有元素的宽度，以放下全部的部件，是不是听起来很反人类？</p>\n<p><img src=\"http://static.zhuwenlong.com/upload/article/flex-wrap.jpg\" alt=\"flex-wrap\"></p>\n<h4 id=\"flex-flow\">flex-flow</h4>\n<p>程序员们都是很懒的，因此他们发明了简写，上面介绍了 <code>flex-direction</code> 和 <code>flex-wrap</code> ， 如果我同时想指定方向和换行岂不是要写两行？</p>\n<pre><code class=\"lang-css\">.container{\n    flex-direction: row ;\n    flex-wrap: nowrap ;\n}\n</code></pre>\n<p>No! No! No! 我们有更加简单的写法</p>\n<pre><code class=\"lang-css\">.container{\n    flex-flow: row nowrap ;\n}\n</code></pre>\n<p>没错！flex-flow就是为了这个场景而诞生的！</p>\n<pre><code class=\"lang-css\">.container{\n    flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;\n}\n</code></pre>\n<h4 id=\"justify-content\">justify-content</h4>\n<p>极端情况我们都解决了，现在考虑一下比较宽松的情况吧，如果我的家具不够排一排，这时候，我又想让他们看起来比较美观的话，我可以通过修改他们的对齐方式来实现：</p>\n<pre><code class=\"lang-css\">.container {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n</code></pre>\n<p>justify-content:</p>\n<p>-flex-start: 常规模式，以 <code>main start</code> 为对齐点\n-flex-end: 以 <code>main end</code> 为对齐点\n-center: 居中对齐\n-space-between: 两边紧贴 <code>main start</code> 和 <code>main end</code> 中间平均分部\n-space-around: 平均分部</p>\n<p><img src=\"http://static.zhuwenlong.com/upload/article/justify-content.jpg\" alt=\"justify-content\"></p>\n<h4 id=\"align-items\">align-items</h4>\n<p>在垂直方向我们有 <code>align-items</code> 来处理</p>\n<pre><code class=\"lang-css\">.container {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n</code></pre>\n<p>align-items:</p>\n<p>-flex-start: 以 <code>cross-start</code> 为对齐点\n-flex-end:  以 <code>cross-end</code> 为对齐点\n-center: 居中\n-baseline: 文字的基础线\n-stretch: 自动伸缩</p>\n<p><img src=\"http://static.zhuwenlong.com/upload/article/align-items.jpg\" alt=\"align-items\"></p>\n<h3 id=\"items-\">Items (部件)</h3>\n<h4 id=\"order\">order</h4>\n<p>默认情况下，flex部件是按照代码的顺序排序的，我们可以使用<code>order</code>在不改变代码的情况下，修改他们的顺序。</p>\n<pre><code class=\"lang-css\">.item {\n  order: &lt;integer&gt;;\n}\n</code></pre>\n<p><img src=\"http://static.zhuwenlong.com/upload/article/order.jpg\" alt=\"order\"></p>\n<h4 id=\"flex-grow\">flex-grow</h4>\n<p>这个属性比较特殊，grow的意思是生长，也就是说，当我的所有元素排成一排之后，剩下的空间如何去分配。</p>\n<pre><code class=\"lang-css\">.item {\n  flex-grow: &lt;number&gt;; /* default 0 */\n}\n</code></pre>\n<p>这里的grow值可以理解成，占用剩余部分的份数，比如说空余部分是230px，然后我们指定的grow一个是7，一个是3，这样的话会吧空余的部分分成10份（7+3）每份的宽度是23px(230/10)，然后第一个grow占用7份也就是161px（7*23），另一个占用69px(3*23)</p>\n<p><img src=\"http://static.zhuwenlong.com/upload/article/flex-grew.jpg\" alt=\"flex-grow\"></p>\n<h4 id=\"flex-shrink\">flex-shrink</h4>\n<p>损耗比例，和<code>flex-grow</code>相反,如果容器无法放下指定的部件，那么就会平均缩小每个部件的宽度，已到达发下这么多部件的目的。\n例如：Contenter的宽度是100px，然后里面有2个宽度为100px的部件，那么如果你指定了不换行的话，浏览器会自动的将这2个部件的宽度同比缩小，即每个的宽度都为50px，这样这2个部件就能放的下了。\n但是，有这么一种情况，对于A、B两个部件，A说：我比B牛逼，我不要和B缩小一样的空间，我缩小的空间永远是B的一半！\n这时候我们就用到了<code>flex-shrink</code></p>\n<pre><code class=\"lang-css\">.A { flex:1 1 100px;  }\n.B { flex:1 2 100px; }\n/*flex: 1 1 100px 是 flex-grow: 1, flex-shrink: 1, flex-basis: 20em 的简写*/\n</code></pre>\n<p>这样A，B容器的宽度就分别为67px，33px</p>\n<h4 id=\"flex-basis\">flex-basis</h4>\n<p>指定初始化时候的item的宽度，即<code>main size</code>，后面的<code>flex-grow</code>,<code>flex-shrink</code>都是在这个基础上进行计算的。</p>\n<pre><code class=\"lang-css\">.item {\n  flex-basis: &lt;length&gt; | auto; /* 默认 auto */\n}\n</code></pre>\n<h4 id=\"flex\">flex</h4>\n<p>前面也说到了，flex是 <code>flex-grow</code> , <code>flex-shrink</code> 和 <code>flex-basis</code>的简写</p>\n<pre><code class=\"lang-css\">.item {\n  flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]\n}\n</code></pre>\n<h4 id=\"align-self\">align-self</h4>\n<p>效果类似<code>align-items</code>(上面有介绍)，只不过他是针对一个部件来说的，而不是所有的部件。</p>\n<pre><code class=\"lang-css\">.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n</code></pre>\n<h3 id=\"-\">综合应用</h3>\n<p>好了，让我们看一个简单的Demo，通过flex实现的一个宽度自适应的布局模型。</p>\n<p><a href=\"http://codepen.io/mofei/pen/pnklz\">点击这里查看Demo（如果Demo无法预览，请在评论中告诉我，我会把demo发到你的邮箱中）</a></p>\n<p><img src=\"http://static.zhuwenlong.com/upload/article/demo.jpg\" alt=\"order\"></p>\n<p><a href=\"http://codepen.io/mofei/pen/pnklz\">点击这里查看Demo（如果Demo无法预览，请在评论中告诉我，我会把demo发到你的邮箱中）</a></p>\n<h3 id=\"-\">参考</h3>\n<ul>\n<li><a href=\"http://css-tricks.com/snippets/css/a-guide-to-flexbox/?utm_source=html5weekly&amp;utm_medium=email\">A Complete Guide to Flexbox</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/flex\">MDN-flex</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes\">Using CSS flexible boxes</a></li>\n</ul>\n"}
{"_id":{"$oid":"51d3de828ece70c43800000e"},"classid":"100","comment":0,"content":"让你的网站与最新的网络标准兼容\r\n文档兼容性定义了一个浏览器将如何呈现你的网站。把自己的要求对浏览器告诉得越详细，用户的体验就会越好。在使用HTML5这样的Web标准时，一开始就要明确地声明HTML5的文档类型：\r\n\r\n这个标记将触发在IE9和IE10中的标准模式，它在Chrome和Firefox中也工作得非常好。以下4个步骤可以使你的网站在各种浏览器和设备上呈现：\r\n\r\n   \r\n第1步：确认你的网站使用的是标准模式\r\n检查网站目前是否处于标准模式：\r\n       1.在IE10平台预览版中打开网站。\r\n           注意：也可以按相同步骤更新IE9中的文档模式，这无需下载预览版。\r\n       2.按F12键启动IE开发人员工具，或在Tools（工具）菜单中找到它\r\n           注意：如果不习惯使用IE F12开发人员工具来调试网页，请阅读链接教程。\r\n       3.检查网站是否显示“Browser Mode: IE10”和“Document Mode: IE10 standards”\r\n如果你的网站已经处于Browser Mode: IE10和Document Mode: IE10 standards状态，那么你已经完成了！注意，如果你的网站的浏览器模式和文档模式不是这样，一个常见的情况是Browser Mode = IE8和Document Mode = Quirks（浏览器模式=IE8，文档模式=Quirks），这表明网站是为旧版本IE设计的，可能不符合Web标准的要求。\r\n   \r\n\r\n   \r\n第2步：实现Web标准下的文档模式\r\n强制使用IE10标准模式来测试你的网站：\r\n将以下标签\r\n\r\n插入网站的HTML页面中\r\n要了解如何更新doctype，请参阅这里。\r\n在浏览器中重新加载页面，使用F12开发人员工具再次检查浏览器模式和文档模式。如果没有显示Browser Mode: IE10和Document Mode: IE10 standards，请继续执行以下步骤。\r\n\r\n   \r\n第3步：判断网站未处于标准模式的原因\r\n很多问题与支持旧版本IE有关。先要保证基于标准的代码在IE9和IE10中正常呈现。然后再保留用于支持旧版本IE的非标准代码。\r\n\r\n   \r\n我的页面不是“Browser Mode: IE10”（浏览器模式：IE10）\r\n可能的原因：你的网站可能处于CompatibilityView（兼容性视图）中，被迫进入旧版浏览器模式以确保网站功能正常。\r\n解决办法：检查网站是否在这个列表内。要了解兼容性视图列表和请求从列表中移除的更多内容，请参阅这里。\r\n\r\n   \r\n我的网页不是“Document Mode =IE10”\r\n可能的原因：你的网站的doctype无效或缺失\r\n解决办法：检查是否使用了有效、格式正确的doctype，如下所示：\r\n\r\n    \r\n\r\n\r\n可能的原因：文档模式受到X-UA-Compatible这个元标签的强行限制要了解如何更新doctype，请参阅这里。\r\n解决办法：在页面上检查是否有类似下面的代码。\r\n\r\n第4步：在更新文档模式时，解决常见IE问题删除找到的代码，重新加载页面。继续测试。要了解如何指定文档兼容模式，请参阅这里。\r\n很多问题与支持旧版本IE有关。先要保证基于标准的代码在IE9和IE10中正常呈现。然后再保留用于支持旧版本IE的非标准代码。\r\n可能的原因：条件注释（conditionalcomment）支持不同浏览器版本相关的功能\r\n解决办法：检查是否存在运行非标准代码的条件注释。这些通常用来支持旧版本IE的特定功能，以便让页面在旧版本下可以实现优雅降级。请检查是否存在类似下面的代码：\r\n\r\n    \r\n可能的原因：用户代理监听支持浏览器版本相关的功能删除找到的代码，重新加载页面。继续测试。要了解条件注释的更多内容，请参阅这里。\r\n解决办法：检查是否存在用户代理监听。用户代理监听通过浏览器模式中存在的用户代理字符串（user agent string）来定位浏览器。请检查是否存在类似下面的代码：\r\n\r\n    if(version = /MSIE  (d+.d+)/.exec(navigator.userAgent)) {\r\n    isIE = true;\r\n    browserVersion = parseFloat(version[1]);\r\n}\r\n其他一些导致网页不能正常显示的原因：首先要用Web标准实现功能探测。要了解用户代理字符串的更多内容，请参阅这里。关于 IE10的用户代理字符串，请参阅这里。\r\n可能的原因：网站可能使用了浏览器已不再支持的特定功能。请尽可能使用Web标准。\r\n解决办法：运行兼容性检查工具。\r\n可能的原因：网站可能使用了Metro 下 IE10不支持的第三方插件或Flash、Quicktime和Silverlight。请尽可能使用Web标准。\r\n解决办法：学习如何创建不使用插件的体验。完整的基础教程很快就将推出。\r\n可能的原因：网站可能加载了特定版本的浏览器CSS文件：\r\n解决办法：确保布局尽可能避免CSS hack。要了解如何检查CSS问题，请参阅这里。\r\n\r\n   \r\nIECompatibility Cookbook中提供了一个常见问题清单。\r\n\r\n   \r\n如果你通过以上介绍的解决步骤还不能更新文档模式，请参考MSDN的论坛。\r\n更多细节，请参阅以下文章：\r\n\r\n   \r\n定义文档能力 @ MSDN\r\n调查文档模式的问题 @ MSDN\r\nIE10中互操作的Quirks模式 @ IE Blog\r\n兼容性检查工具（CompatibilityInspector tool） @ IETestDrive.com\r\n不要忘记添加Doctype @ W3C.org\r\n以上内容来自于：http://blog.reybango.com/2012/01/09/fix-common-ie-problems-update-your-docmode-for-web-standards/\r\n","pubtime":{"$date":1353018489516},"title":"Internet Explorer 10 兼容性白皮书（一） ","visited":26609,"links":[["51d3de8e8ece70c43800000f",{"present":0.052631578947368418131,"title":"Internet Explorer 10 兼容性白皮书（二） 用HTML5构建应用程序"}],["51d3dd0a8ece70c438000008",{"present":0.052631578947368418131,"title":"IE下“怪异模式”的触发  "}],["51d3dc538ece70c438000005",{"present":0.025641025641025640136,"title":"小心 -webkit-text-size-adjust:none！[译]"}],["52bd036287e7903949000001",{"present":0.025641025641025640136,"title":"怎样成长为一个优秀的 Web 前端开发工程师？"}],["52288399917d2e280e000001",{"present":0.025641025641025640136,"title":"给正在实习和将要实习的大学生——实习经验分享"}],["52300d0063c944475b000001",{"present":0.025641025641025640136,"title":"Atwood定律：“任何可以使用JavaScript来编写的应用，最终会由JavaScript编写。”"}],["51d3db7f8ece70c438000003",{"present":0.025641025641025640136,"title":"“登陆网站”还是“登录网站”"}],["51d3de628ece70c43800000c",{"present":0.025641025641025640136,"title":"onhashchange与AJAX无缝刷新"}],["52cfc44ad4cf86262b000001",{"present":0.025641025641025640136,"title":"HTML5 拖动（Drag）文件到文件夹下载"}],["51d3de728ece70c43800000d",{"present":0.025641025641025640136,"title":"javascript区分判断ie6、ie7、ie8"}]],"html":"<p>让你的网站与最新的网络标准兼容\n文档兼容性定义了一个浏览器将如何呈现你的网站。把自己的要求对浏览器告诉得越详细，用户的体验就会越好。在使用HTML5这样的Web标准时，一开始就要明确地声明HTML5的文档类型：</p>\n<p>这个标记将触发在IE9和IE10中的标准模式，它在Chrome和Firefox中也工作得非常好。以下4个步骤可以使你的网站在各种浏览器和设备上呈现：</p>\n<p>第1步：确认你的网站使用的是标准模式\n检查网站目前是否处于标准模式：\n       1.在IE10平台预览版中打开网站。\n           注意：也可以按相同步骤更新IE9中的文档模式，这无需下载预览版。\n       2.按F12键启动IE开发人员工具，或在Tools（工具）菜单中找到它\n           注意：如果不习惯使用IE F12开发人员工具来调试网页，请阅读链接教程。\n       3.检查网站是否显示“Browser Mode: IE10”和“Document Mode: IE10 standards”\n如果你的网站已经处于Browser Mode: IE10和Document Mode: IE10 standards状态，那么你已经完成了！注意，如果你的网站的浏览器模式和文档模式不是这样，一个常见的情况是Browser Mode = IE8和Document Mode = Quirks（浏览器模式=IE8，文档模式=Quirks），这表明网站是为旧版本IE设计的，可能不符合Web标准的要求。</p>\n<p>第2步：实现Web标准下的文档模式\n强制使用IE10标准模式来测试你的网站：\n将以下标签</p>\n<p>插入网站的HTML页面中\n要了解如何更新doctype，请参阅这里。\n在浏览器中重新加载页面，使用F12开发人员工具再次检查浏览器模式和文档模式。如果没有显示Browser Mode: IE10和Document Mode: IE10 standards，请继续执行以下步骤。</p>\n<p>第3步：判断网站未处于标准模式的原因\n很多问题与支持旧版本IE有关。先要保证基于标准的代码在IE9和IE10中正常呈现。然后再保留用于支持旧版本IE的非标准代码。</p>\n<p>我的页面不是“Browser Mode: IE10”（浏览器模式：IE10）\n可能的原因：你的网站可能处于CompatibilityView（兼容性视图）中，被迫进入旧版浏览器模式以确保网站功能正常。\n解决办法：检查网站是否在这个列表内。要了解兼容性视图列表和请求从列表中移除的更多内容，请参阅这里。</p>\n<p>我的网页不是“Document Mode =IE10”\n可能的原因：你的网站的doctype无效或缺失\n解决办法：检查是否使用了有效、格式正确的doctype，如下所示：</p>\n<p>可能的原因：文档模式受到X-UA-Compatible这个元标签的强行限制要了解如何更新doctype，请参阅这里。\n解决办法：在页面上检查是否有类似下面的代码。</p>\n<p>第4步：在更新文档模式时，解决常见IE问题删除找到的代码，重新加载页面。继续测试。要了解如何指定文档兼容模式，请参阅这里。\n很多问题与支持旧版本IE有关。先要保证基于标准的代码在IE9和IE10中正常呈现。然后再保留用于支持旧版本IE的非标准代码。\n可能的原因：条件注释（conditionalcomment）支持不同浏览器版本相关的功能\n解决办法：检查是否存在运行非标准代码的条件注释。这些通常用来支持旧版本IE的特定功能，以便让页面在旧版本下可以实现优雅降级。请检查是否存在类似下面的代码：</p>\n<p>可能的原因：用户代理监听支持浏览器版本相关的功能删除找到的代码，重新加载页面。继续测试。要了解条件注释的更多内容，请参阅这里。\n解决办法：检查是否存在用户代理监听。用户代理监听通过浏览器模式中存在的用户代理字符串（user agent string）来定位浏览器。请检查是否存在类似下面的代码：</p>\n<pre><code>if(version = /MSIE  (d+.d+)/.exec(navigator.userAgent)) {\nisIE = true;\nbrowserVersion = parseFloat(version[1]);\n</code></pre><p>}\n其他一些导致网页不能正常显示的原因：首先要用Web标准实现功能探测。要了解用户代理字符串的更多内容，请参阅这里。关于 IE10的用户代理字符串，请参阅这里。\n可能的原因：网站可能使用了浏览器已不再支持的特定功能。请尽可能使用Web标准。\n解决办法：运行兼容性检查工具。\n可能的原因：网站可能使用了Metro 下 IE10不支持的第三方插件或Flash、Quicktime和Silverlight。请尽可能使用Web标准。\n解决办法：学习如何创建不使用插件的体验。完整的基础教程很快就将推出。\n可能的原因：网站可能加载了特定版本的浏览器CSS文件：\n解决办法：确保布局尽可能避免CSS hack。要了解如何检查CSS问题，请参阅这里。</p>\n<p>IECompatibility Cookbook中提供了一个常见问题清单。</p>\n<p>如果你通过以上介绍的解决步骤还不能更新文档模式，请参考MSDN的论坛。\n更多细节，请参阅以下文章：</p>\n<p>定义文档能力 @ MSDN\n调查文档模式的问题 @ MSDN\nIE10中互操作的Quirks模式 @ IE Blog\n兼容性检查工具（CompatibilityInspector tool） @ IETestDrive.com\n不要忘记添加Doctype @ W3C.org\n以上内容来自于：<a href=\"http://blog.reybango.com/2012/01/09/fix-common-ie-problems-update-your-docmode-for-web-standards/\">http://blog.reybango.com/2012/01/09/fix-common-ie-problems-update-your-docmode-for-web-standards/</a></p>\n"}
{"_id":{"$oid":"51d3de8e8ece70c43800000f"},"classid":"100","comment":0,"content":"用HTML5构建应用程序\r\n\r\nHTML5的采用策略：一个浏览器也不放弃\r\n点击链接下载示例代码\r\nHTML5有许多激动人心的特性。有了新的标签、新的CSS能力和新的JavaScript API，Web的能力范围有了大的飞跃。除了浏览器厂商的士气高涨之外，令人激动的新功能列表几乎每天都在增加。从“nightly builds”（每夜都构建一版）到开发渠道发行版和正常的平台预览版，浏览器在飞速变化，世界各地Web开发人员们正在加入这个狂欢。\r\n\r\n但是，尽管开发和浏览器社区正在把HTML5的喧嚣推到一个极度兴奋的高潮，网上的大多数人却不像我们一样使用最新的浏览器和最新版本。如果你是一个大型开发机构的Web开发人员或者是拥有庞大用户群的大企业，那你对此可能很清楚。即使你为通过Web提供服务的小型机构或新创立的企业工作，你可能也要花上大量时间来确保自己的网站能够支持尽可能多的浏览器和浏览器版本。\r\n\r\n基于这一现实，很容易看出，HTML5还谈不到它是否已为当今的使用做好准备，而是你是否为它做好了准备。例如，假设你用一些新的语法标签（例如\r\n和\r\n）新建了一个页面，添加了一些新的CSS功能（例如圆角（border-radius）和阴影（box-shadow）），甚至添加了一个\r\n在较新的浏览器上，例如IE9、Firefox 4及以上版本、或者Google Chrome上。但如果尝试在IE8或更早的浏览器上加载页面，很有可能看到的是图2所示的效果：一个残缺不全的页面。\r\n如果你在研究HTML5的所有强大功能却得到上述体验之后告诉自己说：最好还是等等，那么我不会对你有任何责怪。如果我问你准备好了吗？你很容易得出这样的结论：HTML5还没有为你或你的用户做好准备。\r\n\r\n在你决定等到2022年再考虑HTML5的之前，我建议你继续阅读本文的后面部分，我将向你提供一些实用的策略，让你现在就能采用HTML5技术，同时避免出现图2所示的糟糕的降级情况。我将从下面三个主题进行详细地介绍：\r\n1.      功能检测与用户代理（UA）嗅探比较\r\n2.      用JavaScript实现填补（Polyfill）\r\n3.      优雅降级\r\n\r\n这些应该可以教会你很多构建支持各种浏览器的网站所需要了解的知识。在本文结束时，你会拥有一个可靠的策略，可以充满自信、毫不犹豫地采用HTML5技术。你还会拥有一些工具在手，可以逐步地为新浏览器增强网站，同时更好地适应旧的浏览器。\r\n\r\n功能检测的重要性\r\n\r\n为了提供跨浏览器的稳定且一致的体验，开发人员经常需要获得一些关于用户浏览器的信息。以前的普遍做法是像下面这样用JavaScript检测这些信息：\r\n\r\n\r\n    varuserAgent = navigator.userAgent;\r\n      \r\nif (userAgent.indexOf('MSIE') >= 0) {\r\n    console.log(\"Hello, IE user\");\r\n} else if (userAgent.indexOf('Firefox') >= 0) {\r\n    console.log(\"Hello, Firefox user\");\r\n} else if (userAgent.indexOf('Chrome') >= 0) {\r\n    console.log(\"Hello, Chrome user\");\r\n}\r\n这个技术称为用户代理（UA）嗅探，广泛地用于判断正在请求页面的是哪个浏览器。这里的思路是：知道了用户的浏览器（例如IE7），就能在运行的时候决定启用或禁用网站的哪项功能。UA嗅探就相当于对浏览器说：“你是谁？”（对UA嗅探以及其他检测技术的深入分析，请参阅bit.ly/mlgHHY。）\r\n这种做法的问题在于，浏览器会撒谎。UA字符串是一个用户可以配置的信息，并不会提供100%正确的浏览器信息。而且，随着这一技术的广泛采用，许多浏览器厂商在自己的UA字符串中增加了额外内容，用来欺骗脚本，让脚本对于实际使用的浏览器做出错误判断，从而避免检测。现在有些浏览器甚至提供小工具，允许用户只要轻轻点击几下鼠标，就能修改UA字符串。\r\nUA嗅探的目的从来就不是确定用户的浏览器和版本。而且它肯定也不是为了在你不喜欢用户使用的浏览器时，让你可以告诉用户说“请下载另一个浏览器”——即使有些人就是这样使用UA嗅探技术的。用户有权选择自己使用什么浏览器，开发人员的职责则是提供最可靠且一致的体验，不要把浏览器的偏好强加给用户。UA嗅探的目标是让你能够准确地了解在用户当前的浏览器中，有哪些能力或功能可以利用。对浏览器本身的了解，只是获得这些信息的一个途径。\r\n目前有一些UA嗅探的替代技术，其中一项正在日益流行的技术称为对象检测或功能检测。这两个术语多数时候可以互换使用，但本文统一使用“功能检测”（feature detection）。\r\n功能检测的目标是判断某项功能或能力在用户当前的浏览器中是否受支持。如果UA嗅探是问浏览器“你是谁”，“功能检测”就是问浏览器“你能干什么”，这个问题更直接，对于根据条件向用户提供功能来说，这种方法也更可靠。如果功能检测脚本实现正确，用户或浏览器将很难造假或错报功能支持。\r\n手动功能检测\r\n\r\n那么，与UA嗅探的示例相比，功能检测到底是什么样呢？为了回答这个问题，我们先来看看如果在IE8中查看前面的HTML5页面，如何解决出现的问题。\r\n\r\n    My Awesome SiteMy Awesome SiteAnArticleIsn't this awesome?\r\nIE9和IE8的显示效果有很大的差别。对于初学者来说，我的页面完全没有样式，因为这个页面的CSS并不存在。而且，页面底部丢失了好玩的HTML5盾牌。每个问题都可以轻松解决，而功能检测则是明确问题的第一步。\r\n两个问题的原因都很简单：对于IE8来说，\r\n、\r\n和\r\n\r\n    !!document.createElement('canvas').getContext\r\n这条语句做了好几件事。首先，它使用两个否定（!!）操作符强行将未定义的值显式地设为false。然后，它手动新建一个canvas元素，并将它加到DOM中。最后，它调用getContext函数，这是\r\n这是最基本的功能检测。利用这条语句以及其他类似语句，就有了查询浏览器所支持功能的更可靠方法。关于手动功能检测的更多信息，请参阅diveintohtml5.info/everything.html。\r\n使用Modernizr进行功能检测\r\n\r\n手动功能检测肯定是对UA嗅探的提高，但这种做法仍然需要你做大量工作来检测功能是否可用，以及在功能不存在的时候决定做什么。虽然Canvas示例很简单，只需要一行代码，但不是每个要检测的功能都这么简单——不同浏览器的检测代码也各不相同。例如，要检测是否支持前面使用的CSS3模块（border-radius和box-shadow）就有些麻烦。\r\n值得庆幸的是，Modernizr (modernizr.com) 提供了更好的方法。Modernizr是一个JavaScript库“……检测下一代 Web 技术（即源于HTML 5和CSS3规范的功能）的本地实现是否可用”。在页面上添加对Modernizr的引用可以提供四大功能：\r\n1.      全面列出支持的功能，智能地加入标签，从而实现CSS的条件定义。\r\n2.      一个JavaScript对象，方便进行基于脚本的功能检测。\r\n3.      在运行的时候将全部HTML5新标签加入DOM，方便IE8和之前的IE浏览器（稍后就会知道不仅如此）。\r\n4.      一个脚本加载器，可以根据条件将polyfill加载到页面中。\r\n本文对第1项不做进一步介绍，但鼓励你访问modernizr.com网站，学习这一功能及其余功能的文档。\r\n上面的第2项功能，可以将下面的代码：\r\n\r\n    !!document.createElement('canvas').getContext\r\n改为这行代码：\r\n\r\n    Modernizr.canvas\r\n这行代码会返回一个布尔值，表明页面是否支持Canvas元素。使用Modernizr比自行执行功能检测的好处是，Modernizr是一个经过良好测试、健壮的、广为采用的库，它已经完成了许多繁重的工作。Twitter、Google、Microsoft以及无数其他机构和开发人员都在使用Modernizr，你当然也可以使用。在ASP.NET MVC 3工具更新（2011年4月发布）中，Microsoft甚至随新的ASP.NET MVC应用程序一起配备了Modernizr。当然，我们迄今为止所做的，不过是检测是否支持\r\n\r\n    if (Modernizr.canvas) {\r\n  // 这里执行canvas代码。\r\n}\r\n根据附加的浏览器功能是否存在来给网站增加功能，这种做法称为“渐进式增强”，因为体验增强针对的能力更强的浏览器。另一方面是“优雅降级”，即某项功能的缺失不会造成浏览器出错或发生故障，而是应该向用户提供一些削弱的功能或替代能力。对于旧版浏览器来说，不必将优雅降级作为默认选择。在许多情况下，甚至可能不是最佳选择。相反，在Modernizr的帮助下，你通常可以使用许多可用的浏览器polyfill，将类似于HTML5的功能添加到不支持HTML5的浏览器中。\r\n什么是Polyfill？\r\n\r\n根据Modernizr网站的说法，polyfill是“在旧版浏览器上复制标准API的JavaScript补充”。“标准API”指的是HTML5技术或功能，例如Canvas。“JavaScript补充”指的是可以动态地加载JavaScript代码或库，在不支持这些标准API的浏览器中模拟它们。例如，geolocation（地理位置）polyfill可以在navigator对象上添加全局的geolocation对象，还能添加getCurrentPosition函数以及“坐标”回调对象，所有这些都是W3C地理位置API定义的对象和函数。因为polyfill模拟标准API，所以能够以一种面向所有浏览器未来的方式针对这些API进行开发，最终目标是：一旦对这些API的支持变成绝对大多数，则可以方便地去掉polyfill，无需做任何额外工作。\r\n通过在页面上添加对Modernizr的引用，我就得到了与示例相关的polyfill的直接好处。页面显示没有样式，是因为IE8不认识\r\n和\r\n标签。因为它不认识这些标签，所以没将它们加入DOM，而CSS选择元素要发挥样式作用，需要在DOM中有这些元素。\r\n当我在页面上添加\r\n。我之所以得到这个好处，是因为Modernizr用JavaScript（document.CreateElement(‘nav’)）手动地将所有HTML5的新标签添加到DOM，这样CSS就能选择标签并给标签加上样式。\r\n除了在IE中添加对新的HTML5元素的支持外，Modernizr库默认不提供任何额外的polyfill。额外的polyfill需要自行提供，或者使用自己的脚本，或者从Modernizr网站上日益增加的选项列表中选择一个。在2.0版中，Modernizr提供了一个条件脚本加载器（基于yepnope.js—yepnopejs.com），可以帮助你只在需要的时候异步下载polyfill库。使用Modernizr配合一个或多个polyfill库来提供需要的功能，是一个强大的组合\r\n使用Polyfill模拟HTML5功能\r\n\r\n对于Canvas来说，在Modernizr和JavaScript库excanvas的帮助下，用polyfill可以在IE8及之前的版本中实现Canvas支持，可以在IE6、IE7和IE8上添加API级别的Canvas支持。可以从bit.ly/bSgyNR下载excanvas，将它添加到自己的脚本文件夹，然后在页面的脚本块中添加一些代码。\r\n用Modernizr和Polyfill实现Canvas支持\r\n\r\n    Modernizr.load({\r\n  test: Modernizr.canvas,\r\n  nope: '../js/excanvas.js',\r\n  complete: function () {\r\n    Modernizr.load('../js/html5CanvasLogo.js');\r\n  }\r\n}]);\r\n\r\n在这里，我使用Modernizr脚本加载器指定了三件事：\r\n1.      用来测试的Boolean表达式。\r\n2.      表达式测试为false时，加载脚本的路径。\r\n3.      检查或脚本加载完成时运行的回调。\r\n对于Canvas来说，在应用程序中要添加的智能处理和polyfill就是这些了。Modernizr会异步加载excanvas.js，而且只会为那些不支持Canvas的浏览器加载，然后加载脚本库，在页面上绘制出HTML5标识。\r\n下面来看另外一个示例来理解Modernizr的价值. 重视细节的你可能已经注意到，图4中网站的样式与图1中在IE9中显示的原始页面相同。这个页面在IE8中显示时没有阴影和圆角，而我不可能让网站在没有这两个效果的情况下丑陋地交付出去，所以我们再次求助于Modernizr。\r\n同处理Canvas一样，Modernizr可以告诉我CSS模块不受支持，但提供一个填补（polyfill）这些CSS模块的库，要我来做。幸运的是，有个名为PIE (css3pie.com)的库在一个库中提供了这两个模块。\r\n为了增加对圆角和阴影的支持，在下载了PIE之后，我可以将图6中的代码加入脚本。这次，我要测试是否支持圆角或阴影模块（而不是假定两者都支持或都不支持），如果有哪个模块不支持，则动态地加载PIE.js。PIE加载完成后，我再执行一段jQuery代码选择全部\r\n标签，并调用PIE.attach函数，添加CSS中已经定义的圆角和阴影样式。\r\n\r\n    Modernizr.load({\r\n  test: Modernizr.borderradius || Modernizr.boxshadow,\r\n  nope: '../js/PIE.js',\r\n  callback: function () {\r\n    $('article').each(function () {\r\n      PIE.attach(this);\r\n    });\r\n  }\r\n});\r\n\r\n                   \r\n使用polyfill协助进行优雅降级\r\n除了使用这里讨论的polyfill技术，在希望应用程序优雅降级的地方也可以借助于Modernizr，而不是用另一个库进行填补（polyfill）。\r\n假设网页上有一个Bing Maps控件，而且我希望使用Geolocation（我将在以后的文章中深入介绍）来确定用户当前位置，然后将这个位置作为大头钉放在地图控件上。\r\n虽然新版本的浏览器都支持Geolocation，但在旧版浏览器中并不支持。纯粹使用JavaScript提供完整的Geolocation支持还确实有些麻烦，即使有针对Geolocation的填补（polyfill）实现起来也不轻松，所以我决定要对自己的应用程序进行优雅降级。当用户的浏览器不支持Geolocation时，我会提供一个表单，用户可以在表单中手动输入位置，我将用用户输入的位置定位和固定地图。\r\n通过Modernizr，只要用一个简单的加载脚本，调用我创建的两个脚本中的一个即可，如图8所示。在这个示例中，我测试的是Modernizr.geolocation属性。如果为true（“yep”分支），就加载fullGeolocation.js脚本，这个脚本使用Geolocation API定位（要得到用户许可），并将位置放在地图上，如图9所示。如果测试为false（“nope”分支），则加载备用脚本，在页面上显示一个地址表单。用户提交表单时，我会使用用户提供的地址将地图居中并固定，如图10所示。这样，我的页面为最新的浏览器提供了优秀的体验，同时对旧版浏览器提供了降级到合理替代品的优雅方式。\r\n\r\n    Modernizr.load({\r\n  test: Modernizr.geolocation,\r\n  yep: '../js/fullGeolocation.js',\r\n  nope: '../js/geolocationFallback.js'\r\n});\r\n\r\n在面对庞大的用户群仍然使用旧版浏览器的时候，很容易认为HTML5的一些高级功能对你的网站不适用。但是现在已经有了很好的解决方案，不仅能够帮助你优雅地降级，还能提升旧版浏览器的能力，让你的用户立即就能体验到HTML5的能力。在本文中，你看到了功能检测、Modernizr和polyfill，所以你可以毫不迟疑地采用HTML5，既满足日益增长的使用最新浏览器的用户，又不会丢失使用旧版浏览器的庞大用户群。\r\n以上内容来自于：http://msdn.microsoft.com/en-us/magazine/hh394148.aspx\r\n","pubtime":{"$date":1353105428217},"title":"Internet Explorer 10 兼容性白皮书（二） 用HTML5构建应用程序","visited":48856,"links":[["51d3de828ece70c43800000e",{"present":0.052631578947368418131,"title":"Internet Explorer 10 兼容性白皮书（一） "}],["51d3dc538ece70c438000005",{"present":0.052631578947368418131,"title":"小心 -webkit-text-size-adjust:none！[译]"}],["52cfc44ad4cf86262b000001",{"present":0.052631578947368418131,"title":"HTML5 拖动（Drag）文件到文件夹下载"}],["51d3db928ece70c438000004",{"present":0.025641025641025640136,"title":"预加载和javascript Image()对象 "}],["528611f363c705fc73000001",{"present":0.025641025641025640136,"title":"javascript 文字大小自动适应文本框 （文字大小自动调整）"}],["51d3dcfc8ece70c438000007",{"present":0.025641025641025640136,"title":"div模拟textarea文本域轻松实现高度自适应"}],["53b37b9e4b7a6de506000001",{"present":0.025641025641025640136,"title":"HTML input 选色板 ( HTML5 Color Input )"}],["5524f05cfd9753d106000001",{"present":0.025641025641025640136,"title":"Window.postMessage() HTML5 跨域解决方案"}],["51d3de628ece70c43800000c",{"present":0.025641025641025640136,"title":"onhashchange与AJAX无缝刷新"}],["5349905d7eeca8ec50000001",{"present":0.025641025641025640136,"title":"manifest 详解以及规范"}],["51d3de728ece70c43800000d",{"present":0.025641025641025640136,"title":"javascript区分判断ie6、ie7、ie8"}]],"html":"<p>用HTML5构建应用程序</p>\n<p>HTML5的采用策略：一个浏览器也不放弃\n点击链接下载示例代码\nHTML5有许多激动人心的特性。有了新的标签、新的CSS能力和新的JavaScript API，Web的能力范围有了大的飞跃。除了浏览器厂商的士气高涨之外，令人激动的新功能列表几乎每天都在增加。从“nightly builds”（每夜都构建一版）到开发渠道发行版和正常的平台预览版，浏览器在飞速变化，世界各地Web开发人员们正在加入这个狂欢。</p>\n<p>但是，尽管开发和浏览器社区正在把HTML5的喧嚣推到一个极度兴奋的高潮，网上的大多数人却不像我们一样使用最新的浏览器和最新版本。如果你是一个大型开发机构的Web开发人员或者是拥有庞大用户群的大企业，那你对此可能很清楚。即使你为通过Web提供服务的小型机构或新创立的企业工作，你可能也要花上大量时间来确保自己的网站能够支持尽可能多的浏览器和浏览器版本。</p>\n<p>基于这一现实，很容易看出，HTML5还谈不到它是否已为当今的使用做好准备，而是你是否为它做好了准备。例如，假设你用一些新的语法标签（例如\n和\n）新建了一个页面，添加了一些新的CSS功能（例如圆角（border-radius）和阴影（box-shadow）），甚至添加了一个\n在较新的浏览器上，例如IE9、Firefox 4及以上版本、或者Google Chrome上。但如果尝试在IE8或更早的浏览器上加载页面，很有可能看到的是图2所示的效果：一个残缺不全的页面。\n如果你在研究HTML5的所有强大功能却得到上述体验之后告诉自己说：最好还是等等，那么我不会对你有任何责怪。如果我问你准备好了吗？你很容易得出这样的结论：HTML5还没有为你或你的用户做好准备。</p>\n<p>在你决定等到2022年再考虑HTML5的之前，我建议你继续阅读本文的后面部分，我将向你提供一些实用的策略，让你现在就能采用HTML5技术，同时避免出现图2所示的糟糕的降级情况。我将从下面三个主题进行详细地介绍：</p>\n<ol>\n<li>功能检测与用户代理（UA）嗅探比较</li>\n<li>用JavaScript实现填补（Polyfill）</li>\n<li>优雅降级</li>\n</ol>\n<p>这些应该可以教会你很多构建支持各种浏览器的网站所需要了解的知识。在本文结束时，你会拥有一个可靠的策略，可以充满自信、毫不犹豫地采用HTML5技术。你还会拥有一些工具在手，可以逐步地为新浏览器增强网站，同时更好地适应旧的浏览器。</p>\n<p>功能检测的重要性</p>\n<p>为了提供跨浏览器的稳定且一致的体验，开发人员经常需要获得一些关于用户浏览器的信息。以前的普遍做法是像下面这样用JavaScript检测这些信息：</p>\n<pre><code>varuserAgent = navigator.userAgent;\n</code></pre><p>if (userAgent.indexOf(&#39;MSIE&#39;) &gt;= 0) {\n    console.log(&quot;Hello, IE user&quot;);\n} else if (userAgent.indexOf(&#39;Firefox&#39;) &gt;= 0) {\n    console.log(&quot;Hello, Firefox user&quot;);\n} else if (userAgent.indexOf(&#39;Chrome&#39;) &gt;= 0) {\n    console.log(&quot;Hello, Chrome user&quot;);\n}\n这个技术称为用户代理（UA）嗅探，广泛地用于判断正在请求页面的是哪个浏览器。这里的思路是：知道了用户的浏览器（例如IE7），就能在运行的时候决定启用或禁用网站的哪项功能。UA嗅探就相当于对浏览器说：“你是谁？”（对UA嗅探以及其他检测技术的深入分析，请参阅bit.ly/mlgHHY。）\n这种做法的问题在于，浏览器会撒谎。UA字符串是一个用户可以配置的信息，并不会提供100%正确的浏览器信息。而且，随着这一技术的广泛采用，许多浏览器厂商在自己的UA字符串中增加了额外内容，用来欺骗脚本，让脚本对于实际使用的浏览器做出错误判断，从而避免检测。现在有些浏览器甚至提供小工具，允许用户只要轻轻点击几下鼠标，就能修改UA字符串。\nUA嗅探的目的从来就不是确定用户的浏览器和版本。而且它肯定也不是为了在你不喜欢用户使用的浏览器时，让你可以告诉用户说“请下载另一个浏览器”——即使有些人就是这样使用UA嗅探技术的。用户有权选择自己使用什么浏览器，开发人员的职责则是提供最可靠且一致的体验，不要把浏览器的偏好强加给用户。UA嗅探的目标是让你能够准确地了解在用户当前的浏览器中，有哪些能力或功能可以利用。对浏览器本身的了解，只是获得这些信息的一个途径。\n目前有一些UA嗅探的替代技术，其中一项正在日益流行的技术称为对象检测或功能检测。这两个术语多数时候可以互换使用，但本文统一使用“功能检测”（feature detection）。\n功能检测的目标是判断某项功能或能力在用户当前的浏览器中是否受支持。如果UA嗅探是问浏览器“你是谁”，“功能检测”就是问浏览器“你能干什么”，这个问题更直接，对于根据条件向用户提供功能来说，这种方法也更可靠。如果功能检测脚本实现正确，用户或浏览器将很难造假或错报功能支持。\n手动功能检测</p>\n<p>那么，与UA嗅探的示例相比，功能检测到底是什么样呢？为了回答这个问题，我们先来看看如果在IE8中查看前面的HTML5页面，如何解决出现的问题。</p>\n<pre><code>My Awesome SiteMy Awesome SiteAnArticleIsn&#39;t this awesome?\n</code></pre><p>IE9和IE8的显示效果有很大的差别。对于初学者来说，我的页面完全没有样式，因为这个页面的CSS并不存在。而且，页面底部丢失了好玩的HTML5盾牌。每个问题都可以轻松解决，而功能检测则是明确问题的第一步。\n两个问题的原因都很简单：对于IE8来说，\n、\n和</p>\n<pre><code>!!document.createElement(&#39;canvas&#39;).getContext\n</code></pre><p>这条语句做了好几件事。首先，它使用两个否定（!!）操作符强行将未定义的值显式地设为false。然后，它手动新建一个canvas元素，并将它加到DOM中。最后，它调用getContext函数，这是\n这是最基本的功能检测。利用这条语句以及其他类似语句，就有了查询浏览器所支持功能的更可靠方法。关于手动功能检测的更多信息，请参阅diveintohtml5.info/everything.html。\n使用Modernizr进行功能检测</p>\n<p>手动功能检测肯定是对UA嗅探的提高，但这种做法仍然需要你做大量工作来检测功能是否可用，以及在功能不存在的时候决定做什么。虽然Canvas示例很简单，只需要一行代码，但不是每个要检测的功能都这么简单——不同浏览器的检测代码也各不相同。例如，要检测是否支持前面使用的CSS3模块（border-radius和box-shadow）就有些麻烦。\n值得庆幸的是，Modernizr (modernizr.com) 提供了更好的方法。Modernizr是一个JavaScript库“……检测下一代 Web 技术（即源于HTML 5和CSS3规范的功能）的本地实现是否可用”。在页面上添加对Modernizr的引用可以提供四大功能：</p>\n<ol>\n<li>全面列出支持的功能，智能地加入标签，从而实现CSS的条件定义。</li>\n<li>一个JavaScript对象，方便进行基于脚本的功能检测。</li>\n<li>在运行的时候将全部HTML5新标签加入DOM，方便IE8和之前的IE浏览器（稍后就会知道不仅如此）。</li>\n<li><p>一个脚本加载器，可以根据条件将polyfill加载到页面中。\n本文对第1项不做进一步介绍，但鼓励你访问modernizr.com网站，学习这一功能及其余功能的文档。\n上面的第2项功能，可以将下面的代码：</p>\n<p>!!document.createElement(&#39;canvas&#39;).getContext\n改为这行代码：</p>\n<p>Modernizr.canvas\n这行代码会返回一个布尔值，表明页面是否支持Canvas元素。使用Modernizr比自行执行功能检测的好处是，Modernizr是一个经过良好测试、健壮的、广为采用的库，它已经完成了许多繁重的工作。Twitter、Google、Microsoft以及无数其他机构和开发人员都在使用Modernizr，你当然也可以使用。在ASP.NET MVC 3工具更新（2011年4月发布）中，Microsoft甚至随新的ASP.NET MVC应用程序一起配备了Modernizr。当然，我们迄今为止所做的，不过是检测是否支持</p>\n<p>if (Modernizr.canvas) {\n// 这里执行canvas代码。\n}\n根据附加的浏览器功能是否存在来给网站增加功能，这种做法称为“渐进式增强”，因为体验增强针对的能力更强的浏览器。另一方面是“优雅降级”，即某项功能的缺失不会造成浏览器出错或发生故障，而是应该向用户提供一些削弱的功能或替代能力。对于旧版浏览器来说，不必将优雅降级作为默认选择。在许多情况下，甚至可能不是最佳选择。相反，在Modernizr的帮助下，你通常可以使用许多可用的浏览器polyfill，将类似于HTML5的功能添加到不支持HTML5的浏览器中。\n什么是Polyfill？</p>\n</li>\n</ol>\n<p>根据Modernizr网站的说法，polyfill是“在旧版浏览器上复制标准API的JavaScript补充”。“标准API”指的是HTML5技术或功能，例如Canvas。“JavaScript补充”指的是可以动态地加载JavaScript代码或库，在不支持这些标准API的浏览器中模拟它们。例如，geolocation（地理位置）polyfill可以在navigator对象上添加全局的geolocation对象，还能添加getCurrentPosition函数以及“坐标”回调对象，所有这些都是W3C地理位置API定义的对象和函数。因为polyfill模拟标准API，所以能够以一种面向所有浏览器未来的方式针对这些API进行开发，最终目标是：一旦对这些API的支持变成绝对大多数，则可以方便地去掉polyfill，无需做任何额外工作。\n通过在页面上添加对Modernizr的引用，我就得到了与示例相关的polyfill的直接好处。页面显示没有样式，是因为IE8不认识\n和\n标签。因为它不认识这些标签，所以没将它们加入DOM，而CSS选择元素要发挥样式作用，需要在DOM中有这些元素。\n当我在页面上添加\n。我之所以得到这个好处，是因为Modernizr用JavaScript（document.CreateElement(‘nav’)）手动地将所有HTML5的新标签添加到DOM，这样CSS就能选择标签并给标签加上样式。\n除了在IE中添加对新的HTML5元素的支持外，Modernizr库默认不提供任何额外的polyfill。额外的polyfill需要自行提供，或者使用自己的脚本，或者从Modernizr网站上日益增加的选项列表中选择一个。在2.0版中，Modernizr提供了一个条件脚本加载器（基于yepnope.js—yepnopejs.com），可以帮助你只在需要的时候异步下载polyfill库。使用Modernizr配合一个或多个polyfill库来提供需要的功能，是一个强大的组合\n使用Polyfill模拟HTML5功能</p>\n<p>对于Canvas来说，在Modernizr和JavaScript库excanvas的帮助下，用polyfill可以在IE8及之前的版本中实现Canvas支持，可以在IE6、IE7和IE8上添加API级别的Canvas支持。可以从bit.ly/bSgyNR下载excanvas，将它添加到自己的脚本文件夹，然后在页面的脚本块中添加一些代码。\n用Modernizr和Polyfill实现Canvas支持</p>\n<pre><code>Modernizr.load({\n</code></pre><p>  test: Modernizr.canvas,\n  nope: &#39;../js/excanvas.js&#39;,\n  complete: function () {\n    Modernizr.load(&#39;../js/html5CanvasLogo.js&#39;);\n  }\n}]);</p>\n<p>在这里，我使用Modernizr脚本加载器指定了三件事：</p>\n<ol>\n<li>用来测试的Boolean表达式。</li>\n<li>表达式测试为false时，加载脚本的路径。</li>\n<li><p>检查或脚本加载完成时运行的回调。\n对于Canvas来说，在应用程序中要添加的智能处理和polyfill就是这些了。Modernizr会异步加载excanvas.js，而且只会为那些不支持Canvas的浏览器加载，然后加载脚本库，在页面上绘制出HTML5标识。\n下面来看另外一个示例来理解Modernizr的价值. 重视细节的你可能已经注意到，图4中网站的样式与图1中在IE9中显示的原始页面相同。这个页面在IE8中显示时没有阴影和圆角，而我不可能让网站在没有这两个效果的情况下丑陋地交付出去，所以我们再次求助于Modernizr。\n同处理Canvas一样，Modernizr可以告诉我CSS模块不受支持，但提供一个填补（polyfill）这些CSS模块的库，要我来做。幸运的是，有个名为PIE (css3pie.com)的库在一个库中提供了这两个模块。\n为了增加对圆角和阴影的支持，在下载了PIE之后，我可以将图6中的代码加入脚本。这次，我要测试是否支持圆角或阴影模块（而不是假定两者都支持或都不支持），如果有哪个模块不支持，则动态地加载PIE.js。PIE加载完成后，我再执行一段jQuery代码选择全部\n标签，并调用PIE.attach函数，添加CSS中已经定义的圆角和阴影样式。</p>\n<p>Modernizr.load({\ntest: Modernizr.borderradius || Modernizr.boxshadow,\nnope: &#39;../js/PIE.js&#39;,\ncallback: function () {\n$(&#39;article&#39;).each(function () {\nPIE.attach(this);\n});\n}\n});</p>\n</li>\n</ol>\n<p>使用polyfill协助进行优雅降级\n除了使用这里讨论的polyfill技术，在希望应用程序优雅降级的地方也可以借助于Modernizr，而不是用另一个库进行填补（polyfill）。\n假设网页上有一个Bing Maps控件，而且我希望使用Geolocation（我将在以后的文章中深入介绍）来确定用户当前位置，然后将这个位置作为大头钉放在地图控件上。\n虽然新版本的浏览器都支持Geolocation，但在旧版浏览器中并不支持。纯粹使用JavaScript提供完整的Geolocation支持还确实有些麻烦，即使有针对Geolocation的填补（polyfill）实现起来也不轻松，所以我决定要对自己的应用程序进行优雅降级。当用户的浏览器不支持Geolocation时，我会提供一个表单，用户可以在表单中手动输入位置，我将用用户输入的位置定位和固定地图。\n通过Modernizr，只要用一个简单的加载脚本，调用我创建的两个脚本中的一个即可，如图8所示。在这个示例中，我测试的是Modernizr.geolocation属性。如果为true（“yep”分支），就加载fullGeolocation.js脚本，这个脚本使用Geolocation API定位（要得到用户许可），并将位置放在地图上，如图9所示。如果测试为false（“nope”分支），则加载备用脚本，在页面上显示一个地址表单。用户提交表单时，我会使用用户提供的地址将地图居中并固定，如图10所示。这样，我的页面为最新的浏览器提供了优秀的体验，同时对旧版浏览器提供了降级到合理替代品的优雅方式。</p>\n<pre><code>Modernizr.load({\n</code></pre><p>  test: Modernizr.geolocation,\n  yep: &#39;../js/fullGeolocation.js&#39;,\n  nope: &#39;../js/geolocationFallback.js&#39;\n});</p>\n<p>在面对庞大的用户群仍然使用旧版浏览器的时候，很容易认为HTML5的一些高级功能对你的网站不适用。但是现在已经有了很好的解决方案，不仅能够帮助你优雅地降级，还能提升旧版浏览器的能力，让你的用户立即就能体验到HTML5的能力。在本文中，你看到了功能检测、Modernizr和polyfill，所以你可以毫不迟疑地采用HTML5，既满足日益增长的使用最新浏览器的用户，又不会丢失使用旧版浏览器的庞大用户群。\n以上内容来自于：<a href=\"http://msdn.microsoft.com/en-us/magazine/hh394148.aspx\">http://msdn.microsoft.com/en-us/magazine/hh394148.aspx</a></p>\n"}
